<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Perl programming news, code and culture</title>
    <link>http://perltricks.com/</link>
    <description>Recent content on Perl programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 02 Oct 2016 10:51:01 +0000</lastBuildDate>
    <atom:link href="http://perltricks.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Hacktoberfest is here</title>
      <link>http://perltricks.com/article/hacktoberfest-is-here/</link>
      <pubDate>Sun, 02 Oct 2016 10:51:01 +0000</pubDate>
      
      <guid>http://perltricks.com/article/hacktoberfest-is-here/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://hacktoberfest.digitalocean.com/&#34;&gt;Hacktoberfest&lt;/a&gt; is here, and you can be part of the effort to make Perl the most popular language in the month long festival of patches and pull requests.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.digitalocean.com/&#34;&gt;DigitalOcean&lt;/a&gt; and &lt;a href=&#34;https://www.github.com/&#34;&gt;GitHub&lt;/a&gt; have teamed up to encourage new users to participate in open source. Make four pull requests to any GitHub project and they&amp;rsquo;ll give you a limited-edition Hacktoberfest t-shirt. It might not sound like much, but consider what you get besides the shirt: you&amp;rsquo;re in the commit logs of four projects and your profile has some history. That&amp;rsquo;s the first step in building your open source résumé.&lt;/p&gt;

&lt;p&gt;The sponsors suggest that projects that want to participate label their issues with &amp;ldquo;Hacktoberfest&amp;rdquo;. That&amp;rsquo;s not strictly necessary, but you can &lt;a href=&#34;https://github.com/search?q=state%3Aopen+label%3Ahacktoberfest&amp;amp;type=Issues&#34;&gt;search&lt;/a&gt; for issues that projects think are suitable for new users. I think all of my projects are suitable (I may be optimistic), so I wanted a way to label all of my issues across all of my projects.&lt;/p&gt;

&lt;p&gt;I found out about this as I was building some other GitHub tools. I looked at &lt;a href=&#34;https://www.metacpan.org/module/Net::GitHub&#34;&gt;Net::GitHub&lt;/a&gt; and &lt;a href=&#34;https://www.metacpan.org/module/Pithub&#34;&gt;Pithub&lt;/a&gt;, but I wanted to iterate through long lists of paged results and process each item as I received them. The &lt;a href=&#34;https://developer.github.com/v3/&#34;&gt;GitHub Developer API&lt;/a&gt; is quite nice and even if you are re-inventing the wheel you&amp;rsquo;re learning about wheels, making this a fun night of work.&lt;/p&gt;

&lt;p&gt;The result is &lt;a href=&#34;https://github.com/briandfoy/ghojo/blob/master/examples/hacktoberfest.pl&#34;&gt;hacktoberfest.pl&lt;/a&gt; in my &lt;a href=&#34;https://github.com/briandfoy/ghojo&#34;&gt;ghojo&lt;/a&gt; repo. It will log in, list all of my repos (there are a couple hundred), create the &amp;ldquo;Hacktoberfest&amp;rdquo; label in each, and then apply the label to each open issue.&lt;/p&gt;

&lt;p&gt;The ghojo project is still very much in its infancy (which means there&amp;rsquo;s all sorts of pull request opportunities). But I allow quite a bit of flexibility by accepting a callback for things I expect to return many items:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Ghojo;

my $ghojo = Ghojo-&amp;gt;new( { token =&amp;gt; ... } );

my $callback = sub {
  my $item = shift;
  ...
  };

$ghojo-&amp;gt;repos( $repo_callback );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each time I find a repo—and you don&amp;rsquo;t have to know how I do that—I run that callback. It&amp;rsquo;s a little bit like &lt;a href=&#34;https://www.metacpan.org/module/File::Find&#34;&gt;File::Find&lt;/a&gt;&amp;rsquo;s use of the &lt;code&gt;wanted&lt;/code&gt; coderef. You don&amp;rsquo;t see the very nice API paging going on either; &lt;code&gt;repos&lt;/code&gt; keeps fetching more results as long as there are more results.&lt;/p&gt;

&lt;p&gt;That callback deals with a repo, but each repo has a list of issues. I want to process this list of issues as I run into them. So what I need is a callback to process a repo with a nested callback for the issues:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use v5.24;

use Ghojo;

my $ghojo = Ghojo-&amp;gt;new( { token =&amp;gt; ... } );

my $label_name = &#39;Hacktoberfest&#39;;

my $callback = sub ( $item ) {
  my( $user, $repo ) = split m{/}, $item-&amp;gt;{full_name};

  my $repo = $ghojo-&amp;gt;get_repo_object( $owner, $repo );

  # get the labels for that repo
  my %labels = map { $_-&amp;gt;@{ qw(name color) } } $repo-&amp;gt;labels-&amp;gt;@*;

  unless( exists $labels{$label_name} ) {
    my $rc = $repo-&amp;gt;create_label( $label_name, &#39;ff5500&#39; );
    say &amp;quot;\tCreated $label_name label&amp;quot; if $rc;
    }

  my $callback = sub ( $item ) {
    $repo-&amp;gt;add_labels_to_issue( $item-&amp;gt;{number}, $label_name );
    return $item;
    };

  my $issues = $repo-&amp;gt;issues( $callback );

  return $repo;
  };


$ghojo-&amp;gt;repos( $repo_callback );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Curiously, within a couple of hours of uploading the program, I received my first Hacktoberfest &lt;a href=&#34;https://github.com/briandfoy/ghojo/pull/14&#34;&gt;pull request&lt;/a&gt;. &lt;a href=&#34;https://github.com/haydenty&#34;&gt;haydenty&lt;/a&gt; added the &lt;a href=&#34;https://github.com/briandfoy/ghojo/blob/master/CONTRIBUTING.md&#34;&gt;CONTRIBUTING.md&lt;/a&gt; file to my ghojo repo. It&amp;rsquo;s something I&amp;rsquo;ve been meaning to add to all of my repos. Now I&amp;rsquo;m considering adding an issue to each repo to note that and label each one &amp;ldquo;Hacktoberfest&amp;rdquo;. Or someone who wants to get started with something simple can create the issues for me, or send the pull requests right off.&lt;/p&gt;

&lt;p&gt;If you have lots of repos, label your issues to help push Perl up in &lt;a href=&#34;https://github.com/search?q=state%3Aopen+label%3Ahacktoberfest&amp;amp;type=Issues&#34;&gt;the rankings&lt;/a&gt;. By the time we reach the end of the month, I&amp;rsquo;ll have a program to reverse the labeling.&lt;/p&gt;

&lt;p&gt;Some of this I&amp;rsquo;m doing for fun, and some of this I&amp;rsquo;m doing because some organizations want better GitHub tools. Somehow how October is when all of that is coming together. If you&amp;rsquo;d like me to work on this sort of stuff for you, &lt;a href=&#34;mailto:brian.d.foy@gmail.com&#34;&gt;let me know&lt;/a&gt;! But submit those pull requests first so you get that t-shirt.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Don&#39;t forget to #Perl</title>
      <link>http://perltricks.com/article/don-t-forget-to--perl/</link>
      <pubDate>Wed, 28 Sep 2016 08:05:37 +0000</pubDate>
      
      <guid>http://perltricks.com/article/don-t-forget-to--perl/</guid>
      <description>&lt;p&gt;When it comes to open source communities, programming comes first, but talking about programming is a close second. Perl programmers are pretty good about blogging (the &lt;a href=&#34;https://github.com/dnmfarrell/Perly-Bot&#34;&gt;Perly-Bot app&lt;/a&gt; that populates our community articles sidebar tracks around 30 blogs), but I&amp;rsquo;ve noticed that on Twitter, many Perl-related tweets lack a &lt;code&gt;#Perl&lt;/code&gt; hashtag. That&amp;rsquo;s a shame, as it helps others discover Perl related tweets via search, clicking the hashtag and in the &amp;ldquo;highlights&amp;rdquo; notification on the Twitter mobile app.&lt;/p&gt;

&lt;p&gt;Sometimes you may not want to include a Perl hashtag: perhaps you&amp;rsquo;ve hit the tweet character limit (&lt;code&gt;#Per&lt;/code&gt; is no good!) or maybe you&amp;rsquo;re blogging about several languages including Perl, and don&amp;rsquo;t want to dissuade non-Perl programmers from clicking the link. There are probably many scenarios where it doesn&amp;rsquo;t make sense to include the hashtag, and that&amp;rsquo;s fine. For everything else, there is &lt;code&gt;#Perl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Hashtags are case insensitive so &lt;code&gt;#Perl&lt;/code&gt; and &lt;code&gt;#perl&lt;/code&gt; are good, but I wouldn&amp;rsquo;t &lt;code&gt;#PERL&lt;/code&gt; unless you&amp;rsquo;re trolling (yw trolls!). Unlike many programming languages, our favorite language has a unique name (kind of - there is the Perl &lt;a href=&#34;http://www.surnamedb.com/Surname/Perl&#34;&gt;surname&lt;/a&gt;). Let&amp;rsquo;s take advantage of it by including &lt;code&gt;#Perl&lt;/code&gt; in our tweets. If enough of us do it, who knows, we might even start trending again.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5 things I learned from Learning Perl 7th Edition</title>
      <link>http://perltricks.com/article/5-things-i-learned-from-learning-perl-7th-edition/</link>
      <pubDate>Fri, 23 Sep 2016 08:12:54 +0000</pubDate>
      
      <guid>http://perltricks.com/article/5-things-i-learned-from-learning-perl-7th-edition/</guid>
      <description>

&lt;p&gt;The 7th edition of &lt;a href=&#34;https://www.learning-perl.com/&#34;&gt;Learning Perl&lt;/a&gt; is due to be released later this month. I was one of the technical reviewers of the book - I hadn&amp;rsquo;t read it since the 3rd edition where it was a course text at my University (and Perl was described as a &amp;ldquo;text processing language&amp;rdquo;!). Reviewing the book, I was struck by how much detail it contained. If you&amp;rsquo;re looking for a thorough introduction to Perl, it&amp;rsquo;s a great place to start. I picked up (or re-learned) a few tricks along the way, that I thought were worth sharing.&lt;/p&gt;

&lt;h3 id=&#34;1-stacked-file-test-operators:20798fba47491e24e703587c4db3eaa3&#34;&gt;1. Stacked file test operators&lt;/h3&gt;

&lt;p&gt;You probably know that Perl supports a bunch of &lt;a href=&#34;http://perldoc.perl.org/functions/-X.html&#34;&gt;file test operators&lt;/a&gt; that do useful things like check if a file exists, if it&amp;rsquo;s readable and so on:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;  if (-e $filepath &amp;amp;&amp;amp; -r $filepath) {
    ... 
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But did you know that since version 5.10, you can stack file test operators?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;  if (-e -r $filepath) {
    ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way is cleaner and shorter. Oh and bonus! file test operators work on filehandles too. Stacked file operators are not part of the &lt;a href=&#34;http://perldoc.perl.org/feature.html&#34;&gt;feature&lt;/a&gt; pragma, so an explicit &lt;code&gt;use 5.10.0;&lt;/code&gt; is not required, although if your code is going to be shared, you should probably include it.&lt;/p&gt;

&lt;h3 id=&#34;2-glob-s-checkered-past:20798fba47491e24e703587c4db3eaa3&#34;&gt;2. Glob&amp;rsquo;s checkered past&lt;/h3&gt;

&lt;p&gt;Learning Perl has a lot of anecdotes about Perl history in it. You might have used the &lt;code&gt;glob&lt;/code&gt; function before:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @json_files = glob &#39;*.json&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns all file names ending in &lt;code&gt;.json&lt;/code&gt; in the current working directory. Glob takes a string of patterns separated by whitespace, so you can provide multiple patterns:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;  my @config_files = glob &#39;*.json *.toml *.ini&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of using the word &lt;code&gt;glob&lt;/code&gt; you can use angle brackets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;  my @json_files = &amp;lt;*.json&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These angle brackets treat the text between them like a double-quoted string. One thing I learned was that ancient versions of Perl (pre 5.6) simply called &lt;code&gt;/bin/csh&lt;/code&gt; every time they encountered &lt;code&gt;glob&lt;/code&gt;! This made globbing slow, and directory handles were preferred over &lt;code&gt;glob&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;3-perl-supports-inline-binary-notation:20798fba47491e24e703587c4db3eaa3&#34;&gt;3. Perl supports inline binary notation&lt;/h3&gt;

&lt;p&gt;In many C-based languages you can write numbers in hexadecimal and octal notation, and you can in Perl too:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;  my $byte_max = 0xff;
  my $permissions = 0755;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Perl though, you can also write binary numbers inline, with the prefix &lt;code&gt;0b&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;  my $bits = 0b10111000;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can make it easier to work with binary data; instead of using hexadecimal notation and doing the mental arithmetic to calculate values, you can write binary data inline. For example, let&amp;rsquo;s say you are reviewing some code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;  if ($bit_array &amp;amp; 0x40) {
    ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To understand this example in hexadecimal, you have to calculate that 4 * 16 = 64, and then either just know, or convert that number to binary to find out that the 7th bit is flipped, and understand that this is testing whether &lt;code&gt;$bit_array&lt;/code&gt; has that bit flipped too. Here&amp;rsquo;s the same code with inline binary:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;  if ($bit_array &amp;amp; 0b1000000) {
    ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, you can just see that the 7th bit is flipped, and the intent of the if statement becomes obvious. If you&amp;rsquo;re interested in understanding bit arrays and bitwise operators, I recently wrote an &lt;a href=&#34;http://perltricks.com/article/save-space-with-bit-arrays/&#34;&gt;introduction&lt;/a&gt; to them.&lt;/p&gt;

&lt;h3 id=&#34;4-check-an-installed-module-is-up-to-date:20798fba47491e24e703587c4db3eaa3&#34;&gt;4. Check an installed module is up to date&lt;/h3&gt;

&lt;p&gt;These days we have so many advanced Perl package installers like &lt;a href=&#34;https://metacpan.org/pod/App::cpanminus&#34;&gt;cpanm&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/distribution/App-cpm/script/cpm&#34;&gt;cpm&lt;/a&gt; it&amp;rsquo;s easy to forget that the basic CPAN client can do a lot too. For instance, the &lt;code&gt;-D&lt;/code&gt; option checks the installed version of a module and compares it to the latest version on CPAN. So to check if the &lt;code&gt;Test::More&lt;/code&gt; module is up to date, at the terminal I can enter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cpan -D Test::More

CPAN: Storable loaded ok (v2.53)
Reading &#39;/home/dfarrell/.local/share/.cpan/Metadata&#39;
  Database was generated on Thu, 22 Sep 2016 21:53:30 GMT
Test::More
-------------------------------------------------------------------------
      (no description)
      E/EX/EXODIST/Test-Simple-1.302056.tar.gz
      /home/dfarrell/.plenv/versions/5.22.0/lib/perl5/5.22.0/Test/More.pm
      Installed: 1.001014
      CPAN:      1.302056  Not up to date
      Chad Granum (EXODIST)
      exodist7@gmail.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Woah, mine is pretty out of date. I should upgrade &amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;5-avoiding-the-shell-for-system-commands:20798fba47491e24e703587c4db3eaa3&#34;&gt;5. Avoiding the shell for system commands&lt;/h3&gt;

&lt;p&gt;The Perl built-in functions &lt;a href=&#34;http://perldoc.perl.org/functions/exec.html&#34;&gt;exec&lt;/a&gt; and &lt;a href=&#34;http://perldoc.perl.org/functions/system.html&#34;&gt;system&lt;/a&gt; &lt;em&gt;may&lt;/em&gt; invoke the shell when running a system command. Generally you want to avoid this as invoking the shell is slower than executing the command directly. Perl looks at the first argument passed to &lt;code&gt;exec&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt; and if it contains shell &lt;a href=&#34;http://faculty.salina.k-state.edu/tim/unix_sg/shell/metachar.html&#34;&gt;metacharacters&lt;/a&gt; invokes the shell.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $command = join &amp;quot; &amp;quot;, $program, $arg1, $arg2;
system $command; # may invoke shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So let&amp;rsquo;s say you need to invoke a system command, and you&amp;rsquo;re not sure whether the command arguments will contain metacharacters or not. If they do, the shell will be invoked and any metacharacters will be interpolated. One way to avoid the shell interpolating metacharacters is to escape them. But shell escape sequences are rarely simple (e.g. &lt;a href=&#34;https://stackoverflow.com/questions/1250079/how-to-escape-single-quotes-within-single-quoted-strings#1250279&#34;&gt;escaping a single quote&lt;/a&gt;). Learning Perl shows a better way: passing a list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;system $program, $arg1, $arg2; # never invokes the shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will never invoke the shell, and avoid metacharacter interpolation.&lt;/p&gt;

&lt;h3 id=&#34;pre-order-learning-perl-now:20798fba47491e24e703587c4db3eaa3&#34;&gt;Pre-order Learning Perl now&lt;/h3&gt;

&lt;p&gt;Learning Perl 7th Edition has nearly 400 pages describing the Perl syntax, and how to accomplish important tasks like file IO, process management and module installations. It&amp;rsquo;s available for pre-order now on &lt;a href=&#34;https://goo.gl/DvCB14&#34;&gt;Amazon&lt;/a&gt; (that&amp;rsquo;s an affiliate link for brian d foy, the author of this edition). You can also get it from the publisher, &lt;a href=&#34;http://shop.oreilly.com/product/0636920049517.do&#34;&gt;O&amp;rsquo;Reilly&lt;/a&gt;. Check out the book&amp;rsquo;s offical &lt;a href=&#34;https://www.learning-perl.com/&#34;&gt;website&lt;/a&gt; where brian has been blogging about the new edition.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using bit arrays with large integers</title>
      <link>http://perltricks.com/article/using-bitmasks-with-large-integers/</link>
      <pubDate>Thu, 15 Sep 2016 17:40:12 +0000</pubDate>
      
      <guid>http://perltricks.com/article/using-bitmasks-with-large-integers/</guid>
      <description>

&lt;p&gt;A few weeks ago I wrote &lt;a href=&#34;http://perltricks.com/article/save-space-with-bit-arrays/&#34;&gt;Save space with bit arrays&lt;/a&gt; and employed some hand-waving around maximum bitmask lengths. Specifically, I said:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;using a module like bigint may not work because of addressable memory limitations&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now I&amp;rsquo;m not sure exactly where the &amp;ldquo;addressable memory limitation&amp;rdquo; line is, but this was something that I&amp;rsquo;d read elsewhere, and believed to be true, but didn&amp;rsquo;t have time to research. The more I thought about it, the less sense that sentence made. The amount of memory a system can address is controlled by &lt;a href=&#34;https://superuser.com/questions/168114/how-much-memory-can-a-64bit-machine-address-at-a-time#168121&#34;&gt;many factors&lt;/a&gt;, but I don&amp;rsquo;t believe you&amp;rsquo;d ever want to create a bit array using all the addressable memory just for storing bitmasks. I decided to test bit arrays with large integers and see if they behaved correctly under &lt;a href=&#34;https://metacpan.org/pod/bigint&#34;&gt;bigint&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;testing-large-bitmasks:45b406225733c523a87ffdfd363b9d74&#34;&gt;Testing large bitmasks&lt;/h3&gt;

&lt;p&gt;For these tests I wanted to check the typical operations that a bit array would be used for: setting / unsetting a bitmask and converting the bit array into a binary string. I came up with the follow test script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;#!/usr/bin/env perl
use strict;
use warnings;
use bigint;
use Test::More tests =&amp;gt; 60;

for my $shift_size (8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096) {
  my $bitmask  = 1 &amp;lt;&amp;lt; ($shift_size - 1);
  my $bit_array = 0;

  ok !($bit_array &amp;amp; $bitmask),  &#39;bitmask is not set&#39;;
  ok $bit_array |= $bitmask,    &#39;set bitmask&#39;;
  ok $bit_array  &amp;amp; $bitmask,    &#39;bitmask is set&#39;;
  ok !($bit_array &amp;amp;= ~$bitmask),&#39;bitmask is unset&#39;;
  ok !($bit_array &amp;amp; $bitmask),  &#39;bitmask is not set&#39;;

  cmp_ok length(sprintf &amp;quot;%b&amp;quot;, $bitmask), &#39;==&#39;, $shift_size,
    &#39;bitmask string is correct length&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script loops over numbers of increasing size, creating bitmasks with them, and then testing the bit array against the bitmask. The bitwise operations were explained in my previous &lt;a href=&#34;http://perltricks.com/article/save-space-with-bit-arrays/&#34;&gt;article&lt;/a&gt;. Finally the script uses &lt;code&gt;sprintf&lt;/code&gt; to convert the bitmask to a binary string, and check its length is correct. Running this script I got some interesting failures. Here&amp;rsquo;s a snippet of the output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
not ok 24 - bitmask string is correct length
#   Failed test &#39;bitmask string is correct length&#39;
#   at ./bigint-test line 18.
#          got: 64
#     expected: 128
ok 25 - bitmask is not set
ok 26 - set bitmask
ok 27 - bitmask is set
ok 28 - bitmask is unset
ok 29 - bitmask is not set
not ok 30 - bitmask string is correct length
#   Failed test &#39;bitmask string is correct length&#39;
#   at ./bigint-test line 18.
#          got: 64
#     expected: 256
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whilst all of the bitwise operations passed, the string length test failed as soon as the bitmask size was larger than 64 bits (my machine is 64 bit, I expect on a 32 bit compiled Perl it would fail after 32 bits). So what to do about this? Is it that &lt;code&gt;sprintf&lt;/code&gt; cannot print integers larger than 64 bit? After trying a bunch of different functions, I tried the simplest: including a length argument to &lt;code&gt;sprintf&lt;/code&gt;. So this line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cmp_ok length(sprintf &amp;quot;%b&amp;quot;, $bitmask), &#39;==&#39;, $shift_size,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Became:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cmp_ok length(sprintf &amp;quot;%0${shift_size}b&amp;quot;, $bitmask), &#39;==&#39;, $shift_size,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m pleased to report that the change worked, and all tests passed (on Perl 5.10 and higher). Here is the finished script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;#!/usr/bin/env perl
use strict;
use warnings;
use bigint;
use Test::More tests =&amp;gt; 60;

for my $shift_size (8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096) {
  my $bitmask  = 1 &amp;lt;&amp;lt; ($shift_size - 1);
  my $bit_array = 0;

  ok !($bit_array &amp;amp; $bitmask),  &#39;bitmask is not set&#39;;
  ok $bit_array |= $bitmask,    &#39;set bitmask&#39;;
  ok $bit_array  &amp;amp; $bitmask,    &#39;bitmask is set&#39;;
  ok !($bit_array &amp;amp;= ~$bitmask),&#39;bitmask is unset&#39;;
  ok !($bit_array &amp;amp; $bitmask),  &#39;bitmask is not set&#39;;

  cmp_ok length(sprintf &amp;quot;%0${shift_size}b&amp;quot;, $bitmask), &#39;==&#39;, $shift_size,
    &#39;bitmask string is correct length&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m not sure at what point you would hit &amp;ldquo;addressable memory limitations&amp;rdquo;, but a 4096 bit integer is a huge number. This suggests to me that you &lt;em&gt;could&lt;/em&gt; use a 4096 bit array with Perl, although whether you &lt;em&gt;should&lt;/em&gt; is another question, TIMTOWTDI.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What&#39;s new on CPAN - August 2016</title>
      <link>http://perltricks.com/article/what-s-new-on-cpan---august-2016/</link>
      <pubDate>Wed, 07 Sep 2016 02:46:10 +0000</pubDate>
      
      <guid>http://perltricks.com/article/what-s-new-on-cpan---august-2016/</guid>
      <description>

&lt;p&gt;Welcome to &amp;ldquo;What&amp;rsquo;s new on CPAN&amp;rdquo;, a curated look at last month&amp;rsquo;s new CPAN uploads for your reading and programming pleasure. Enjoy!&lt;/p&gt;

&lt;h3 id=&#34;apis-apps:1723d238fdf5897b662b370d57878ca8&#34;&gt;APIs &amp;amp; Apps&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/API::Medium&#34;&gt;API::Medium&lt;/a&gt; is a Perl interface for Medium&amp;rsquo;s RESTful API&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/App::Critique&#34;&gt;App::Critique&lt;/a&gt; is a Perl Critic based app for progressively critiquing code. Looks interesting&lt;/li&gt;
&lt;li&gt;Get ISBN data via the xISBN service with &lt;a href=&#34;https://metacpan.org/pod/Business::xISBN&#34;&gt;Business::xISBN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/App::opan&#34;&gt;App::opan&lt;/a&gt; is a private CPAN server for managing Perl modules, similar to Pinto&lt;/li&gt;
&lt;li&gt;Get a perly interface to the mailboxlayer.com API (email verification service) with &lt;a href=&#34;https://metacpan.org/pod/Net::Mailboxlayer&#34;&gt;Net::Mailboxlayer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/WebService::Mailgun&#34;&gt;WebService::Mailgun&lt;/a&gt; lets you send and receive email via mailgun, an email service&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Net::Statsite::Client&#34;&gt;Net::Statsite::Client&lt;/a&gt; provides an OO interface to Statsite, the open source, C implementation of statsd&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;config-devops:1723d238fdf5897b662b370d57878ca8&#34;&gt;Config &amp;amp; Devops&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Global::MutexLock&#34;&gt;Global::MutexLock&lt;/a&gt; is an XS-based module that implements system mutexes via System V IPC Ids. Might be Linux only &amp;hellip;&lt;/li&gt;
&lt;li&gt;Escape strings for the shell on Linux, UNIX or MSWin32 using &lt;a href=&#34;https://metacpan.org/pod/ShellQuote::Any&#34;&gt;ShellQuote::Any&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/XAS::Logmon&#34;&gt;XAS::Logmon&lt;/a&gt; can manage and monitor log files&lt;/li&gt;
&lt;li&gt;Manage a Buildbot instance via the v2 API using &lt;a href=&#34;https://metacpan.org/pod/REST::Buildbot&#34;&gt;REST::Buildbot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;data:1723d238fdf5897b662b370d57878ca8&#34;&gt;Data&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Extract recent CPAN Testers results with &lt;a href=&#34;https://metacpan.org/pod/CPAN::Testers::TailLog&#34;&gt;CPAN::Testers::TailLog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parse Band-in-a-Box (music software) data files with &lt;a href=&#34;https://metacpan.org/pod/Data::BiaB&#34;&gt;Data::BiaB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Convert iRealBook/iRealPro data using &lt;a href=&#34;https://metacpan.org/pod/Data::iRealPro&#34;&gt;Data::iRealPro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Imager::Trim&#34;&gt;Imager::Trim&lt;/a&gt; provides automatic cropping for images using Imager&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Monorail&#34;&gt;Monorail&lt;/a&gt; is a database migration tool, inspired by django migrations&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;development-version-control:1723d238fdf5897b662b370d57878ca8&#34;&gt;Development &amp;amp; Version Control&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Grep::Query&#34;&gt;Grep::Query&lt;/a&gt; is an advanced expression evaluator with its own DSL&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Net::WinRM&#34;&gt;Net::WinRM&lt;/a&gt; access WMI classes using WinRM (documentation can be found in &lt;a href=&#34;https://metacpan.org/source/KARASIK/Net-WinRM-1.00/winrm&#34;&gt;winrm&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Get parallel processing using pipe(2) with &lt;a href=&#34;https://metacpan.org/pod/Parallel::Pipes&#34;&gt;Parallel::Pipes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Paws::Kinesis::MemoryCaller&#34;&gt;Paws::Kinesis::MemoryCaller&lt;/a&gt; provides a local in-memory implementation of AWS Kinesis; the stream processing service. Useful for testing?&lt;/li&gt;
&lt;li&gt;Get subroutine success/failure information with &lt;a href=&#34;https://metacpan.org/pod/Process::Results&#34;&gt;Process::Results&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Term::Form&#34;&gt;Term::Form&lt;/a&gt; processes STDIN input, similar to readline&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;hardware:1723d238fdf5897b662b370d57878ca8&#34;&gt;Hardware&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Perl interface to Raspberry Pi&amp;rsquo;s board/GPIO pin functionality with &lt;a href=&#34;https://metacpan.org/pod/RPi::WiringPi&#34;&gt;RPi::WiringPi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/UAV::Pilot::Wumpus::Server&#34;&gt;UAV::Pilot::Wumpus::Server&lt;/a&gt; is a server for contrlling drones via &lt;a href=&#34;https://metacpan.org/release/TMURRAY/UAV-Pilot-Wumpus-0.586092716855095&#34;&gt;UAV::Pilot::Wumpus&lt;/a&gt; (I&amp;rsquo;ve used a direct link as the module doesn&amp;rsquo;t seem to be indexed on MetaCPAN).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;science-mathematics:1723d238fdf5897b662b370d57878ca8&#34;&gt;Science &amp;amp; Mathematics&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Make a confusion matrix with &lt;a href=&#34;https://metacpan.org/pod/AI::ConfusionMatrix&#34;&gt;AI::ConfusionMatrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Digest::FarmHash&#34;&gt;Digest::FarmHash&lt;/a&gt; is an interface for Google&amp;rsquo;s FarmHash library (collection of hashing routines)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;web:1723d238fdf5897b662b370d57878ca8&#34;&gt;Web&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Catalyst::View::Template::Pure&#34;&gt;Catalyst::View::Template::Pure&lt;/a&gt; is a Catalyst View Adaptor for Template::Pure, the new HTML templating system&lt;/li&gt;
&lt;li&gt;Conveniently generate Facebook Instant Article markup with &lt;a href=&#34;https://metacpan.org/pod/Facebook::InstantArticle&#34;&gt;Facebook::InstantArticle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Mojolicious::Plugin::Multiplex&#34;&gt;Mojolicious::Plugin::Multiplex&lt;/a&gt; A websocket multiplexing layer for Mojolicious applications&lt;/li&gt;
&lt;li&gt;Dynamically modify the Plack environment request variable using &lt;a href=&#34;https://metacpan.org/pod/Plack::Middleware::ReviseEnv&#34;&gt;Plack::Middleware::ReviseEnv&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The History of the Schwartzian Transform</title>
      <link>http://perltricks.com/article/the-history-of-the-schwartzian-transform/</link>
      <pubDate>Fri, 02 Sep 2016 11:18:55 +0000</pubDate>
      
      <guid>http://perltricks.com/article/the-history-of-the-schwartzian-transform/</guid>
      <description>

&lt;p&gt;The history of the Schwartzian Transform is fascinating, full of intrigue, competing philosophies, and cross-language reluctant cooperation. The Schwartzian Transform is the name applied to a particular implementation of a cached-key sorting algorithm.&lt;/p&gt;

&lt;p&gt;The first public appearance is probably Randal Schwartz&amp;rsquo;s Usenet &lt;a href=&#34;https://groups.google.com/d/msg/comp.unix.shell/MdqXDOuzDG0/gcmc1IG9GckJ&#34;&gt;post&lt;/a&gt; on December 16, 1994 in response to Ken Brown&amp;rsquo;s request for help:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&amp;rsquo;m having trouble sorting on the *last* word of the last field in a record&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ken Brown&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Randal included the following code in his reply:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;#!/usr/bin/perl
require 5; # new features, new bugs!
print
  map { $_-&amp;gt;[0] }
  sort { $a-&amp;gt;[1] cmp $b-&amp;gt;[1] }
  map { [$_, /(\S+)$/] }
  &amp;lt;&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Randal didn&amp;rsquo;t name it. He wrote the code and essentially dropped the mic. He says that he was on a break from teaching a Perl class, so his response was brief and unexplicated - typical for an experienced Usenet denizen (he said that he was there when you could read all of Usenet in a half hour). I don&amp;rsquo;t think he expected it to be as troublesome as it turned out to be.&lt;/p&gt;

&lt;p&gt;His code isn&amp;rsquo;t that complex. It&amp;rsquo;s a big statement, but when I teach it in Perl classes, I tell people to read it from the end toward the beginning (a handy technique for any list pipeline):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The first step computes the key to sort on. It combines that with the original value in a tuple.&lt;/li&gt;
&lt;li&gt;The middle step sorts of the computed element in the tuple.&lt;/li&gt;
&lt;li&gt;The last step extracts the original value from the tuple.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You probably can&amp;rsquo;t imagine how shocking this could be back then. Perl 5 was officially released in October 1994, but the first development versions had been around since the middle of 1993. Randal was surely playing with Perl 5 as soon as it came out. This means that most Perl programmers had not yet seen new features like the &lt;a href=&#34;http://perldoc.perl.org/functions/map.html&#34;&gt;map&lt;/a&gt; function or references. They certainly weren&amp;rsquo;t comfortable with those ideas.&lt;/p&gt;

&lt;p&gt;Randal, however, knew the &lt;em&gt;decorate-sort-undecorate&lt;/em&gt; technique from LISP, especially since he&amp;rsquo;s solidly in the emacs camp in the editor wars. Renzo on &lt;a href=&#34;http://codereview.stackexchange.com/a/138436/13050&#34;&gt;Code Review&lt;/a&gt; fixed up my attempt at a LISP version:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;(defun schwartzian-transform (list costly-function predicate)
&amp;quot;sort a list of objects over the value of a function applied to them,
by applying the Schwartzian Transform (https://en.wikipedia.org/wiki/Schwartzian_transform)
the parameters are the list, the function, and the predicate for the sort.&amp;quot;
  (mapcar #&#39;cdr
      (stable-sort (mapcar (lambda (x)
                 (cons (funcall costly-function x) x))
                 list)
             predicate
             :key #&#39;car)))

(require :sb-posix)
(schwartzian-transform
 (directory &amp;quot;/etc/*&amp;quot;)
 (lambda (x) (sb-posix:stat-mtime (sb-posix:stat x)))
 #&#39;&amp;lt;=)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even with a little LISP knowledge you can tease out the same algorithm. You see the &lt;code&gt;mapcar&lt;/code&gt;, &lt;code&gt;stable-sort&lt;/code&gt;, and &lt;code&gt;mapcar&lt;/code&gt;. (I used &lt;a href=&#34;http://www.sbcl.org&#34;&gt;SBCL&lt;/a&gt; for this).&lt;/p&gt;

&lt;p&gt;In 1995 Tom Christiansen wrote &lt;a href=&#34;http://www.perl.com/doc/FMTEYEWTK/sort.html&#34;&gt;Far More Than Everything You&amp;rsquo;ve Ever Wanted to Know About Sorting&lt;/a&gt; and extensively covered Randal&amp;rsquo;s code even though he hadn&amp;rsquo;t labeled yet. He didn&amp;rsquo;t like it that much, but, to be fair, he says at the end:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&amp;rsquo;m not ragging on Randal, merely teasing a bit. He&amp;rsquo;s just trying to be clever, and that&amp;rsquo;s what he does. I&amp;rsquo;m just submitting a sample chapter for his perusal for inclusion the mythical Alpaca Book :-)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Tom Christiansen&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tom refers to &lt;em&gt;Learning Perl Objects, References, Objects, and Modules&lt;/em&gt;, which wouldn&amp;rsquo;t show up until 2003 (it&amp;rsquo;s now called &lt;a href=&#34;http://www.intermediateperl.com&#34;&gt;Intermediate Perl&lt;/a&gt;). Curiously, in that same year &lt;a href=&#34;https://books.google.com/books?id=GxKWdn7u4w8C&amp;amp;pg=PA113&amp;amp;dq=schwartzian+transform&amp;amp;hl=en&amp;amp;sa=X&amp;amp;ved=0ahUKEwir89e-krvNAhXMdz4KHW4uAqQQ6AEILjAC#v=onepage&amp;amp;q=schwartzian%20transform&amp;amp;f=false&#34;&gt;Text Processing in Python&lt;/a&gt; (Google Books) mentioned it.&lt;/p&gt;

&lt;p&gt;A month after his Usenet posting, Randal wrote about his decorate-sort-undecorate idiom in his &lt;a href=&#34;http://www.stonehenge.com/merlyn/UnixReview/col06.html&#34;&gt;Unix Review column&lt;/a&gt; for January 1996, but he hadn&amp;rsquo;t labeled the technique by then either.&lt;/p&gt;

&lt;h3 id=&#34;getting-the-name:cfab7c104a06866196fb7592f2146c3d&#34;&gt;Getting the name&lt;/h3&gt;

&lt;p&gt;In August 1995, &lt;a href=&#34;https://groups.google.com/forum/?hl=en#!topic/comp.lang.perl.misc/fLo0RNV8oW8&#34;&gt;Bennett Todd answers a sorting question&lt;/a&gt; with a &amp;ldquo;Schwartz transformation&amp;rdquo;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Or for possibly more efficiency, ensure that the calls only happen once per
record, rather than approximately NlogN times, with the Schwartz
transformation:-)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Bennett Todd&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;@keys = map { $_-&amp;gt;[0] }
    sort { $a-&amp;gt;[1] &amp;lt;=&amp;gt; $b-&amp;gt;[1] or $a cmp $b }
    map { [ $_, datexform($foo{$_}) ] } keys %foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the first instance I could find where Randal&amp;rsquo;s last name was attached to the technique. People have seen and understood the technique and it has the start of a name, but it&amp;rsquo;s not quite an idiom yet. It also hasn&amp;rsquo;t settled on a name.&lt;/p&gt;

&lt;p&gt;Tom Christiansen&amp;rsquo;s April 1996 post in &lt;em&gt;comp.lang.perl.misc&lt;/em&gt; for &lt;a href=&#34;https://groups.google.com/d/msg/comp.lang.perl.misc/pw-Hl4byLnc/yzejRnku3RoJ&#34;&gt;Read directory in timestamp order?&lt;/a&gt; showed some benchmarks for sorting methods. He labeled one the &amp;ldquo;Schwartzian Transform&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;In July, Colin Howarth started the thread &lt;a href=&#34;https://groups.google.com/d/msg/comp.lang.perl.misc/6NEeX4XJx54/nmpMmReMIbcJ&#34;&gt;&amp;ldquo;Schwartzian transform of %$self &amp;hellip; help?&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In October, Tom posted &lt;a href=&#34;https://groups.google.com/d/msg/comp.lang.perl.misc/VIKNMCeNFAM/18UApg1hWy8J&#34;&gt;an expanded draft of perllol&lt;/a&gt; as part of his &lt;a href=&#34;http://www.perl.com/doc/FMTEYEWTK/pdsc/&#34;&gt;Perl Data Structures Cookbook&lt;/a&gt;, which turned into &lt;a href=&#34;http://perldoc.perl.org/perldsc.html&#34;&gt;perldsc&lt;/a&gt; and &lt;a href=&#34;http://perldoc.perl.org/perllol.html&#34;&gt;perllol&lt;/a&gt;. He uses the full term &amp;ldquo;Schwartzian Transform&amp;rdquo;. The term was catching on.&lt;/p&gt;

&lt;h3 id=&#34;gaining-notoriety:cfab7c104a06866196fb7592f2146c3d&#34;&gt;Gaining notoriety&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://groups.google.com/d/msg/comp.lang.perl.misc/fPx42DB2jd8/cC_6osV70mMJ&#34;&gt;I&amp;rsquo;m still pissed at Randal for having posted it&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Tom Christiansen&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tom wrote that in December and he didn&amp;rsquo;t mince words. It might look catty now, but at the time, Tom was on a mission to make people fall in love with Perl. He evangelized the language and didn&amp;rsquo;t want to scare people off with weird looking code. He was everywhere that people were talking about Perl, and that was good for us. That meant he was effectively supporting code he didn&amp;rsquo;t write, he didn&amp;rsquo;t like, and people didn&amp;rsquo;t understand. In his role of Perl&amp;rsquo;s apostle, he was besieged with people asking about something he wouldn&amp;rsquo;t have written himself.&lt;/p&gt;

&lt;p&gt;Later, in that same thread, he&amp;rsquo;d give it another name, the &lt;a href=&#34;https://groups.google.com/d/msg/comp.lang.perl.misc/fPx42DB2jd8/cC_6osV70mMJ&#34;&gt;Black Transform&lt;/a&gt;. He played on the translation of Randal&amp;rsquo;s &lt;a href=&#34;https://en.wikipedia.org/wiki/Schwartz_(surname&#34;&gt;Germanic surname&lt;/a&gt;) that reflected his own opinion. That name didn&amp;rsquo;t stick.&lt;/p&gt;

&lt;p&gt;As with most long Usenet threads, it&amp;rsquo;s not entirely clear what people specifically didn&amp;rsquo;t like about the code, or even that there&amp;rsquo;s a consensus complaint. Some complaints spiral around Randal&amp;rsquo;s lack of comments. Some people want Perl to be accessible at first glance to someone who doesn&amp;rsquo;t know the language. Others who were comfortable with advanced programming skills weren&amp;rsquo;t bothered at all. That&amp;rsquo;s a tension even today.&lt;/p&gt;

&lt;p&gt;Remember, references and method notation were new syntax. People skilled with Perl 4 were still learning Perl 5. Perl hadn&amp;rsquo;t developed idioms for list processing (LISP, natch), so people apparently weren&amp;rsquo;t that comfortable with stacked list operations. Some people merely hated functional programming and LISP.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s also a segment of people who would rather have programming languages that are easy to learn over more powerful but more opaque.&lt;/p&gt;

&lt;p&gt;Around that time, Joseph Hall wrote &lt;a href=&#34;http://web.archive.org/web/19961228210914/http://www.5sigma.com/perl/schwtr.html&#34;&gt;More about the Schwartzian Transform (Internet Archive)&lt;/a&gt;. It&amp;rsquo;s tough to tell exactly when he wrote this, but the earliest copy in the Internet archive notes it was last modified in January 1997. Joseph used his PeGS (Perl Graphical Structures) to show them in action. This might be the first mention outside of Usenet. It&amp;rsquo;s also the basis for the item that appears in his 1998 book &lt;a href=&#34;http://www.effectiveperlprogramming.com&#34;&gt;Effective Perl Programming&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also, around that time, Joseph was working with Randal at Stonehenge Consulting Services to develop the Perl courses. I&amp;rsquo;m fuzzy on that timeline, but his coursework turned into the book &lt;em&gt;Learning Perl Objects, References, and Modules&lt;/em&gt; (later renamed &lt;a href=&#34;https://www.intermediateperl.com&#34;&gt;Intermediate Perl&lt;/a&gt;). He&amp;rsquo;s the one who came up with the Gilligan&amp;rsquo;s Island as examples, but his handiwork with PeGS and the Schwartzian Transform show up in that book and in the class.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.effectiveperlprogramming.com&#34;&gt;Effective Perl Programming&lt;/a&gt; might be the first book to mention the transform, using what he&amp;rsquo;d already written. Even though I worked on the second edition of that book, I think &lt;a href=&#34;https://www.amazon.com/gp/product/0201419750/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;tag=hashbang09-20&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;linkCode=as2&amp;amp;creativeASIN=0201419750&amp;amp;linkId=b8a4558fd65ec4c4bb17add6e194e5e4&#34;&gt;Joseph&amp;rsquo;s original is still worth the $4 on Amazon.com&lt;/a&gt;. It&amp;rsquo;s some of the best Perl writing in the history of Perl.&lt;/p&gt;

&lt;p&gt;In 1998 the transform also showed up in the first edition of &lt;a href=&#34;https://books.google.com/books?id=7q5QAAAAMAAJ&amp;amp;q=schwartzian+transform+%22programming+perl%22&amp;amp;dq=schwartzian+transform+%22programming+perl%22&amp;amp;hl=en&amp;amp;sa=X&amp;amp;ved=0ahUKEwjplePak7vNAhWSZj4KHYK9AtUQ6AEINDAD&#34;&gt;The Perl Cookbook&lt;/a&gt;, where Tom called it the Schwartzian Transform. I don&amp;rsquo;t know who first typed it into a manuscript, so perhaps it&amp;rsquo;s a tie. Tom and Joseph might have to figure that out between them.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://books.google.com/books?id=4ju67sMPwEkC&amp;amp;pg=PA111&amp;amp;dq=schwartzian+transform&amp;amp;hl=en&amp;amp;sa=X&amp;amp;ved=0ahUKEwir89e-krvNAhXMdz4KHW4uAqQQ6AEIOjAE#v=onepage&amp;amp;q=schwartzian%20transform&amp;amp;f=false&#34;&gt;Mastering Perl Algorithms (Google Books)&lt;/a&gt; covered the transform in 1999 and &lt;a href=&#34;https://books.google.com/books?id=gGNQ-O1WWQAC&amp;amp;pg=PA310&amp;amp;dq=schwartzian+transform&amp;amp;hl=en&amp;amp;sa=X&amp;amp;ved=0ahUKEwjo79KEk7vNAhWBMj4KHcBFDEY4ChDoAQhNMAg#v=onepage&amp;amp;q=schwartzian%20transform&amp;amp;f=false&#34;&gt;CGI Programming in Perl (Google Books)&lt;/a&gt; mentioned it in 2000. After that, the term &amp;ldquo;Schwartzian Transform&amp;rdquo; turns up quite a bit, even in some Ruby, Python, the Jython books.&lt;/p&gt;

&lt;p&gt;Some other interesting quotes from that long thread, which seem quaint twenty years later. My favorite was prophetic:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://groups.google.com/d/msg/comp.lang.perl.misc/fPx42DB2jd8/CTRmyWyJW6MJ&#34;&gt;I wonder if this chunk of code will haunt us forever.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Eric Arnold&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Indeed it has haunted us since then, but that&amp;rsquo;s not the end of the story.&lt;/p&gt;

&lt;h3 id=&#34;variations:cfab7c104a06866196fb7592f2146c3d&#34;&gt;Variations&lt;/h3&gt;

&lt;p&gt;Randal&amp;rsquo;s use of the anonymous array is interesting, but it&amp;rsquo;s not the only way to decorate the original value. You could compute the values and store them in a hash. Joseph Hall came up with something called the Orcish Maneuver - a clever pun on &lt;a href=&#34;http://lotr.wikia.com/wiki/Orcs&#34;&gt;Orc&lt;/a&gt; (perhaps) and &amp;ldquo;OR Cache&amp;rdquo;. This doesn&amp;rsquo;t use the &lt;a href=&#34;http://perldoc.perl.org/functions/map.html&#34;&gt;map&lt;/a&gt; function  or references:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @sorted = sort {
  ( $times{$a} ||= -M $a ) &amp;lt;=&amp;gt;
  ( $times{$b} ||= -M $b )
} @old_array;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Joseph uses a hash to store the potentially expensive sort value. If that key does not yet exist, he calculates and stores it for next time. This idiom relies on the feature that a Perl assignment returns the value assigned.&lt;/p&gt;

&lt;p&gt;Thanks to the &lt;a href=&#34;http://act.yapc.eu/alpineperl2016/&#34;&gt;Alpine Perl Workshop 2016&lt;/a&gt; in Innsbruck for sponsoring the accompanying talk on this history. You can find &lt;a href=&#34;http://bit.ly/2bHNNx4&#34;&gt;the slides for that talk on Slideshare&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For what it&amp;rsquo;s worth, you&amp;rsquo;ll find plenty more Lord of the Rings references in the perl source.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Save space with bit arrays</title>
      <link>http://perltricks.com/article/save-space-with-bit-arrays/</link>
      <pubDate>Tue, 23 Aug 2016 08:58:54 +0000</pubDate>
      
      <guid>http://perltricks.com/article/save-space-with-bit-arrays/</guid>
      <description>

&lt;p&gt;&amp;ldquo;Big data&amp;rdquo; is an overused term, but when you&amp;rsquo;re actually working with big data, every bit can count. Shaving several bits from data structure used billions of times can save a lot of space. A few months ago I was working on a job distribution system; it would send millions of jobs out every day. We wanted to capture every decision made by the system, so that a user could later query the system to understand &lt;em&gt;why&lt;/em&gt; a job had or hadn&amp;rsquo;t been sent to a partner.&lt;/p&gt;

&lt;p&gt;The problem was that the system was making billions of decisions a day, so we needed a way to pack those decisions as efficiently as possible. A colleague of mine had the bright idea to use a &lt;a href=&#34;https://en.wikipedia.org/wiki/Bit_array&#34;&gt;bit array&lt;/a&gt;, and it worked very well - we were able to compress the data by a factor of 18 or more. If you&amp;rsquo;re not familiar with bit arrays, or a little rusty on the code, keep reading and I&amp;rsquo;ll show you how to use them with Perl.&lt;/p&gt;

&lt;h3 id=&#34;bit-array-basics:a332d1994b52ca26596563ea047b2f1d&#34;&gt;Bit array basics&lt;/h3&gt;

&lt;p&gt;Bit arrays are a way of storing multiple booleans in single number. Consider the number 0 as a byte/octet represented as bits:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of treating it like a number, using &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation&#34;&gt;bitwise operators&lt;/a&gt; we can treat each bit as a separate column. As this is an 8 bit number, we can store up to 8 booleans in it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0|0|0|0|0|0|0|0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To store a boolean in the first bit of the array, we can use bitwise or equals (&lt;code&gt;|=&lt;/code&gt;). Here&amp;rsquo;s how that looks in C pseudocode:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;short bit_array = 0;
bit_array |= 1 &amp;lt;&amp;lt; 6;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s take this one step at a time. First I initialize an 8 bit integer called &lt;code&gt;bit_array&lt;/code&gt;. Next, I create a binary number with the bit set that I wish to set in &lt;code&gt;bit_array&lt;/code&gt;. I do this with the left bitshift code &lt;code&gt;1 &amp;lt;&amp;lt; 6&lt;/code&gt;. This means, &amp;ldquo;shift the bits in the number on the left, 6 places to the left&amp;rdquo;, which does this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;00000001 &amp;lt;&amp;lt; 6;
01000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is called a bitmask. Next I use or equals to update &lt;code&gt;bit_array&lt;/code&gt; with the bitmask &lt;code&gt;01000000&lt;/code&gt;. Bitwise or (&lt;code&gt;|&lt;/code&gt;) works by setting any bit to 1 in its left operand that is set to 1 in its right operand. Adding a equals sign on the end simply assigns the resulting value to &lt;code&gt;bit_array&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we wanted to store a boolean in the fourth bit, we&amp;rsquo;d do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;bit_array |= 1 &amp;lt;&amp;lt; 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now the &lt;code&gt;bit_array&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;01001000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test if a particular bit is set, I can use bitwise and (&lt;code&gt;&amp;amp;&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;if (bit_array &amp;amp; (1 &amp;lt;&amp;lt; 6)) {
  /* the seventh column is true */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bitwise and returns a number with every bit set to 0 in its left operand which is 0 in its right operand. So the code &lt;code&gt;1 &amp;lt;&amp;lt; 6&lt;/code&gt; bitshifts a number that only has one particular bit set to 1 (&lt;code&gt;01000000&lt;/code&gt;). This is the bitmask. If the bit array has that bit set to 1, it will return non-zero (true), else it returns zero (false).&lt;/p&gt;

&lt;h3 id=&#34;bit-arrays-in-perl:a332d1994b52ca26596563ea047b2f1d&#34;&gt;Bit arrays in Perl&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m going to use a contrived example to show how bit arrays work in Perl. Imagine we&amp;rsquo;re working on an ordering system at a pizza restaurant. We need to store all the toppings required for the pizza. In Perl we store numbers in scalars, which are usually 32 or 64 bits long; that&amp;rsquo;s a lot of toppings we can pack into a single number!&lt;/p&gt;

&lt;p&gt;Here is the class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Pizza::Order;
use utf8;

my %toppings = (
  tomato        =&amp;gt; 1 &amp;lt;&amp;lt; 0,
  cheese        =&amp;gt; 1 &amp;lt;&amp;lt; 1,
  onion         =&amp;gt; 1 &amp;lt;&amp;lt; 2,
  sausage       =&amp;gt; 1 &amp;lt;&amp;lt; 3,
  pepperoni     =&amp;gt; 1 &amp;lt;&amp;lt; 4,
  ham           =&amp;gt; 1 &amp;lt;&amp;lt; 5,
  chicken       =&amp;gt; 1 &amp;lt;&amp;lt; 6,
  bbq_chicken   =&amp;gt; 1 &amp;lt;&amp;lt; 7,
  olives        =&amp;gt; 1 &amp;lt;&amp;lt; 8,
  vegetables    =&amp;gt; 1 &amp;lt;&amp;lt; 9,
  jalapeńo      =&amp;gt; 1 &amp;lt;&amp;lt; 10,
  ranch         =&amp;gt; 1 &amp;lt;&amp;lt; 11,
  eggplant      =&amp;gt; 1 &amp;lt;&amp;lt; 12,
  garlic        =&amp;gt; 1 &amp;lt;&amp;lt; 13,
);

sub new {
  my $class = shift;
  my $self = 0;
  return bless \$self, $class;
}

sub print_state {
  my $self = shift;
  printf &amp;quot;%014b\n&amp;quot;, $$self;
}

sub available_toppings {
  return keys %toppings;
}

sub add_topping {
  my ($self, $topping) = @_;
  # bitwise OR equals to set a bit field
  return $$self |= $toppings{ $topping };
}

sub remove_topping {
  my ($self, $topping) = @_;
  # bitwise NOT to invert a field and bitwise AND equals to unset it
  return $$self &amp;amp;= ~$toppings{ $topping };
}

sub get_toppings {
  my $self = shift;
  my @ordered_toppings = ();
  for my $topping (keys %toppings) {
    push @ordered_toppings, $topping
      # bitwise AND to test if this bit is set
      if $$self &amp;amp; $toppings{ $topping };
  }
  return @ordered_toppings;
}
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I create a class called &lt;code&gt;Pizza::Order&lt;/code&gt;. The &lt;code&gt;%toppings&lt;/code&gt; hash stores names of pizza toppings and their associated bitmask. I could only think of 14 toppings, leaving 18 spare slots for the future (if we want to stick to 32 bit integers). The &lt;code&gt;new&lt;/code&gt; subroutine is a constructor which creates a blessed scalar as the &lt;code&gt;Pizza::Order&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;print_state&lt;/code&gt; method uses &lt;a href=&#34;http://perldoc.perl.org/functions/printf.html&#34;&gt;printf&lt;/a&gt; to print the Pizza::Order object state as a binary number. This is a really useful feature of &lt;code&gt;printf&lt;/code&gt; which many other languages don&amp;rsquo;t have (C &amp;amp; Python for example). Both &lt;code&gt;add_topping&lt;/code&gt; and &lt;code&gt;get_toppings&lt;/code&gt; use the techniques described earlier to set and check for set bits.&lt;/p&gt;

&lt;p&gt;More interesting perhaps, is the &lt;code&gt;remove_topping&lt;/code&gt; method. This uses bitwise not (&lt;code&gt;~&lt;/code&gt;) to invert a bitmask and then bitwise and (&lt;code&gt;&amp;amp;&lt;/code&gt;) equals to unset it. Pretty nifty, huh? Here&amp;rsquo;s a quick script to test it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;#!/usr/bin/perl
use Pizza::Order;

my $order = Pizza::Order-&amp;gt;new();
$order-&amp;gt;add_topping(&#39;cheese&#39;);
$order-&amp;gt;add_topping(&#39;eggplant&#39;);
$order-&amp;gt;remove_topping(&#39;cheese&#39;);
$order-&amp;gt;add_topping(&#39;tomato&#39;);
$order-&amp;gt;print_state();
print &amp;quot;$_\n&amp;quot; for $order-&amp;gt;get_toppings();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This prints:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;01000000000001
eggplant
tomato
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first line is the current state of the &lt;code&gt;$order&lt;/code&gt; object. It shows the first, and second-to-last bits set, which correspond to the tomato and eggplant bitmasks. It then prints out those toppings. Yay, it works!&lt;/p&gt;

&lt;h3 id=&#34;bit-array-limitations:a332d1994b52ca26596563ea047b2f1d&#34;&gt;Bit array limitations&lt;/h3&gt;

&lt;p&gt;One thing to watch out for when storing bit arrays on disk is code change. Imagine if I had several years&amp;rsquo; worth of pizza orders saved in a database. Then one day, we stopped offering bbq chicken. It would be tempting to update the toppings hash like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my %toppings = (
  tomato        =&amp;gt; 1 &amp;lt;&amp;lt; 0,
  cheese        =&amp;gt; 1 &amp;lt;&amp;lt; 1,
  onion         =&amp;gt; 1 &amp;lt;&amp;lt; 2,
  sausage       =&amp;gt; 1 &amp;lt;&amp;lt; 3,
  pepperoni     =&amp;gt; 1 &amp;lt;&amp;lt; 4,
  ham           =&amp;gt; 1 &amp;lt;&amp;lt; 5,
  chicken       =&amp;gt; 1 &amp;lt;&amp;lt; 6,
  olives        =&amp;gt; 1 &amp;lt;&amp;lt; 7, # deleted bbq_chicken
  vegetables    =&amp;gt; 1 &amp;lt;&amp;lt; 8,
  jalapeńo      =&amp;gt; 1 &amp;lt;&amp;lt; 9,
  ranch         =&amp;gt; 1 &amp;lt;&amp;lt; 10,
  eggplant      =&amp;gt; 1 &amp;lt;&amp;lt; 11,
  garlic        =&amp;gt; 1 &amp;lt;&amp;lt; 12,
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I deleted the &lt;code&gt;bbq_chicken&lt;/code&gt; entry and bumped up the remaining toppings bitmasks. The problem is compatibility: in all the historical pizza orders, &lt;code&gt;olives&lt;/code&gt; (for example) had a bitmask of &lt;code&gt;00000010000000&lt;/code&gt; but in the new code, its bitmask is one lower. So if I tried to load a historical order with this class, the toppings data would be wrong. One way to handle this is remove, but not reuse, the bitmask for the deleted entry.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my %toppings = (
  tomato        =&amp;gt; 1 &amp;lt;&amp;lt; 0,
  cheese        =&amp;gt; 1 &amp;lt;&amp;lt; 1,
  onion         =&amp;gt; 1 &amp;lt;&amp;lt; 2,
  sausage       =&amp;gt; 1 &amp;lt;&amp;lt; 3,
  pepperoni     =&amp;gt; 1 &amp;lt;&amp;lt; 4,
  ham           =&amp;gt; 1 &amp;lt;&amp;lt; 5,
  chicken       =&amp;gt; 1 &amp;lt;&amp;lt; 6,
  # reserved
  olives        =&amp;gt; 1 &amp;lt;&amp;lt; 8,
  vegetables    =&amp;gt; 1 &amp;lt;&amp;lt; 9,
  jalapeńo      =&amp;gt; 1 &amp;lt;&amp;lt; 10,
  ranch         =&amp;gt; 1 &amp;lt;&amp;lt; 11,
  eggplant      =&amp;gt; 1 &amp;lt;&amp;lt; 12,
  garlic        =&amp;gt; 1 &amp;lt;&amp;lt; 13,
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This limitation makes bitmasks less useful for long-term storage of data, unless the existing bitmasks are unlikely to change. Note that it&amp;rsquo;s fine to add additional toppings and bitmasks, it&amp;rsquo;s just re-using existing bitmasks that causes issues.&lt;/p&gt;

&lt;p&gt;Another thing to consider is upper limits (update - see &lt;a href=&#34;http://perltricks.com/article/using-bitmasks-with-large-integers/&#34;&gt;using bit arrays with large integers&lt;/a&gt;). If you want your Perl code to be compatible with 32 bit and 64 bit Perls, you should probably stick to a maximum of 32 bitmasks (using a module like &lt;a href=&#34;https://metacpan.org/pod/bigint&#34;&gt;bigint&lt;/a&gt; may &lt;em&gt;not&lt;/em&gt; work because of addressable memory limitations). You can see the settings your Perl has been compiled with by typing &lt;code&gt;perl -V | grep longsize&lt;/code&gt; at the command line. The longsize value is the number of bytes your Perl can store in an integer natively.&lt;/p&gt;

&lt;p&gt;Finally, in order to get the data back out of a bit array it needs to be tested with all the available bitmasks. Consider the &lt;code&gt;get_toppings&lt;/code&gt; method in &lt;code&gt;Pizza::Order&lt;/code&gt;. To find out what toppings are set, the code has to check every topping&amp;rsquo;s bitmask. This is pretty inefficient. So bitmasks are good for compact data storage, but not fast access.&lt;/p&gt;

&lt;h3 id=&#34;references:a332d1994b52ca26596563ea047b2f1d&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Wikipedia has useful entries on &lt;a href=&#34;https://en.wikipedia.org/wiki/Bit_array&#34;&gt;bit arrays&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Bitwise_operation&#34;&gt;bitwise operators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Perl&amp;rsquo;s official &lt;a href=&#34;http://perldoc.perl.org/perlop.html&#34;&gt;operator documentation&lt;/a&gt; covers the bitwise operators. You can read it in the terminal with the command &lt;code&gt;perldoc perlop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use Perl&amp;rsquo;s builtin functions &lt;a href=&#34;http://perldoc.perl.org/functions/sprintf.html&#34;&gt;sprintf&lt;/a&gt; (&lt;code&gt;perldoc -f sprintf&lt;/code&gt;) and &lt;a href=&#34;http://perldoc.perl.org/functions/printf.html&#34;&gt;printf&lt;/a&gt; (&lt;code&gt;perldoc -f printf&lt;/code&gt;) to inspect binary values&lt;/li&gt;
&lt;li&gt;Stringifying / printing numbers as binary isn&amp;rsquo;t the only nice binary feature Perl has over other languages. Another is the ability to write binary numbers inline, just like octal and hexadecimal numbers, for example: &lt;code&gt;0b00001000&lt;/code&gt;. This is great for comparing binary numbers&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/bigint&#34;&gt;bigint&lt;/a&gt; is one of several modules on CPAN for working with large integers, see &lt;a href=&#34;http://perltricks.com/article/using-bitmasks-with-large-integers/&#34;&gt;using bit arrays with large integers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Identify slow code with Devel::Timer</title>
      <link>http://perltricks.com/article/identify-slow-code-with-devel--timer/</link>
      <pubDate>Wed, 17 Aug 2016 08:38:50 +0000</pubDate>
      
      <guid>http://perltricks.com/article/identify-slow-code-with-devel--timer/</guid>
      <description>

&lt;p&gt;Program speed is an important factor in programming. No one wants their program to execute more slowly. As a general purpose programming language, Perl is usually fast enough for most things, and when it isn&amp;rsquo;t, we have some great tools to help us make it faster. We can use the &lt;a href=&#34;https://metacpan.org/pod/Benchmark&#34;&gt;Benchmark&lt;/a&gt; module to compare code and &lt;a href=&#34;https://metacpan.org/pod/Devel::NYTProf&#34;&gt;Devel::NYTProf&lt;/a&gt; to produce detailed analyses of our programs.&lt;/p&gt;

&lt;p&gt;This article is about &lt;a href=&#34;https://metacpan.org/pod/Devel::Timer&#34;&gt;Devel::Timer&lt;/a&gt;, another module I like to use when I want to optimize an existing subroutine, and I&amp;rsquo;m not sure how long each statement within the subroutine takes to execute. It&amp;rsquo;s very easy to setup, so if you haven&amp;rsquo;t used it before, once you&amp;rsquo;ve read this article you&amp;rsquo;ll have another tool in your toolbox for optimizing code.&lt;/p&gt;

&lt;h3 id=&#34;use-devel-timer-to-get-a-timing-report:c8f1bf769d62e73aff7cbb1221d2bf48&#34;&gt;Use Devel::Timer to get a timing report&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s say I have a subroutine which is far too slow, but I&amp;rsquo;m not sure what&amp;rsquo;s slowing it down. The (fictional) subroutine looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub foo {
  my $args = shift;

  die &#39;foo() requires an hashref of args&#39;
    unless $args &amp;amp;&amp;amp; ref $args eq &#39;HASH&#39;;

  my %parsed_args = validate_args($args);

  my $user        = find_user($parsed_args{username});

  my $location    = get_location($parsed_args{req_address});

  my $bar         = register_request($user, $location);

  return $bar;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I can use Devel::Timer to time each statement in the subroutine, and tell me how long each one took:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Devel::Timer;

sub foo {
  my $args = shift;
  my $timer = Devel::Timer-&amp;gt;new();

  die &#39;foo() requires an hashref of args&#39;
    unless $args &amp;amp;&amp;amp; ref $args eq &#39;HASH&#39;;
  $timer-&amp;gt;mark(&#39;check $args is hashref&#39;);

  my %parsed_args = validate_args($args);
  $timer-&amp;gt;mark(&#39;validate_args()&#39;);

  my $user        = find_user($parsed_args{username});
  $timer-&amp;gt;mark(&#39;find_user()&#39;);

  my $location    = get_location($parsed_args{req_address});
  $timer-&amp;gt;mark(&#39;get_location()&#39;);

  my $bar         = register_request($user, $location);
  $timer-&amp;gt;mark(&#39;register_request()&#39;);

  $timer-&amp;gt;report();
  return $bar;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve updated the code to import Devel::Timer and construct a new &lt;code&gt;$timer&lt;/code&gt; object. After every statement I want to time, I call the &lt;code&gt;mark&lt;/code&gt; method which adds an entry to the timer, like recording split times on a stopwatch. Finally I call &lt;code&gt;report&lt;/code&gt; which prints out a table listing the time spent between every &lt;code&gt;mark&lt;/code&gt; call.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Devel::Timer Report -- Total time: 0.0515 secs
Interval  Time    Percent
----------------------------------------------
02 -&amp;gt; 03  0.0328  63.68%  validate_args() -&amp;gt; find_user()
04 -&amp;gt; 05  0.0095  18.44%  get_location() -&amp;gt; register_request()
03 -&amp;gt; 04  0.0081  15.72%  find_user() -&amp;gt; get_location()
06 -&amp;gt; 07  0.0010   0.19%  register_request() -&amp;gt; END
01 -&amp;gt; 02  0.0001   0.00%  check $args is hashref -&amp;gt; validate_args()
00 -&amp;gt; 01  0.0000   0.00%  INIT -&amp;gt; check $args is hashref
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default the table is printed in descending order of duration. The output shows that the subroutine took 515ms to execute, and the time between the &lt;code&gt;validate_args()&lt;/code&gt; mark and the &lt;code&gt;find_user()&lt;/code&gt; mark took a whopping 63.68% of the runtime. So if I was going to refactor this subroutine, I would start with the &lt;code&gt;find_user()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;In my experience, this is a typical distribution of timings. It&amp;rsquo;s rare to find every statement in a subroutine takes the same amount of time. Usually there just are one or two culprits, and if you can refactor those, the subroutine runtime can improve by an order of magnitude or more.&lt;/p&gt;

&lt;h3 id=&#34;a-common-pitfall:c8f1bf769d62e73aff7cbb1221d2bf48&#34;&gt;A common pitfall&lt;/h3&gt;

&lt;p&gt;One thing to watch out for with Devel::Timer is lazy evaluation. This is when code is written to only execute when it&amp;rsquo;s required. Sometimes the first call to a subroutine may be slow, as objects are created, caches initialized or whatever. But subsequent calls are much faster. An easy way to check for this is to call the subroutine multiple times in the same process, and check the Devel::Timer reports to confirm the timings.&lt;/p&gt;

&lt;h3 id=&#34;references:c8f1bf769d62e73aff7cbb1221d2bf48&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;This article is about &lt;a href=&#34;https://metacpan.org/pod/Devel::Timer&#34;&gt;Devel::Timer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Benchmark::Stopwatch&#34;&gt;Benchmark::Stopwatch&lt;/a&gt; is another timer module, similar to Devel::Timer&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Devel::NYTProf&#34;&gt;Devel::NYTProf&lt;/a&gt; is a code profiler for Perl. Tim Bunce regularly gives &lt;a href=&#34;https://www.youtube.com/watch?v=SDWoCQf53Ck&#34;&gt;talks&lt;/a&gt; about it&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://metacpan.org/pod/Benchmark&#34;&gt;Benchmark&lt;/a&gt; module comes with Perl&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>What&#39;s new on CPAN - July 2016</title>
      <link>http://perltricks.com/article/what-s-new-on-cpan---july-2016/</link>
      <pubDate>Tue, 09 Aug 2016 09:11:11 +0000</pubDate>
      
      <guid>http://perltricks.com/article/what-s-new-on-cpan---july-2016/</guid>
      <description>

&lt;p&gt;Welcome to &amp;ldquo;What&amp;rsquo;s new on CPAN&amp;rdquo;, a curated look at last month&amp;rsquo;s new CPAN uploads for your reading and programming pleasure. Enjoy!&lt;/p&gt;

&lt;h3 id=&#34;apis-apps:f3bb894e15cb1eeff469d8127fc0975c&#34;&gt;APIs &amp;amp; Apps&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Add copyright information to your images with &lt;a href=&#34;https://metacpan.org/pod/App::CopyrightImage&#34;&gt;App::CopyrightImage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Test the tone perception of your ears with &lt;a href=&#34;https://metacpan.org/pod/App::tonematch&#34;&gt;App::tonematch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/ExtUtils::PL2Bat&#34;&gt;ExtUtils::PL2Bat&lt;/a&gt; converts Perl scripts to batch files to run on Windows&lt;/li&gt;
&lt;li&gt;Get an interface to Mail Chimp&amp;rsquo;s API using &lt;a href=&#34;https://metacpan.org/pod/Mail::Chimp3&#34;&gt;Mail::Chimp3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OneAll is an all-in-one social media API, use it with &lt;a href=&#34;https://metacpan.org/pod/WWW::OneAll&#34;&gt;WWW::OneAll&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/PowerShell&#34;&gt;PowerShell&lt;/a&gt; wraps PowerShell commands&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Snapforce::API&#34;&gt;Snapforce::API&lt;/a&gt; provides a perly interface for the Snapforce CRM API&lt;/li&gt;
&lt;li&gt;Communicate with socket.io servers using &lt;a href=&#34;https://metacpan.org/pod/SocketIO::Emitter&#34;&gt;SocketIO::Emitter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;config-devops:f3bb894e15cb1eeff469d8127fc0975c&#34;&gt;Config &amp;amp; Devops&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Get a simple API for querying Gentoo&amp;rsquo;s installed-package database using &lt;a href=&#34;https://metacpan.org/pod/Gentoo::VDB&#34;&gt;Gentoo::VDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Perl::Critic::Policy::BuiltinFunctions::ProhibitReturnOr&#34;&gt;Perl::Critic::Policy::BuiltinFunctions::ProhibitReturnOr&lt;/a&gt; checks for use of &lt;code&gt;return ... or ...&lt;/code&gt; - an easy mistake to make&lt;/li&gt;
&lt;li&gt;RT-Extension-Tags Extension using &lt;a href=&#34;https://metacpan.org/pod/RT::Extension::Tags&#34;&gt;RT::Extension::Tags&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;data:f3bb894e15cb1eeff469d8127fc0975c&#34;&gt;Data&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Parse::SAMGov&#34;&gt;Parse::SAMGov&lt;/a&gt; parses SAM Entity Management Public Extract Layout from SAM.gov&lt;/li&gt;
&lt;li&gt;Access CSV, XML, HTML and log data with SQL using &lt;a href=&#34;https://metacpan.org/pod/DBD::AnyData2&#34;&gt;DBD::AnyData2&lt;/a&gt;, a new version of &lt;a href=&#34;https://metacpan.org/pod/DBD::AnyData&#34;&gt;DBIx::AnyData&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Use DBIx::Class in asynchronous environments with &lt;a href=&#34;https://metacpan.org/pod/DBIx::Connector::Pool&#34;&gt;DBIx::Connector::Pool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Data::IEEE754::Tools&#34;&gt;Data::IEEE754::Tools&lt;/a&gt; provides functions for inspecting and manipulating Perl&amp;rsquo;s floating point values&lt;/li&gt;
&lt;li&gt;Create custom ETL processes using &lt;a href=&#34;https://metacpan.org/pod/ETL::Pipeline&#34;&gt;ETL::Pipeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Geo::libpostal&#34;&gt;Geo::libpostal&lt;/a&gt; Perl bindings for the speedy libpostal geo coder (disclaimer: I am the module author)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/MARC::Spec&#34;&gt;MARC::Spec&lt;/a&gt; builds and parses the MARCspec record path language&lt;/li&gt;
&lt;li&gt;Daniel Șuteu uploaded two search modules:&lt;a href=&#34;https://metacpan.org/pod/Search::MultiMatch&#34;&gt;Search::MultiMatch&lt;/a&gt; uses 2 dimensional arrays as keys, and &lt;a href=&#34;https://metacpan.org/pod/Search::ByPrefix&#34;&gt;Search::ByPrefix&lt;/a&gt; searches for substring matches&lt;/li&gt;
&lt;li&gt;Normalize URIs with &lt;a href=&#34;https://metacpan.org/pod/URI::Normalize&#34;&gt;URI::Normalize&lt;/a&gt; - no more missing trailing slashes, yay!&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/YAML::LoadBundle&#34;&gt;YAML::LoadBundle&lt;/a&gt; loads a directory of YAML files into a single data structure, with different merge options. Nice!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;development-version-control:f3bb894e15cb1eeff469d8127fc0975c&#34;&gt;Development &amp;amp; Version Control&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Use map reduce with just a few lines of code using &lt;a href=&#34;https://metacpan.org/pod/MapReduce::Framework::Simple&#34;&gt;MapReduce::Framework::Simple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/ReadonlyX&#34;&gt;ReadonlyX&lt;/a&gt; aims to be a faster, better version of Readonly. I wonder how it compares to community favorite &lt;a href=&#34;https://metacpan.org/pod/Const::Fast&#34;&gt;Const::Fast&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Write your script in any encoding with &lt;a href=&#34;https://metacpan.org/pod/Filter::Encoding&#34;&gt;Filter::Encoding&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Alt::FFI::libffi&#34;&gt;Alt::FFI::libffi&lt;/a&gt; provides a Perl Foreign Function interface based on libffi&lt;/li&gt;
&lt;li&gt;Monkeypatch Moose exceptions with &lt;a href=&#34;https://metacpan.org/pod/MooseX::ErrorHandling&#34;&gt;MooseX::ErrorHandling&lt;/a&gt;. Docs say &amp;ldquo;This module is almost certainly a bad idea&amp;rdquo;. Ready for production then!&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Params::ValidationCompiler&#34;&gt;Params::ValidationCompiler&lt;/a&gt; let&amp;rsquo;s you create and re-use parameter validation routines&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;hardware:f3bb894e15cb1eeff469d8127fc0975c&#34;&gt;Hardware&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Device::Chip::AVR_HVSP&#34;&gt;Device::Chip::AVR_HVSP&lt;/a&gt; enables high-voltage serial programming for AVR chips&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;other:f3bb894e15cb1eeff469d8127fc0975c&#34;&gt;Other&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Geo::GoogleEarth::AutoTour&#34;&gt;Geo::GoogleEarth::AutoTour&lt;/a&gt; generates Google Earth tours using tracks and paths&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;web:f3bb894e15cb1eeff469d8127fc0975c&#34;&gt;Web&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Parse::WWWAuthenticate&#34;&gt;Parse::WWWAuthenticate&lt;/a&gt; parses the WWW-Authenticate HTTP header; not sure if this is better than using a general purpose parser like &lt;a href=&#34;https://metacpan.org/pod/HTTP::XSHeaders&#34;&gt;HTTP::XSHeaders&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/PEF::Front&#34;&gt;PEF::Front&lt;/a&gt; is a new web framework&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Plift&#34;&gt;Plift&lt;/a&gt; is a new templating module&lt;/li&gt;
&lt;li&gt;Implement a mock HTTP server for testing using &lt;a href=&#34;https://metacpan.org/pod/Test::HTTP::MockServer&#34;&gt;Test::HTTP::MockServer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Create a test Apache instance with &lt;a href=&#34;https://metacpan.org/pod/Test::Instance::Apache&#34;&gt;Test::Instance::Apache&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Building a UTF-8 encoder in Perl</title>
      <link>http://perltricks.com/article/building-a-utf-8-encoder-in-perl/</link>
      <pubDate>Tue, 02 Aug 2016 08:47:57 +0000</pubDate>
      
      <guid>http://perltricks.com/article/building-a-utf-8-encoder-in-perl/</guid>
      <description>

&lt;p&gt;This week I wrote a UTF-8 encoder/decoder. Perl already comes with UTF-8 encoding features built-in, so this wasn&amp;rsquo;t necessary, but sometimes it&amp;rsquo;s nice to understand how things work. The UTF-8 scheme is defined in &lt;a href=&#34;https://tools.ietf.org/html/rfc3629&#34;&gt;RFC 3629&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;what-does-a-utf-8-encoder-do:bacb6356dcc1a00cc990d0647178b7de&#34;&gt;What does a UTF-8 encoder do?&lt;/h3&gt;

&lt;p&gt;UTF-8 is a scheme for encoding &lt;a href=&#34;https://en.wikipedia.org/wiki/Unicode&#34;&gt;Unicode&lt;/a&gt; sequences of codepoints as bytes/octets. A codepoint is just a number, that identifies the Unicode entry (such as 0x24 which is a dollar sign).&lt;/p&gt;

&lt;p&gt;Unicode defines codepoints in the range 0x0000..0x10FFFF, so the encoder must take a codepoint and convert it to bytes according to the UTF-8 scheme, which looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Char. number range  |     UTF-8 bytes/octets sequence
   (hexadecimal)    |              (binary)
--------------------+------------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This has some interesting properties. First of all, codepoints in the range 0x00..0x7F (0-127) will have the same bytes as with ASCII encoding, which is convenient. Second it&amp;rsquo;s a &lt;em&gt;variable width&lt;/em&gt; encoding, which means that a single codepoint can be 1-4 bytes long.&lt;/p&gt;

&lt;p&gt;Decoding is simply the process in reverse: converting a sequence of bytes back into a codepoint.&lt;/p&gt;

&lt;h3 id=&#34;encoding-utf-8:bacb6356dcc1a00cc990d0647178b7de&#34;&gt;Encoding UTF-8&lt;/h3&gt;

&lt;p&gt;To encode UTF-8, I need to convert a codepoint (which is just a number), into a sequence of bytes. As there are four different byte sequences defined in the UTF-8 table, there are four scenarios to handle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub codepoint_to_bytes {
  my $codepoint = shift;

  if ($codepoint &amp;lt; 0x80) {
    return pack &#39;C&#39;, $codepoint;
  }
  elsif ($codepoint &amp;lt; 0x800) {
    return pack &#39;CC&#39;,
           $codepoint &amp;gt;&amp;gt;  6 | 0b11000000,
           $codepoint       &amp;amp; 0b00111111 | 0b10000000;
  }
  elsif ($codepoint &amp;lt; 0x10000) {
    return pack &#39;CCC&#39;,
           $codepoint &amp;gt;&amp;gt; 12 | 0b11100000,
           $codepoint &amp;gt;&amp;gt;  6 &amp;amp; 0b00111111 | 0b10000000,
           $codepoint       &amp;amp; 0b00111111 | 0b10000000;
  }
  else {
    return pack &#39;CCCC&#39;,
           $codepoint &amp;gt;&amp;gt; 18 | 0b11110000,
           $codepoint &amp;gt;&amp;gt; 12 &amp;amp; 0b00111111 | 0b10000000,
           $codepoint &amp;gt;&amp;gt;  6 &amp;amp; 0b00111111 | 0b10000000,
           $codepoint       &amp;amp; 0b00111111 | 0b10000000;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first is the easiest: if the codepoint is between 0x00 and 0x7F, no transformation is required, so I just &lt;a href=&#34;http://perldoc.perl.org/functions/pack.html&#34;&gt;pack&lt;/a&gt; the codepoint as-is. The byte value of a character is the same as the codepoint (e.g. &lt;code&gt;&#39;U&#39; == 56 == 0x38 == 00111000&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;For the second scenario I have to populate the bitmask &lt;code&gt;110xxxxx 10xxxxxx&lt;/code&gt; with the codepoint, which means I need to return two bytes. This is how I do it:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;For the first byte, bitshift the codepoint 6 places to the right (as the second byte will get those 6 bits).&lt;/li&gt;
&lt;li&gt;Use bitwise OR to set the two most significant bits to one (&lt;code&gt;xxxxxxxx | 11000000 == 11xxxxxx&lt;/code&gt;). I&amp;rsquo;m using Perl&amp;rsquo;s inline binary notation (&lt;code&gt;0b...&lt;/code&gt;) which makes it easy to compare the binary numbers with the bitmask.&lt;/li&gt;
&lt;li&gt;For the second byte use bitwise AND to set the two most significant bits to zero (&lt;code&gt;xxxxxxxx &amp;amp; 00111111 == 00xxxxxx&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Use bitwise OR to set the most significant bit to 1 (&lt;code&gt;xxxxxxxx | 10000000 == 1xxxxxxx&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Use &lt;a href=&#34;http://perldoc.perl.org/functions/pack.html&#34;&gt;pack&lt;/a&gt; to combine the bytes into a scalar and return it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The process for three byte and four byte encoding follows the same approach, with the rules updated according to the UTF-8 scheme.&lt;/p&gt;

&lt;p&gt;If I wanted to get UTF-8 encoded bytes for the &lt;a href=&#34;http://www.fileformat.info/info/unicode/char/1f4fa/fontsupport.htm&#34;&gt;Television&lt;/a&gt; codepoint (U+1F4FA) I could use the code like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $bytes = codepoint_to_bytes(0x1F4FA);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;decoding-utf-8:bacb6356dcc1a00cc990d0647178b7de&#34;&gt;Decoding UTF-8&lt;/h3&gt;

&lt;p&gt;To decode UTF-8 bytes, we need to reverse the encoding process to get back to the original Unicode codepoint number. The decoder must check how many bytes it received, extract the appropriate bits and add them together.&lt;/p&gt;

&lt;p&gt;Perl tries &amp;ldquo;to make the easy things easy, and the hard things possible&amp;rdquo; as the saying goes, but sometimes it makes easy things harder than they are in simpler languages like C. Binary data is one such area: Perl needs to be told to turn off its character features before you can safely work with the data.&lt;/p&gt;

&lt;p&gt;There are two ways to do that. The old, discouraged way is to use the &lt;a href=&#34;https://metacpan.org/pod/bytes&#34;&gt;bytes pragma&lt;/a&gt;. The newer way is to use the &lt;a href=&#34;https://metacpan.org/pod/Encode#SYNOPSIS&#34;&gt;Encode&lt;/a&gt; module to encode the scalar as bytes and remove its UTF-8 flag. After that, Perl&amp;rsquo;s functions will treat the scalar as a sequence of bytes instead of characters:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Encode &#39;encode&#39;;

sub bytes_to_codepoint {
  # treat the scalar as bytes/octets
  my $input    = encode(&#39;UTF-8&#39;, shift);

  # length returns number of bytes
  my $len      = length $input;
  my $template = &#39;C&#39; x $len;
  my @bytes    = unpack $template, $input;

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the subroutine &lt;code&gt;bytes_to_codepoint&lt;/code&gt; I use &lt;code&gt;encode()&lt;/code&gt; to populate &lt;code&gt;$input&lt;/code&gt; with the bytes passed to it. Next I use the &lt;code&gt;length&lt;/code&gt; function to return the number of bytes in &lt;code&gt;$input&lt;/code&gt; - this is different from its usual behavior which returns the number of characters; this is the effect of using &lt;code&gt;encode()&lt;/code&gt; to convert the scalar to bytes. Finally I use &lt;a href=&#34;http://perldoc.perl.org/functions/unpack.html&#34;&gt;unpack&lt;/a&gt; to extract the bytes from &lt;code&gt;$input&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now I know the number of bytes passed to &lt;code&gt;bytes_to_codepoint&lt;/code&gt;, it&amp;rsquo;s just a matter of reversing the binary operations from the encoding process:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;if ($len == 1) {
  return $bytes[0];
}
elsif ($len == 2) {
  return (($bytes[0] &amp;amp; 0b00011111) &amp;lt;&amp;lt;  6) +
          ($bytes[1] &amp;amp; 0b00111111);
}
elsif ($len == 3) {
  return (($bytes[0] &amp;amp; 0b00001111) &amp;lt;&amp;lt; 12) +
         (($bytes[1] &amp;amp; 0b00111111) &amp;lt;&amp;lt;  6) +
         ( $bytes[2] &amp;amp; 0b00111111);
}
else {
  return (($bytes[0] &amp;amp; 0b00000111) &amp;lt;&amp;lt; 18) +
         (($bytes[1] &amp;amp; 0b00111111) &amp;lt;&amp;lt; 12) +
         (($bytes[2] &amp;amp; 0b00111111) &amp;lt;&amp;lt;  6) +
          ($bytes[3] &amp;amp; 0b00111111);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is just one byte, I return it as-is because the codepoint number is the same as the byte value. As with encoding, it gets interesting with two bytes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Remove the bitmask from the first byte with bitwise AND. Remember bitwise AND returns any bits as zero which are zero in the right operand (&lt;code&gt;xxxxxxxx &amp;amp; 00011111 == 000xxxxx&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Bit shift the resulting number 6 places to the left to get the original value. So &lt;code&gt;00000010&lt;/code&gt; would become &lt;code&gt;10000000&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Remove the bitmask from the second byte with bitwise AND (&lt;code&gt;xxxxxxxx &amp;amp; 00111111 == 00xxxxxx&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Add the numbers together.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The same logic applies to three byte and four byte sequences, I just update the bitwise operations to match the UTF-8 scheme. The final code looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Encode &#39;encode&#39;;

sub bytes_to_codepoint {
  # treat the scalar as bytes/octets
  my $input    = encode(&#39;UTF-8&#39;, shift);

  # length returns number of bytes
  my $len      = length $input;
  my $template = &#39;C&#39; x $len;
  my @bytes    = unpack $template, $input;

  # reverse encoding
  if ($len == 1) {
    return $bytes[0];
  }
  elsif ($len == 2) {
    return (($bytes[0] &amp;amp; 0b00011111) &amp;lt;&amp;lt;  6) +
            ($bytes[1] &amp;amp; 0b00111111);
  }
  elsif ($len == 3) {
    return (($bytes[0] &amp;amp; 0b00001111) &amp;lt;&amp;lt; 12) +
           (($bytes[1] &amp;amp; 0b00111111) &amp;lt;&amp;lt;  6) +
           ( $bytes[2] &amp;amp; 0b00111111);
  }
  else {
    return (($bytes[0] &amp;amp; 0b00000111) &amp;lt;&amp;lt; 18) +
           (($bytes[1] &amp;amp; 0b00111111) &amp;lt;&amp;lt; 12) +
           (($bytes[2] &amp;amp; 0b00111111) &amp;lt;&amp;lt;  6) +
            ($bytes[3] &amp;amp; 0b00111111);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s say I wanted to get the codepoint for the &lt;a href=&#34;http://www.fileformat.info/info/unicode/char/1f5fc/index.htm&#34;&gt;Tokyo Tower&lt;/a&gt; I can call the code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use utf8;
my $codepoint = bytes_to_codepoint(&#39;🗼&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;notes:bacb6356dcc1a00cc990d0647178b7de&#34;&gt;Notes&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;This is a naive implementation - it doesn&amp;rsquo;t handle UTF-16 reserved characters (U+D800..U+DFFF), noncharacters and only encodes/decodes one codepoint at a time.&lt;/li&gt;
&lt;li&gt;Take a look at &lt;a href=&#34;https://metacpan.org/pod/distribution/Unicode-UTF8/lib/Unicode/UTF8.pod&#34;&gt;Unicode::UTF8&lt;/a&gt; if you need a fast UTF-8 encoder and don&amp;rsquo;t want to use Perl&amp;rsquo;s builtin tools.&lt;/li&gt;
&lt;li&gt;UTF-8 is by far the most popular Unicode encoding. It was created by Ken Thompson and Rob Pike in &lt;a href=&#34;http://doc.cat-v.org/bell_labs/utf-8_history&#34;&gt;just a few days&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Building your own UTF-8 encoder? Check out Markus Kuhn&amp;rsquo;s &lt;a href=&#34;https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt&#34;&gt;decoder test file&lt;/a&gt; which contains several difficult or edge case tests for UTF-8 decoding. Markus also wrote a comprehensive &lt;a href=&#34;https://www.cl.cam.ac.uk/~mgk25/unicode.html&#34;&gt;UTF-8 and Unicode FAQ for Unix/Linux&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Announcing Geo::libpostal</title>
      <link>http://perltricks.com/article/announcing-geo--libpostal/</link>
      <pubDate>Tue, 19 Jul 2016 08:33:59 +0000</pubDate>
      
      <guid>http://perltricks.com/article/announcing-geo--libpostal/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/openvenues/libpostal&#34;&gt;libpostal&lt;/a&gt; is a C library for normalizing and parsing international street addresses. It&amp;rsquo;s built from &lt;a href=&#34;http://www.openstreetmap.org/&#34;&gt;OpenStreetMap&lt;/a&gt; data, supports normalization in over 60 languages and can parse addresses from over 100 countries. It&amp;rsquo;s blindingly fast and now you can use it with Perl using &lt;a href=&#34;https://metacpan.org/pod/Geo::libpostal&#34;&gt;Geo::libpostal&lt;/a&gt;, a new module I wrote.&lt;/p&gt;

&lt;h3 id=&#34;normalizing-an-address:e046575a69114c4aa4ccae4e8b7fbc4f&#34;&gt;Normalizing an address&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s say you support an application with a customer sign up process where the customer provides their address. One way to prevent duplicate sign-ups is by allowing only one customer per address. But how do you handle the scenario where the customer types their address slightly differently every time?&lt;/p&gt;

&lt;p&gt;One answer is to use libpostal&amp;rsquo;s normalization capability to expand single address string into valid variants. If you already have a customer whose address matches one of the variants, you know you&amp;rsquo;ve got a duplicate sign-up. Let&amp;rsquo;s say you have a customer with the address &amp;ldquo;216 Park Avenue Apt 17D, New York, NY 10022&amp;rdquo;. Then another customer comes along with the ever-so-similar address &amp;ldquo;216 Park &lt;strong&gt;Ave&lt;/strong&gt; Apt 17D, New York, NY 10022&amp;rdquo;. Here&amp;rsquo;s how you can test for that with Perl:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Geo::libpostal &#39;expand_address&#39;;

my @original_variants = expand_address(&amp;quot;216 Park Avenue Apt 17D, New York, NY 10022&amp;quot;);

# @original_variants contains:
#   216 park avenue apartment 17d new york new york 10022
#   216 park avenue apartment 17d new york ny 10022

my @new_variants = expand_address(&amp;quot;216 Park Ave Apt 17D, New York, NY 10022&amp;quot;);

for my $address (@new_variants) {
  if (grep { $address eq $_ } @original_variants) {
    print &amp;quot;Duplicate address found!\n&amp;quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;expand_address()&lt;/code&gt; supports a ton of &lt;a href=&#34;https://metacpan.org/pod/Geo::libpostal#expand_address&#34;&gt;options&lt;/a&gt;: including returning results in multiple languages, expanding only certain components of an address, and the format of the expanded addresses.&lt;/p&gt;

&lt;h3 id=&#34;parsing-an-address:e046575a69114c4aa4ccae4e8b7fbc4f&#34;&gt;Parsing an address&lt;/h3&gt;

&lt;p&gt;libpostal can also parse an address string into its constituent parts using such as house name, number, city and postcode. This can be useful for all sorts of things from information extraction to simplifying web forms. This is how to parse an address string with Perl:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Geo::libpostal &#39;parse_address&#39;;

my %address = parse_address(&amp;quot;216 Park Avenue Apt 17D, New York, NY 10022&amp;quot;);

# %address contains:
#    road         =&amp;gt; &#39;park avenue apt 17d&#39;,
#    city         =&amp;gt; &#39;new york&#39;,
#    postcode     =&amp;gt; &#39;10022&#39;,
#    state        =&amp;gt; &#39;ny&#39;,
#    house_number =&amp;gt; &#39;216&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-slow-starter:e046575a69114c4aa4ccae4e8b7fbc4f&#34;&gt;A slow starter&lt;/h3&gt;

&lt;p&gt;To be as fast as possible, libpostal uses setup functions to create lookup tables in memory. These can take several seconds to construct, so under the hood Geo::libpostal lazily calls the setup functions for you. This means that the first call to &lt;code&gt;expand_address&lt;/code&gt; or &lt;code&gt;parse_address&lt;/code&gt; is a lot slower than usual as the setup functions are running as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Geo::libpostal &#39;expand_address&#39;;

# this is slow
@addresses = expand_address(&amp;quot;216 Park Avenue Apt 17D, New York, NY 10022&amp;quot;);

# this is fast!
@addresses = expand_address(&amp;quot;76 Ninth Avenue, New York, NY 10111&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, libpostal has teardown functions which unload the lookup tables. Geo::libpostal has an internal function, &lt;code&gt;_teardown&lt;/code&gt; that is automatically called in an &lt;code&gt;END&lt;/code&gt; block, but you can call it directly too. The only effect will be that the subsequent call to &lt;code&gt;expand_address&lt;/code&gt; or &lt;code&gt;parse_address&lt;/code&gt; will be slower, as the setup functions are called again. With the latest version of libpostal it is safe to call setup or teardown multiple times in a process.&lt;/p&gt;

&lt;h3 id=&#34;references:e046575a69114c4aa4ccae4e8b7fbc4f&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/openvenues/libpostal&#34;&gt;libpostal&lt;/a&gt; is hosted on GitHub and maintained by &lt;a href=&#34;http://iam.al/&#34;&gt;Al Barrentine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;This &lt;a href=&#34;https://medium.com/@albarrentine/statistical-nlp-on-openstreetmap-b9d573e6cc86#.5cbxb54w5&#34;&gt;blog post&lt;/a&gt; by Al Barrentine is an in-depth introduction to libpostal&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Geo::libpostal&#34;&gt;Geo::libpostal&lt;/a&gt; is hosted on &lt;a href=&#34;https://github.com/dnmfarrell/Geo-libpostal&#34;&gt;GitHub&lt;/a&gt;, pull requests welcome!&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>What&#39;s new on CPAN - June 2016</title>
      <link>http://perltricks.com/article/what-s-new-on-cpan---june-2016/</link>
      <pubDate>Wed, 13 Jul 2016 09:34:38 +0000</pubDate>
      
      <guid>http://perltricks.com/article/what-s-new-on-cpan---june-2016/</guid>
      <description>

&lt;p&gt;Welcome to &amp;ldquo;What&amp;rsquo;s new on CPAN&amp;rdquo;, a curated look at last month&amp;rsquo;s new CPAN uploads for your reading and programming pleasure. June saw YAPC::NA (among other conferences) which meant CPAN activity was lower than normal. I&amp;rsquo;m expecting a bumper July though; for now enjoy!&lt;/p&gt;

&lt;h3 id=&#34;apis-apps:3eb441e242dd6932e7a620f4de77124c&#34;&gt;APIs &amp;amp; Apps&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/App::Licensecheck&#34;&gt;App::Licensecheck&lt;/a&gt; inspects source files for licenses&lt;/li&gt;
&lt;li&gt;Use the Runkeeper (Health Graph) API with &lt;a href=&#34;https://metacpan.org/pod/WebService::HealthGraph&#34;&gt;WebService::HealthGraph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/WebService::SQLFormat&#34;&gt;WebService::SQLFormat&lt;/a&gt; formats SQL via the sqlformat.org API&lt;/li&gt;
&lt;li&gt;Monitor the status of other plack applications using &lt;a href=&#34;https://metacpan.org/pod/Plack::App::ServiceStatus&#34;&gt;Plack::App::ServiceStatus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;config-devops:3eb441e242dd6932e7a620f4de77124c&#34;&gt;Config &amp;amp; Devops&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;In the docs for &lt;a href=&#34;https://metacpan.org/pod/Acme::Devel::Hide::Tiny&#34;&gt;Acme::Devel::Hide::Tiny&lt;/a&gt; author David Golden shows how to force the unavailability of a module for testing without adding a test dependency&lt;/li&gt;
&lt;li&gt;Get a single list of all dependencies (including indirect ones) for a distribution with &lt;a href=&#34;https://metacpan.org/pod/CPAN::Flatten&#34;&gt;CPAN::Flatten&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;data:3eb441e242dd6932e7a620f4de77124c&#34;&gt;Data&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/DBIx::EAV&#34;&gt;DBIx::EAV&lt;/a&gt; enables Entity-Attribute-Value data modeling (aka &amp;lsquo;open schema&amp;rsquo;) via DBI&lt;/li&gt;
&lt;li&gt;Useful testing tool: generate random IPs with &lt;a href=&#34;https://metacpan.org/pod/IP::Random&#34;&gt;IP::Random&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Estimates the length of all the vectors in an SVG file using &lt;a href=&#34;https://metacpan.org/pod/SVG::Estimate&#34;&gt;SVG::Estimate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/String::Normal&#34;&gt;String::Normal&lt;/a&gt; is another text normalization module&lt;/li&gt;
&lt;li&gt;Extract strings from markup with &lt;a href=&#34;https://metacpan.org/pod/XML::Lenient&#34;&gt;XML::Lenient&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Get convenient, fast and jQuery-like DOM manipulation with &lt;a href=&#34;https://metacpan.org/pod/XML::LibXML::jQuery&#34;&gt;XML::LibXML::jQuery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;development-version-control:3eb441e242dd6932e7a620f4de77124c&#34;&gt;Development &amp;amp; Version Control&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Use U2F authentication with your app using with &lt;a href=&#34;https://metacpan.org/pod/Authen::U2F&#34;&gt;Authen::U2F&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/PDF::PDFUnit&#34;&gt;PDF::PDFUnit&lt;/a&gt; Perl interface to the Java PDFUnit testing framework&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://metacpan.org/pod/Parallel::Dragons&#34;&gt;Parallel::Dragons&lt;/a&gt; abstract says &amp;ldquo;Daemon are forever&amp;hellip; Dragons lay eggs, grow fast and die in flames!&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Useful Perl::Critic policies:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Perl::Critic::Policy::Moo::ProhibitMakeImmutable&#34;&gt;Perl::Critic::Policy::Moo::ProhibitMakeImmutable&lt;/a&gt; checks that Moo classes do not contain calls to make_immutable á la Moose&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Perl::Critic::Policy::TryTiny::RequireBlockTermination&#34;&gt;Perl::Critic::Policy::TryTiny::RequireBlockTermination&lt;/a&gt; checks that try/catch/finally blocks are properly terminated - this is so easy to get wrong and the error message is often cryptic.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Perl::Critic::Policy::TryTiny::RequireUse&#34;&gt;Perl::Critic::Policy::TryTiny::RequireUse&lt;/a&gt; checks that code which uses Try::Tiny actually imports it&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Do meta programming with &lt;a href=&#34;https://metacpan.org/pod/Sub::Attributes&#34;&gt;Sub::Attributes&lt;/a&gt; (disclosure - I am the module author)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;hardware:3eb441e242dd6932e7a620f4de77124c&#34;&gt;Hardware&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Medical: a SLURM-specific driver for HPCI using &lt;a href=&#34;https://metacpan.org/pod/HPCD::SLURM&#34;&gt;HPCD::SLURM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;New chip drivers:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Device::Chip::PCF8574&#34;&gt;Device::Chip::PCF8574&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Device::Chip::SSD1306&#34;&gt;Device::Chip::SSD1306&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;other:3eb441e242dd6932e7a620f4de77124c&#34;&gt;Other&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Solve for the WordBrain mobile Game with &lt;a href=&#34;https://metacpan.org/pod/Game::WordBrain&#34;&gt;Game::WordBrain&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ham radio enthusiasts:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Ham::WSJTX::Logparse&#34;&gt;Ham::WSJTX::Logparse&lt;/a&gt; parses ALL.TXT log files from Joe Taylor K1JT&amp;rsquo;s WSJT-X, to extract CQ and calling station information for all entries in a given amateur band&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Ham::WorldMap&#34;&gt;Ham::WorldMap&lt;/a&gt; creates an Imager image containing an equirectangular projection of the world map, with optional Maidenhead locator grid and day/night illumination and additional utility methods&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;science-mathematics:3eb441e242dd6932e7a620f4de77124c&#34;&gt;Science &amp;amp; Mathematics&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Math::BivariateCDF&#34;&gt;Math::BivariateCDF&lt;/a&gt; provides Bivariate CDF functions&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;web:3eb441e242dd6932e7a620f4de77124c&#34;&gt;Web&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Interesting: &lt;a href=&#34;https://metacpan.org/pod/Mojo::UserAgent::CookieJar::ChromeMacOS&#34;&gt;Mojo::UserAgent::CookieJar::ChromeMacOS&lt;/a&gt; can read OSX Chrome Chrome cookies for Mojo::UserAgent&lt;/li&gt;
&lt;li&gt;Scrape the FindaGrave site using &lt;a href=&#34;https://metacpan.org/pod/WWW::Scrape::FindaGrave&#34;&gt;WWW::Scrape::FindaGrave&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Weasel&#34;&gt;Weasel&lt;/a&gt; let&amp;rsquo;s you use a single module for different web drivers like Selenium. Inspired by PHP&amp;rsquo;s Mink&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Write multiline programs at the terminal</title>
      <link>http://perltricks.com/article/write-multiline-programs-at-the-terminal/</link>
      <pubDate>Tue, 05 Jul 2016 11:18:55 +0000</pubDate>
      
      <guid>http://perltricks.com/article/write-multiline-programs-at-the-terminal/</guid>
      <description>

&lt;p&gt;Perl one liners are incredibly useful, and when I&amp;rsquo;m working I write several a day. Whether it&amp;rsquo;s to test if a new module compiles, check the syntax of a function, or edit a file, one liners do the trick. Sometimes when I need to do something more involved, instead of a one liner I&amp;rsquo;ll write a throwaway script. Of course I usually forget to delete the script and that&amp;rsquo;s why my machine is littered with Perl files like &amp;lsquo;tmp.pl&amp;rsquo;, &amp;lsquo;getname.pl&amp;rsquo; etc. But I&amp;rsquo;ve since found a better way - using a shell here-doc!&lt;/p&gt;

&lt;h3 id=&#34;shell-here-docs:d9e36343a40cb58c91b5d1c8b86bcefc&#34;&gt;Shell here-docs&lt;/h3&gt;

&lt;p&gt;In the terminal I can use the here-doc syntax to write an entire Perl script at the command line. Here&amp;rsquo;s an example using &lt;a href=&#34;https://metacpan.org/pod/HTTP::Tiny&#34;&gt;HTTP::Tiny&lt;/a&gt; to print out the HTTP headers returned by this website.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl - &amp;lt;&amp;lt;&#39;EOF&#39;
&amp;gt; use HTTP::Tiny;
&amp;gt; use Data::Dumper;
&amp;gt; my $res = HTTP::Tiny-&amp;gt;new-&amp;gt;get(&#39;http://perltricks.com/&#39;);
&amp;gt; print Dumper($res-&amp;gt;{headers});
&amp;gt; EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s happening here? The syntax &lt;code&gt;perl -&lt;/code&gt; primes Perl to execute STDIN. The syntax for a shell here-doc is &lt;code&gt;&amp;lt;&amp;lt;&#39;word&#39;&lt;/code&gt; where &amp;ldquo;word&amp;rdquo; is the value to terminate the here-doc with (I tend to use &lt;code&gt;EOF&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;). After typing the first line and pressing enter, the shell caret will move to a new line, prefixed with &lt;code&gt;&amp;gt;&lt;/code&gt;. It would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl - &amp;lt;&amp;lt;&#39;EOF&#39;
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, you can type the lines of the Perl script, pressing enter for a new line. Or you can paste in code from an existing script. Once you type the terminating word on a new line, the terminal sends the script to &lt;code&gt;perl&lt;/code&gt; via STDIN. Unlike with one-liners, you&amp;rsquo;re free to use both single and double quotes in the program text. Yay!&lt;/p&gt;

&lt;p&gt;If I want shell parameter expansion, I leave the terminator unquoted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl - &amp;lt;&amp;lt;EOF
&amp;gt; print &amp;quot;$HOME\n&amp;quot;
&amp;gt; EOF
/home/dfarrell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I can write throwaway scripts in the terminal, and not leave them littered all over my hard drive. Just like other successful commands, Bash will store the script in it&amp;rsquo;s history, so you can search for, edit and re-execute the scripts over and over again.&lt;/p&gt;

&lt;p&gt;This trick isn&amp;rsquo;t specific to Perl. Shell here-docs can be used in the same way to execute code in Perl 6, Python, Ruby &amp;hellip; any binary which can execture code from STDIN.&lt;/p&gt;

&lt;h3 id=&#34;editing-tips:d9e36343a40cb58c91b5d1c8b86bcefc&#34;&gt;Editing tips&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s say you just ran a throwaway script using a here-doc, and now you want to edit it and run it again. If you press the up arrow, Bash will display the command, but you can&amp;rsquo;t press up again, else Bash will display the previous command. Instead, use the left and right arrow keys to move to the beginning and end of lines, and the caret will automatically jump to the next line.&lt;/p&gt;

&lt;p&gt;When editing a throwaway script, I start by deleting the terminator word (&amp;ldquo;EOF&amp;rdquo; or whatever). That way when I press enter, I can add more lines to the script. If the command you&amp;rsquo;re looking for is an old one, you can search your terminal history with &lt;code&gt;&amp;lt;Ctrl&amp;gt;&amp;lt;shift&amp;gt;r&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;references:d9e36343a40cb58c91b5d1c8b86bcefc&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The Wikipedia &lt;a href=&#34;https://en.wikipedia.org/wiki/Heredoc#Unix_shells&#34;&gt;here-docs entry&lt;/a&gt; has examples of shell here-doc syntax.&lt;/li&gt;
&lt;li&gt;The bash manpage (&lt;code&gt;man bash&lt;/code&gt;) has a concise but useful entry on shell here-docs and the different types.&lt;/li&gt;
&lt;li&gt;The more common way to use here-docs is inside Perl code. Read about &lt;em&gt;those&lt;/em&gt; in &lt;a href=&#34;http://perldoc.perl.org/perlop.html&#34;&gt;perlop&lt;/a&gt;, the official Perl documentation.Read it in the terminal with &lt;code&gt;perldoc perlop&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/HTTP::Tiny&#34;&gt;HTTP::Tiny&lt;/a&gt; is a lightweight, &lt;em&gt;fast&lt;/em&gt; Perl user agent that comes bundled with Perl (since version 5.14.0). You probably have it installed already, so you can read it&amp;rsquo;s documentation with &lt;code&gt;perldoc HTTP::Tiny&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;N.B. When reading documentation in the terminal, type &lt;code&gt;/search-term&amp;lt;enter&amp;gt;&lt;/code&gt; to jump to the next search match. Pressing &lt;code&gt;n&lt;/code&gt; will jump to the next match and &lt;code&gt;N&lt;/code&gt; the previous match. Pressing &lt;code&gt;h&lt;/code&gt; will display the help page. (all of this assumes your terminal reader is &lt;code&gt;less&lt;/code&gt;, which is typical).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Untangling subroutine attributes</title>
      <link>http://perltricks.com/article/untangling-subroutine-attributes/</link>
      <pubDate>Wed, 29 Jun 2016 08:37:20 +0000</pubDate>
      
      <guid>http://perltricks.com/article/untangling-subroutine-attributes/</guid>
      <description>

&lt;p&gt;Subroutine attributes are optional labels that can be included in a subroutine declaration. They&amp;rsquo;re a curious feature with a clunky interface and minimal documentation. They seem underused, but it&amp;rsquo;s hard to think of legitimate uses for them. In my opinion the coolest thing about subroutine attributes is that they run at compile time. This means you can execute custom code before the main program is run, and seeing as Perl gives you access to the symbol table, you can basically do wizardy things.&lt;/p&gt;

&lt;h3 id=&#34;the-lvalue-trick:d2b269acfdd0ebc3293d2a34b1704830&#34;&gt;The lvalue trick&lt;/h3&gt;

&lt;p&gt;Perl has several subroutine attributes built-in. A useful one is &lt;code&gt;lvalue&lt;/code&gt; which tells Perl that the subroutine refers to a variable that persists beyond individual calls. A common case is using them as method getter/setters:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Foo;

sub new { bless {}, shift }

sub bar :lvalue {
  my $self = shift;

  # must return the variable for lvalue-ness
  $self-&amp;gt;{bar};
}

package main;

my $foo = Foo-&amp;gt;new();

$foo-&amp;gt;bar = &amp;quot;dogma&amp;quot;; # not $foo-&amp;gt;bar(&amp;quot;dogma&amp;quot;);
print $foo-&amp;gt;bar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By adding the attribute &lt;code&gt;:lvalue&lt;/code&gt; to the &lt;code&gt;bar&lt;/code&gt; subroutine, I can use it like a variable, getting, setting and substituting and so on.&lt;/p&gt;

&lt;h3 id=&#34;custom-attributes:d2b269acfdd0ebc3293d2a34b1704830&#34;&gt;Custom attributes&lt;/h3&gt;

&lt;p&gt;To use custom attributes in a package, you must provide a subroutine called &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt;. Perl will call this subroutine during compilation if it find any custom subroutine attributes. It&amp;rsquo;s called once for every subroutine with custom attributes. &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; receives the package name, a coderef to the subroutine and a list of the attributes it declared:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Sub::Attributes;

sub MODIFY_CODE_ATTRIBUTES {
  my ($package, $coderef, @attributes) = @_;
  return ();
}

sub _internal_function :Private {
  ...
}
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve created a new package with the required subroutine - all it does is return an empty list. I&amp;rsquo;ve then declared an empty subroutine called &lt;code&gt;_internal_function&lt;/code&gt; which has a custom attribute, &lt;code&gt;Private&lt;/code&gt;. I want to do the impossible and create truly private subroutines in Perl by making any subroutine with the &lt;code&gt;Private&lt;/code&gt; attribute only callable by its own package. But what if I misspell &lt;code&gt;Private&lt;/code&gt;?  If we received any attributes we didn&amp;rsquo;t recognize, &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt; can add them to a list and Perl will throw a compile time error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Sub::Attributes;

sub MODIFY_CODE_ATTRIBUTES {
  my ($package, $coderef, @attributes, @disallowed) = @_;

  push @disallowed, grep { $_ ne &#39;Private&#39; } @attributes;

  return @disallowed;
}

sub _internal_function :Private {
  ...
}
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve updated to code to declare and return &lt;code&gt;@disallowed&lt;/code&gt; - an array of any unrecognized subroutine attributes. Even though it&amp;rsquo;s declared in the first line of the subroutine, it will always be empty because &lt;code&gt;@attributes&lt;/code&gt; gobbles up all remaining arguments passed to the subroutine. Next I grep through the list of attributes received and if any don&amp;rsquo;t match &amp;ldquo;Private&amp;rdquo;, I add them to the disallowed array.&lt;/p&gt;

&lt;h3 id=&#34;adding-compile-time-behavior:d2b269acfdd0ebc3293d2a34b1704830&#34;&gt;Adding compile time behavior&lt;/h3&gt;

&lt;p&gt;Now any subroutine in the package can use the attribute &lt;code&gt;Private&lt;/code&gt; but it doesn&amp;rsquo;t do anything. I need to add some behavior!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Sub::Attributes;
use B &#39;svref_2object&#39;;

sub MODIFY_CODE_ATTRIBUTES {
  my ($package, $coderef, @attributes, @disallowed) = @_;

  my $subroutine_name = svref_2object($coderef)-&amp;gt;GV-&amp;gt;NAME;

  my %allowed = (
    Private =&amp;gt; sub {
        my ($coderef, @args) = @_;
        my ($calling_package, $filename, $line, $sub) = caller(2);
        croak &#39;Only the object may call this sub&#39; unless $sub &amp;amp;&amp;amp; $sub =~ /^Sub\:\:Attributes\:\:/;
        $coderef-&amp;gt;(@args);
      },
  );

  for my $attribute (@attributes) {
    # parse the attribute into name and value

    # attribute not known, compile error
    push(@disallowed, $attribute) &amp;amp;&amp;amp; next unless exists $allowed{$attribute};

    # override subroutine with attribute coderef
    my $overrider = $allowed{$attribute};
    my $old_coderef = $coderef;
    $coderef = sub { $overrider-&amp;gt;($old_coderef, @_) };
    *{&amp;quot;Sub:\:Attributes:\:$subroutine_name&amp;quot;} = $coderef;
  }
  return @disallowed;
}

sub _internal_function :Private {
  ...
}

sub call_internal_function {
  _internal_function();
}
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code imports the &lt;code&gt;svref_2object&lt;/code&gt; function from the &lt;a href=&#34;https://metacpan.org/pod/B&#34;&gt;B&lt;/a&gt; module. This handy function takes a reference and returns an object with the data from Perl&amp;rsquo;s internals. In this case, passing a coderef returns a &lt;a href=&#34;https://metacpan.org/pod/B#B::CV-Methods&#34;&gt;B::CV&lt;/a&gt; object. I use this to get the subroutine name and overrride the subroutine later.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve created a hash called &lt;code&gt;%allowed&lt;/code&gt; which is where I can declare any permitted custom attributes and their associated code. For &lt;code&gt;Private&lt;/code&gt; I made a coderef that checks the caller is in the same package and croaks if it&amp;rsquo;s not, else it will call it.&lt;/p&gt;

&lt;p&gt;Next I loop through any attributes received, and check they exist in &lt;code&gt;%attributes&lt;/code&gt;. If they don&amp;rsquo;t, I push them into &lt;code&gt;@disallowed&lt;/code&gt; and skip to the next attribute. If the attribute does exist, I assign the coderef to &lt;code&gt;$overrider&lt;/code&gt; and declare a new coderef which will call &lt;code&gt;$overrider&lt;/code&gt; passing the old coderef to be called.&lt;/p&gt;

&lt;p&gt;Finally I override the &lt;code&gt;Private&lt;/code&gt; subroutine with the new coderef:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*{&amp;quot;Sub:\:Attributes:\:$subroutine_name&amp;quot;} = $coderef;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how you override subroutines using a &lt;a href=&#34;http://perldoc.perl.org/perldata.html#Typeglobs-and-Filehandles&#34;&gt;typeglob&lt;/a&gt; (&lt;a href=&#34;https://www.amazon.com/Mastering-Perl-brian-d-foy/dp/144939311X/&#34;&gt;Mastering Perl&lt;/a&gt; has a whole chapter dedicated to features like these, highly recommended). But what about that backslash in the middle of the colons &lt;code&gt;:\:&lt;/code&gt;?. That escape is necessary for the code to run on Perl versions 5.16 through 5.18 (thanks to Andreas König for debugging this).&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re wondering why I bothered to create &lt;code&gt;$old_coderef&lt;/code&gt; at all, it&amp;rsquo;s so that a subroutine can have multiple attributes with new behaviors nested inside each other.&lt;/p&gt;

&lt;p&gt;Now any calls to &lt;code&gt;_internal_function&lt;/code&gt; will croak unless they come from within Sub::Attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Sub::Attributes;

Sub::Attributes::call_internal_function(); # ok
Sub::Attributes::_internal_function(); # croak!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;making-it-re-useable:d2b269acfdd0ebc3293d2a34b1704830&#34;&gt;Making it re-useable&lt;/h3&gt;

&lt;p&gt;If it seems dumb to create custom attributes and then elsewhere in the same code, validate those attributes, join the club. To get the most out of this system, you have to make your custom attributes re-usable. Fortunately, just a few changes are needed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Sub::Attributes;
use B &#39;svref_2object&#39;;

sub MODIFY_CODE_ATTRIBUTES {
  my ($package, $coderef, @attributes, @disallowed) = @_;

  my $subroutine_name = svref_2object($coderef)-&amp;gt;GV-&amp;gt;NAME;

  my %allowed = (
    Private =&amp;gt;
      sub {
        my $package = shift;
        return sub {
          my ($coderef, @args) = @_;
          my ($calling_package, $filename, $line, $sub) = caller(2);
          croak &#39;Only the object may call this sub&#39; unless $sub &amp;amp;&amp;amp; $sub =~ /^$package\:\:/;
          $coderef-&amp;gt;(@args);
        }
      },
  );

  for my $attribute (@attributes) {
    # parse the attribute into name and value

    # attribute not known, compile error
    push(@disallowed, $attribute) &amp;amp;&amp;amp; next unless exists $allowed{$attribute};

    # execute compile time code
    my $overrider = $allowed{$attribute}-&amp;gt;($package);
    next unless $overrider;

    # override the subroutine if necessary
    my $old_coderef = $coderef;
    $coderef = sub { $overrider-&amp;gt;($old_coderef, @_) };
    *{&amp;quot;$package:\:$subroutine_name&amp;quot;} = $coderef;
  }

  $Sub::Attributes::attributes{$package}{$subroutine_name} = \@attributes;
  return @disallowed;
};
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rather than hardcoding the package name, I&amp;rsquo;ve made it dynamic. The key change here is that the coderef for &lt;code&gt;Private&lt;/code&gt; has been changed to a coderef that returns another coderef. Now I can execute some arbitrary code at compile time and optionally manufacture a new coderef that uses compile time information. In the case of &lt;code&gt;Private&lt;/code&gt;, I want to pass the package name of the private subroutine, so I can check later that the caller is from within the same package.&lt;/p&gt;

&lt;p&gt;Why optionally return a coderef? Imagine if I created an attribute called &lt;code&gt;After&lt;/code&gt; which behaved like the &lt;code&gt;after&lt;/code&gt; function in &lt;a href=&#34;https://metacpan.org/pod/Class::Method::Modifiers&#34;&gt;Class::Method::Modifiers&lt;/a&gt;. In this case the subroutine with the private attribute would be reference a &lt;em&gt;different&lt;/em&gt; subroutine. That might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub foo { }

sub logger :After(foo) {
  print &amp;quot;foo() was called!\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here &lt;code&gt;logger&lt;/code&gt; should be executed after &lt;code&gt;foo&lt;/code&gt;. So logger itself never changes, and doesn&amp;rsquo;t need to be overridden.&lt;/p&gt;

&lt;p&gt;I store the attributes for a subroutine under the package name in the symbol table for &lt;code&gt;Sub::Attributes&lt;/code&gt;. I could add them to the package&amp;rsquo;s symbol table, but I might inadvertently overwrite something else, so I keep the data within the &lt;code&gt;Sub::Attributes&lt;/code&gt; namespace.&lt;/p&gt;

&lt;p&gt;$Sub::Attributes::attributes{$package}{$subroutine_name} = \@attributes;&lt;/p&gt;

&lt;h3 id=&#34;why-no-fetch-code-attributes:d2b269acfdd0ebc3293d2a34b1704830&#34;&gt;Why no FETCH_CODE_ATTRIBUTES?&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;attribute&lt;/code&gt; &lt;a href=&#34;http://perldoc.perl.org/attributes.html&#34;&gt;docs&lt;/a&gt; mention another subroutine, called &lt;code&gt;FETCH_CODE_ATTRIBUTES&lt;/code&gt; that given a coderef, should return the attributes for the referenced subroutine. When &lt;code&gt;attributes::get&lt;/code&gt; is called, it passes the class of the declaring package, which is &lt;code&gt;Sub::Attributes&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# $class == &amp;quot;Sub::Attributes&amp;quot;
sub FETCH_CODE_ATTRIBUTES {
  my ($class, $coderef) = @_;
  my $cv = svref_2object($coderef);
  # $class should be subclass name, not Sub::Attributes
  return @{$Sub::Attributes::attributes{$class}{ $cv-&amp;gt;GV-&amp;gt;NAME }};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don&amp;rsquo;t see a way to find out the package name of the original subroutine. &lt;code&gt;FETCH_CODE_ATTRIBUTTES&lt;/code&gt; is not required and if it&amp;rsquo;s not there Perl won&amp;rsquo;t throw an exception if &lt;code&gt;attributes::get&lt;/code&gt; is called. Instead I provided the &lt;code&gt;sub_attributes&lt;/code&gt; method which does work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub sub_attributes {
  my ($package) = @_;
  my $class_name = ref $package || $package;
  return $Sub::Attributes::attributes{ $class_name };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This returns the attributes stored for a package. This might be useful if other packages want to inspect the attributes for a package&amp;rsquo;s subroutine. it can be called as an object method or class method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Foo;
use base &#39;Sub::Attributes&#39;;

...

Foo-&amp;gt;sub_attributes(); # works
$foo-&amp;gt;sub_attributes(); # works also
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;squashing-warnings:d2b269acfdd0ebc3293d2a34b1704830&#34;&gt;Squashing warnings&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s generally good practice to use the &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas to help detect issues with our code. However the code so far will emit some warnings and an exception if we add those pragmas as-is. This code will add the pragmas but make Perl ignore the violations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
no strict &#39;refs&#39;;
use warnings;
no warnings qw(reserved redefine);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;reserved&lt;/code&gt; warning is of particular interest here. This would be caused by using custom subroutine attributes, so no matter what, you&amp;rsquo;d want to turn that off. Redefine is a warning emitted whenever a subroutine is over-written, strict references means no interpolating of variable names in symbol table lookups; we need these features so we can dynamically patch subroutines like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*{&amp;quot;$class:\:$subroutine&amp;quot;} = $coderef
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;making-it-extensible:d2b269acfdd0ebc3293d2a34b1704830&#34;&gt;Making it extensible&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;ve gone to the hard work of setting up the code for inheritable custom attributes, why not make it extensible? That way consuming packages can add their own custom attributes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Sub::Attributes;
use strict;
no strict &#39;refs&#39;;
use warnings;
no warnings qw(reserved redefine);

use B &#39;svref_2object&#39;;

BEGIN {
  our %allowed = (
    Private =&amp;gt;
      sub {
        my $package = shift;
        return sub {
          my ($coderef, @args) = @_;
          my ($calling_package, $filename, $line, $sub) = caller(2);
          croak &#39;Only the object may call this sub&#39; unless $sub &amp;amp;&amp;amp; $sub =~ /^$package\:\:/;
          $coderef-&amp;gt;(@args);
        }
      },
    # compile time override, run a coderef after running the subroutine
    After =&amp;gt; sub {
      my ($package, $value, $coderef) = @_;

      # full name of the sub to override
      my $fq_sub = &amp;quot;$package:\:$value&amp;quot;;

      my $target_coderef = \&amp;amp;{$fq_sub};
      *{$fq_sub} = sub {
        my @rv = $target_coderef-&amp;gt;(@_);
        $coderef-&amp;gt;(@_);
        return wantarray ? @rv : $rv[0];
      };

      # we didn&#39;t change the method with the attribute
      # so we return undef as we have no runtime changes
      return undef;
    },
  );
}

sub MODIFY_CODE_ATTRIBUTES {
  my ($package, $coderef, @attributes, @disallowed) = @_;

  my $subroutine_name = svref_2object($coderef)-&amp;gt;GV-&amp;gt;NAME;

  for my $attribute (@attributes) {
    # parse the attribute into name and value
    my ($name, $value) = $attribute =~ qr/^ (\w+) (?:\((\S+?)\))? $/x;

    # attribute not known, compile error
    push(@disallowed, $name) &amp;amp;&amp;amp; next unless exists $Sub::Attributes::allowed{$name};

    # execute compile time code
    my $overrider = $Sub::Attributes::allowed{$name}-&amp;gt;($package, $value, $coderef);
    next unless $overrider;

    # override the subroutine if necessary
    my $old_coderef = $coderef;
    $coderef = sub { $overrider-&amp;gt;($old_coderef, @_) };
    *{&amp;quot;$package:\:$subroutine_name&amp;quot;} = $coderef;
  }

  $Sub::Attributes::attributes{$package}{$subroutine_name} = \@attributes;
  return @disallowed;
};

sub sub_attributes {
  my ($package) = @_;
  my $class_name = ref $package || $package;
  return $Sub::Attributes::attributes{ $class_name };
}
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve moved the &lt;code&gt;%allowed&lt;/code&gt; hash into a &lt;code&gt;BEGIN&lt;/code&gt; block - this has to be declared at compile time so it&amp;rsquo;s available for &lt;code&gt;MODIFY_CODE_ATTRIBUTES&lt;/code&gt;. Now new custom attributes can be added by modifying &lt;code&gt;%Sub::Attributes::attributes&lt;/code&gt;. I also added a new custom attribute &lt;code&gt;After&lt;/code&gt; which implements causes the subroutine to be called after another one, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub foo { }

sub bar :After(foo) {
  print &amp;quot;foo() was called!\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I added a regex which captures the attribute name and value when passing attributes (so for &lt;code&gt;After(foo)&lt;/code&gt; &amp;ldquo;After&amp;rdquo; is the name and &amp;ldquo;foo&amp;rdquo; is the value). The &lt;code&gt;$value&lt;/code&gt; and &lt;code&gt;$coderef&lt;/code&gt; are now passed to the custom attribute&amp;rsquo;s subroutine to allow compile-time overrides of other subroutines.&lt;/p&gt;

&lt;h3 id=&#34;resources:d2b269acfdd0ebc3293d2a34b1704830&#34;&gt;Resources&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://perldoc.perl.org/attributes.html&#34;&gt;attributes&lt;/a&gt; is the official documentation on attributes.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Sub::Attributes&#34;&gt;Sub::Attributes&lt;/a&gt; is my module which implements the above code, and adds a few more custom attributes.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://perldoc.perl.org/perldata.html#Typeglobs-and-Filehandles&#34;&gt;perldata&lt;/a&gt; has an entry on typeglobs and the symbol table.&lt;/li&gt;
&lt;li&gt;Chapters 7 &amp;amp; 8 of &lt;a href=&#34;https://www.amazon.com/Mastering-Perl-brian-d-foy/dp/144939311X/&#34;&gt;Mastering Perl&lt;/a&gt; second edition cover the symbol table and overrriding subroutines in detail.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://perldoc.perl.org/perlsub.html&#34;&gt;perlsub&lt;/a&gt; has information on lvalue subroutines.&lt;/li&gt;
&lt;li&gt;Two useful blog posts by mascip on &lt;a href=&#34;http://blogs.perl.org/users/mascip/2014/02/subroutine-attributes-how-to-use-them-and-what-for.html&#34;&gt;possible uses&lt;/a&gt; and &lt;a href=&#34;http://blogs.perl.org/users/mascip/2014/02/three-ways-to-introduce-othogonal-behavior-aspects-method-modifiers-and-subroutine-attributes.html&#34;&gt;when to use&lt;/a&gt; subroutine attributes.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Attribute::Handlers&#34;&gt;Attribute::Handlers&lt;/a&gt; provides a mechanism for calling subroutines via attributes.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The road to a 55x speedup with XS</title>
      <link>http://perltricks.com/article/the-road-to-a-55x-speedup-with-xs/</link>
      <pubDate>Tue, 14 Jun 2016 20:54:51 +0000</pubDate>
      
      <guid>http://perltricks.com/article/the-road-to-a-55x-speedup-with-xs/</guid>
      <description>

&lt;p&gt;Lately my client has been concerned with improving their application speed, so naturally I started to think about XS, Perl&amp;rsquo;s C macro language. With XS you can write C code and call it from Perl.&lt;/p&gt;

&lt;p&gt;To test the waters I wrote a simple URI encoder/decoder in C and with some trial-and-error managed to make &lt;a href=&#34;https://metacpan.org/pod/URI::Encode::XS&#34;&gt;URI::Encode::XS&lt;/a&gt;, a module that used it. &amp;ldquo;This is easy!&amp;rdquo; I thought and excitedly typed out a benchmarking &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode-XS/blob/master/bench&#34;&gt;script&lt;/a&gt;. I benchmarked my module against &lt;a href=&#34;https://metacpan.org/pod/URI::Escape&#34;&gt;URI::Escape&lt;/a&gt; a venerable but rather slow &lt;em&gt;pure-Perl&lt;/em&gt; URI encoder/decoder. You can imagine how crestfallen I was when I read the benchmark results to find that all of my effort only netted a 20% speedup. I wondered if Perl&amp;rsquo;s string routines are so fast they&amp;rsquo;re hard to improve upon.&lt;/p&gt;

&lt;h3 id=&#34;renewed-hope:4569416bc6792b95aa8a57ed35ded62b&#34;&gt;Renewed hope&lt;/h3&gt;

&lt;p&gt;Enter &lt;a href=&#34;https://metacpan.org&#34;&gt;URI::XSEscape&lt;/a&gt;, a &amp;ldquo;quick and dirty&amp;rdquo; (the authors&amp;rsquo; words) XS implementation of URI::Escape. It was uploaded to CPAN last month. You can see the authors&amp;rsquo; &lt;a href=&#34;https://metacpan.org/pod/URI::XSEscape#BENCHMARKS&#34;&gt;benchmarks&lt;/a&gt; for yourself, but in my testing it appeared to be about 18.5 times faster than URI::Escape. That&amp;rsquo;s not a misprint - on my laptop it encoded 2.75m strings per second, compared to 138k for URI::Escape. So how did they do it?&lt;/p&gt;

&lt;p&gt;First let&amp;rsquo;s look at my naive C encode implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;void *uri_encode (char *uri, const char *special_chars, char *buffer)
{
  int i = 0;
  /* \0 is null, end of the string */
  while (uri[i] != &#39;\0&#39;)
  {
    int encode_char = 1;
    int j = 0;
    while (special_chars[j] != &#39;\0&#39;)
    {
      if (uri[i] == special_chars[j])
      {
        /* do not encode char as it is in the special_chars set */
        encode_char = 0;
        break;
      }
      j++;
    }
    if (encode_char == 1)
    {
      char code[4];
      sprintf(code, &amp;quot;%%%02X&amp;quot;, uri[i]);
      strcat(buffer, code);
    }
    else
    {
      char code[2];
      code[0] = uri[i];
      code[1] = &#39;\0&#39;;
      strcat(buffer, code);
    }
    i++;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically what this does is loop through the &lt;code&gt;uri&lt;/code&gt; string, looking characters that are in the &lt;code&gt;special_chars&lt;/code&gt; string, and if it finds a match, it percent encodes the character with &lt;code&gt;sprintf&lt;/code&gt; and appends the result to &lt;code&gt;buffer&lt;/code&gt; which is the encoded string. Compare this with the encode function from &lt;code&gt;URI::XSEscape&lt;/code&gt; (I&amp;rsquo;ve simplified it slightly):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;Buffer* uri_encode(Buffer* src, int length,
                   Buffer* tgt)
{
    int s = src-&amp;gt;pos;
    int t = tgt-&amp;gt;pos;

    while (s &amp;lt; (src-&amp;gt;pos + length)) {
        unsigned char u = (unsigned char) src-&amp;gt;data[s];
        char* v = uri_encode_tbl[(int)u];

        /* if current source character doesn&#39;t need to be encoded,
           just copy it to target*/
        if (!v) {
            tgt-&amp;gt;data[t++] = src-&amp;gt;data[s++];
            continue;
        }

        /* copy encoded character from our table */
        tgt-&amp;gt;data[t+0] = &#39;%&#39;;
        tgt-&amp;gt;data[t+1] = v[0];
        tgt-&amp;gt;data[t+2] = v[1];

        /* we used up 3 characters (%XY) in target
         * and 1 character from source */
        t += 3;
        ++s;
    }
    /* null-terminate target and return src as was left */
    src-&amp;gt;pos = s;
    tgt-&amp;gt;pos = t;
    buffer_terminate(tgt);
    return src;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code loops through the input string but instead of comparing the current character to another string of special characters, it does a table lookup. This is much faster than looping through another string. Note how it doesn&amp;rsquo;t use &lt;code&gt;sprintf&lt;/code&gt; either - all the hex codes are pre-computed in &lt;code&gt;uri_encode_tbl&lt;/code&gt;. Finally, instead of creating a new string and concatenating it to the output string, this code simply copies the output directly to the output string&amp;rsquo;s memory location.&lt;/p&gt;

&lt;p&gt;This code also avoid a subtle bug with my implementation: Perl strings can contain null characters, but in C null is used to terminate strings. Because URI::XSEscape&amp;rsquo;s encode function accepts a length argument, it can encode strings will nulls and my version can&amp;rsquo;t.&lt;/p&gt;

&lt;h3 id=&#34;going-faster:4569416bc6792b95aa8a57ed35ded62b&#34;&gt;Going faster&lt;/h3&gt;

&lt;p&gt;At this point I updated the encode/decode functions in URI::Encode::XS to be table based like URI::XSEscape and saw huge gains in performance, making URI::Encode::XS about 25 times faster than URI::Escape (URI::Encode::XS doesn&amp;rsquo;t support user-defined escape values, so it&amp;rsquo;s simpler than URI::XSEscape). I thought a 25x improvement was as good as it got, and was about done with the module, when I was contacted by &lt;a href=&#34;https://metacpan.org/author/CHANSEN&#34;&gt;Christian Hansen&lt;/a&gt; (author of &lt;a href=&#34;https://metacpan.org/release/Time-Moment&#34;&gt;Time::Moment&lt;/a&gt;). Christian overhauled my simple XS code to make it safer and faster. This is what became of the &lt;code&gt;uri_encode&lt;/code&gt; C function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;size_t uri_encode (const char *src, const size_t len, char *dst)
{
  size_t i = 0, j = 0;
  while (i &amp;lt; len
  {
    const char * code = uri_encode_tbl[ (unsigned char)src[i] ];
    if (code)
    {
      memcpy(&amp;amp;dst[j], code, 3);
      j += 3;
    }
    else
    {
      dst[j] = src[i];
      j++;
    }
    i++;
  }
  dst[j] = &#39;\0&#39;;
  return j;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version looks up the character value in a pre-computed table and then uses &lt;code&gt;memcpy&lt;/code&gt; to append it to the output string (avoiding 3 separate assignments). It also returns the length of encoded string, which is useful. After Christian&amp;rsquo;s optimizations, my benchmarking &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode-XS/blob/master/bench&#34;&gt;script&lt;/a&gt; showed URI::Encode::XS&amp;rsquo;s encoding function to be 55 times faster than URI::Escape (about 8m encoded strings per second). Much of the gains came from optimizing the &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode-XS/blob/df8009e9d7af4cf243fa29ca8aaa23982feeba58/XS.xs#L143&#34;&gt;xsub&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;the-power-of-c-the-pleasure-of-perl:4569416bc6792b95aa8a57ed35ded62b&#34;&gt;The power of C, the pleasure of Perl&lt;/h3&gt;

&lt;p&gt;To me the most magical thing about XS code is you call it from Perl:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use URI::Encode::XS &#39;uri_encode&#39;;

my $encoding = uri_encode($some_string); # super fast
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the user has the convenience of writing Perl code, but the benefit of the faster implementation. Perl is already pretty fast, but there are certain operations that are expensive. If you work on a Perl application, how much faster would it be if you could make all of the bottlenecks 55 times faster?&lt;/p&gt;

&lt;h3 id=&#34;learning-xs:4569416bc6792b95aa8a57ed35ded62b&#34;&gt;Learning XS&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;d like to learn more about XS, I&amp;rsquo;d strongly recommend this &lt;a href=&#34;http://world.std.com/~swmcd/steven/perl/pm/xs/intro/index.html&#34;&gt;series&lt;/a&gt; by Steven W McDougall. It&amp;rsquo;s the best introduction I know of.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/xsawyerx/xs-fun&#34;&gt;XS is Fun&lt;/a&gt; is a more modern introduction to XS programming that takes you through the steps of writing an XS module and importing a C library.&lt;/p&gt;

&lt;p&gt;Chapter 18 &amp;ldquo;Extending Perl: A First Course&amp;rdquo; in &lt;a href=&#34;http://shop.oreilly.com/product/9781565922204.do&#34;&gt;Advanced Perl Programming&lt;/a&gt; first edition has a good introduction to XS. It covers the most common macros for scalars, arrays and hashes which is useful (the second edition doesn&amp;rsquo;t cover XS). &lt;a href=&#34;https://www.manning.com/books/extending-and-embedding-perl&#34;&gt;Extending and Embedding Perl&lt;/a&gt; goes further, with several tutorials on the different ways to call and receive data from XS. Both books are a bit dated but I found them valuable and an easier read than the official docs.&lt;/p&gt;

&lt;p&gt;The official Perl documentation has useful reference sources: &lt;a href=&#34;http://perldoc.perl.org/perlxs.html&#34;&gt;perlxs&lt;/a&gt;, &lt;a href=&#34;http://perldoc.perl.org/perlapi.html&#34;&gt;perlapi&lt;/a&gt; and &lt;a href=&#34;http://perldoc.perl.org/perlxs.html&#34;&gt;perlguts&lt;/a&gt;. There is also &lt;a href=&#34;http://perldoc.perl.org/perlxs.html&#34;&gt;perlxstut&lt;/a&gt; but I would skip that in favor of the above resources.&lt;/p&gt;

&lt;p&gt;Several times I&amp;rsquo;ve found XS macros used in Perl code that are not explained in any documentation (e.g. &lt;code&gt;dXSTARG&lt;/code&gt;). In those cases it pays to have a copy of the Perl &lt;a href=&#34;https://www.perl.org/get.html&#34;&gt;source code&lt;/a&gt; - just grep the source and you&amp;rsquo;ll find its definition with a comment (typically in &lt;code&gt;pp.h&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;a-note-on-the-benchmarks:4569416bc6792b95aa8a57ed35ded62b&#34;&gt;A note on the benchmarks&lt;/h3&gt;

&lt;p&gt;The benchmarks in this article were all run on my laptop, a Dell XPS 13 with 8GB RAM running Fedora 23. Different hardware will yield different results (Christian&amp;rsquo;s benchmark showed URI::Encode::XS to be 90x (!) faster than URI::Escape).&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode-XS/blob/master/bench&#34;&gt;script&lt;/a&gt; counts how many times each module can encode a string per second. But a string of a different length, or with a different number of reserved characters will yield a different benchmark. For example benchmarking an empty string shows URI::Encode::XS to be just 9x times faster on my laptop.&lt;/p&gt;

&lt;p&gt;The module versions were URI::Encode::XS v0.08 and URI::Escape v3.31. The Perl version was 5.22.&lt;/p&gt;

&lt;h3 id=&#34;thanks:4569416bc6792b95aa8a57ed35ded62b&#34;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;A big thank you to Christian Hansen and Jesse DuMond for your help with URI::Encode::XS. The module would not be half of what it is without your contributions.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

