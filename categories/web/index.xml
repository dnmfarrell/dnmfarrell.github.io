<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Web on Perl programming news, code and culture</title>
    <link>http://perltricks.com/categories/web/</link>
    <description>Recent content in Web on Perl programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 02 Feb 2016 13:41:18 +0000</lastBuildDate>
    <atom:link href="http://perltricks.com/categories/web/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Get an in-browser remote desktop with Mojolicious and noVNC</title>
      <link>http://perltricks.com/article/212/2016/2/2/Get-an-in-browser-remote-desktop-with-Mojolicious-and-noVNC/</link>
      <pubDate>Tue, 02 Feb 2016 13:41:18 +0000</pubDate>
      
      <guid>http://perltricks.com/article/212/2016/2/2/Get-an-in-browser-remote-desktop-with-Mojolicious-and-noVNC/</guid>
      <description>

&lt;p&gt;While SSH is a staple of remote system administration, sometimes only a GUI will do. Perhaps the remote system doesn&amp;rsquo;t have a terminal environment to connect to; perhaps the target application doesn&amp;rsquo;t present an adequate command line interface; perhaps there is an existing GUI session you need to interact with. There can be all kinds of reasons.&lt;/p&gt;

&lt;p&gt;For this purpose, a generic type of remote desktop service called VNC is commonly used. The servers are easy to install, start on seemingly all platforms and lots of hardware has a VNC server embedded for remote administration. Clients are similarly easy to use, but when building a management console in the web, wouldn&amp;rsquo;t it be nice to have the console view right in your browser?&lt;/p&gt;

&lt;p&gt;Luckily there is a pure JavaScript VNC client called &lt;a href=&#34;https://github.com/kanaka/noVNC&#34;&gt;noVNC&lt;/a&gt; noVNC listens for VNC traffic over WebSockets, which is convenient for browsers but isn&amp;rsquo;t supported by most VNC servers. To overcome this problem they provide a command-line application called &lt;a href=&#34;https://github.com/kanaka/websockify&#34;&gt;Websockify&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Websockify is a relay that connects to a TCP connection (the VNC server) and exposes the traffic as a WebSocket stream such that a browser client can listen on. While this does fix the problem it isn&amp;rsquo;t an elegant solution. Each VNC Server needs its own instance of Websockify requiring a separate port. Further you either need to leave these connected at all times in case of a web client or else spawn them on demand and clean them up later.&lt;/p&gt;

&lt;h2 id=&#34;mojolicious-to-the-rescue:df6114835a8ce31097aba2ba4c9f0a9f&#34;&gt;Mojolicious to the Rescue&lt;/h2&gt;

&lt;p&gt;Mojolicious has a built-in event-based &lt;a href=&#34;http://mojoliciou.us/perldoc/Mojo/IOLoop/Client&#34;&gt;TCP Client&lt;/a&gt; and native &lt;a href=&#34;http://mojolicious.org/perldoc/Mojolicious/Guides/Tutorial#WebSockets&#34;&gt;WebSocket&lt;/a&gt; handling. If you are already serving your site with Mojolicious, why not let it do the TCP/WebSocket relay work too? Even if you aren&amp;rsquo;t, the on-demand nature of the solution I&amp;rsquo;m going to show would be useful as a stand-alone app for this single purpose versus the websockify application.&lt;/p&gt;

&lt;p&gt;Here is a &lt;a href=&#34;http://mojolicio.us/perldoc/Mojolicious/Guides/Tutorial&#34;&gt;Mojolicious::Lite&lt;/a&gt; application which serves the noVNC client when you request a url like &lt;code&gt;/192.168.0.1&lt;/code&gt;. When the page loads, the client requests the WebSocket route at &lt;code&gt;/proxy?target=192.168.0.1&lt;/code&gt; which establishes the bridge. This example is bundled with my forthcoming wrapper module with a working name of &lt;a href=&#34;https://github.com/jberger/Mojo-Websockify/blob/master/ex/client.pl&#34;&gt;Mojo::Websockify&lt;/a&gt;. The code is remarkably simple:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Mojolicious::Lite;

use Mojo::IOLoop;

websocket &#39;/proxy&#39; =&amp;gt; sub {
  my $c = shift;
  $c-&amp;gt;render_later-&amp;gt;on(finish =&amp;gt; sub { warn &#39;websocket closing&#39; });

  my $tx = $c-&amp;gt;tx;
  $tx-&amp;gt;with_protocols(&#39;binary&#39;);

  my $host = $c-&amp;gt;param(&#39;target&#39;) || &#39;127.0.0.1&#39;;
  my $port = $host =~ s{:(\d+)$}{} ? $1 : 5901;

  Mojo::IOLoop-&amp;gt;client(address =&amp;gt; $host, port =&amp;gt; $port, sub {
    my ($loop, $err, $tcp) = @_;

    $tx-&amp;gt;finish(4500, &amp;quot;TCP connection error: $err&amp;quot;) if $err;
    $tcp-&amp;gt;on(error =&amp;gt; sub { $tx-&amp;gt;finish(4500, &amp;quot;TCP error: $_[1]&amp;quot;) });

    $tcp-&amp;gt;on(read =&amp;gt; sub {
      my ($tcp, $bytes) = @_;
      $tx-&amp;gt;send({binary =&amp;gt; $bytes});
    });

    $tx-&amp;gt;on(binary =&amp;gt; sub {
      my ($tx, $bytes) = @_;
      $tcp-&amp;gt;write($bytes);
    });

    $tx-&amp;gt;on(finish =&amp;gt; sub {
      $tcp-&amp;gt;close;
      undef $tcp;
      undef $tx;
    });
  });
};

get &#39;/*target&#39; =&amp;gt; sub {
  my $c = shift;
  my $target = $c-&amp;gt;stash(&#39;target&#39;);
  my $url = $c-&amp;gt;url_for(&#39;proxy&#39;)-&amp;gt;query(target =&amp;gt; $target);
  $url-&amp;gt;path-&amp;gt;leading_slash(0); # novnc assumes no leading slash :(
  $c-&amp;gt;render(
    vnc  =&amp;gt;
    base =&amp;gt; $c-&amp;gt;tx-&amp;gt;req-&amp;gt;url-&amp;gt;to_abs,
    path =&amp;gt; $url,
  );
};

app-&amp;gt;start;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;get&lt;/code&gt; route shown at the bottom and isn&amp;rsquo;t very exciting. It&amp;rsquo;s the frontend route that renders the noVNC client and tells it the WebSocket url.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;websocket&lt;/code&gt; route is the more interesting one, which I will explain in detail. After shifting off the controller, we tell the server not to attempt to render a template (&lt;code&gt;render_later&lt;/code&gt;), then subscribe to the finish handler. This is actually a hint to the server that we intend to initiate a WebSocket connection later. Typically this is done by either subscribing to one of the message events or else by sending data upon connection, but in this case we won&amp;rsquo;t do either until the TCP connection is established. Then after extracting the target host and port from the query argument we are ready to make the TCP connection.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mojolicious.org/perldoc/Mojo/IOLoop#client&#34;&gt;&lt;code&gt;Mojo::IOLoop-&amp;gt;client&lt;/code&gt;&lt;/a&gt; simply takes connection arguments and a callback for what to do once connected. We use this callback to establish our relay. The WebSocket protocol reserves all closing statuses below 4000 for internal use, so I&amp;rsquo;ve taken to using the standard HTTP statuses and prepending a 4 to them. Thus when setting up the TCP error handling, either on initially connecting or for subsequent errors, the status passed to the WebSocket &lt;code&gt;finish&lt;/code&gt; method is 4500.&lt;/p&gt;

&lt;p&gt;The relay itself is the next two method calls. First, when the TCP socket emits a &lt;code&gt;read&lt;/code&gt; event, we take its raw bytes and send them (as binary messages) to the WebSocket client. Then when the WebSocket emits a binary frame (i.e. when it receives a binary message) we write that back to the TCP connection. Finally when the Websocket is closed, we also close the TCP connection and cleanup our handlers.&lt;/p&gt;

&lt;p&gt;Simple, isn&amp;rsquo;t it?!&lt;/p&gt;

&lt;h2 id=&#34;additional-notes:df6114835a8ce31097aba2ba4c9f0a9f&#34;&gt;Additional Notes&lt;/h2&gt;

&lt;p&gt;There are a few things missing. First is that I haven&amp;rsquo;t addressed security in this example. If any part of the stream is publicly available you will want to encrypt the traffic and put the servers behind authentication. Another risk is the issue of &amp;ldquo;back pressure&amp;rdquo; where a stream starts sending floods of data.&lt;/p&gt;

&lt;p&gt;You may have noticed I skipped one line, which until a recent version of Chrome wasn&amp;rsquo;t necessary. When the WebSocket connection is first established it calls &lt;code&gt;with_protocols(&#39;binary&#39;)&lt;/code&gt;. Early versions of noVNC also supported sending the TCP traffic as base64 encoded text, since early implementations of WebSockets didn&amp;rsquo;t distinguish between text and binary frame types as the modern ones do. The WebSocket protocol allows the client to request an application-defined &amp;ldquo;sub-protocol&amp;rdquo; which noVNC used to request binary or base64, the latter of which has long since been deprecated and removed. The client still asks for the binary sub-protocol and recent versions of Chrome have started to refuse to connect if the server doesn&amp;rsquo;t indicate that it can handle this request.&lt;/p&gt;

&lt;h2 id=&#34;shouldn-t-this-be-on-cpan:df6114835a8ce31097aba2ba4c9f0a9f&#34;&gt;Shouldn&amp;rsquo;t This Be On CPAN?&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m hoping to wrap this TCP/WebSocket bridge logic up as a module called &lt;code&gt;Mojo::Websockify&lt;/code&gt; and include the noVNC client as an example. It turns out however, that the logic which is simple to show here is remarkably hard to package in a generic, extensible way. For example, you may want to check if the TCP service is already in use via some database-locking table, or to allow remote-takeover of sessions using a message broker between clients. I&amp;rsquo;ll probably just simplify things for the common case and build in some protection for the &amp;ldquo;back pressure&amp;rdquo; problem. In the meantime I hope you have enjoyed seeing how beautifully simple Mojolicious&amp;rsquo; WebSocket and TCP services are.&lt;/p&gt;

&lt;p&gt;Happy Perling!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Twitter as a datastore</title>
      <link>http://perltricks.com/article/210/2016/1/21/Twitter-as-a-datastore/</link>
      <pubDate>Thu, 21 Jan 2016 13:52:14 +0000</pubDate>
      
      <guid>http://perltricks.com/article/210/2016/1/21/Twitter-as-a-datastore/</guid>
      <description>&lt;p&gt;Why doesn&amp;rsquo;t anyone talk about Twitter as a data store? It&amp;rsquo;s a free account, they mostly have uptime, and you can easily control who can see the information. If you can do it in 140 characters (and &lt;a href=&#34;http://www.theverge.com/2015/8/12/9134175/twitter-direct-message-character-limit&#34;&gt;soon to be 10,000&lt;/a&gt;), it&amp;rsquo;s an easy way to store data.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/excellent_nums&#34;&gt;Tweets by @excellent_nums&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m doing this for my &lt;a href=&#34;http://www.excellentnums.com&#34;&gt;excellent numbers project&lt;/a&gt; that does quite a bit of computing to find numbers with a particular property. This isn&amp;rsquo;t the only way I&amp;rsquo;m storing the numbers, but I had the idea of tweeting them as soon as I found them in case every other method failed. If I accidentally deleted the output files (did that), truncated and overwrote files (did that), or somehow screwed it up in another way (did that), the numbers are still on Twitter.&lt;/p&gt;

&lt;p&gt;I had another compelling reason, though. I wanted to get an alert on my phone when my program found another excellent number. Unfortunately, I&amp;rsquo;ve hitched my wagon to the iPhone. There are all sorts of complicated ways for me to get an alert but I already use Twitter and get alerts for that. So, I can have a backup store and an alert system using stuff I already have installed. I can spend more time on the math and less time on installing and managing Redis (which is easy too and deserves an article here) then coming up with a way to send new entries to my phone.&lt;/p&gt;

&lt;p&gt;I wrote about my setup in nonspecific terms in &lt;a href=&#34;http://www.masteringperl.org/2015/12/ive-found-over-200-excellent-numbers/&#34;&gt;Mastering Perl&lt;/a&gt;. I didn&amp;rsquo;t show any code, although it&amp;rsquo;s all in &lt;a href=&#34;https://github.com/briandfoy/excellent_numbers&#34;&gt;the excellent_numbers GitHub repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before you start, you need some Twitter credentials to use their API through the &lt;a href=&#34;https://metacpan.org/pod/Net::Twitter&#34;&gt;Net::Twitter&lt;/a&gt; module. Start at &lt;a href=&#34;http://apps.twitter.com&#34;&gt;Twitter Application Management&lt;/a&gt; to get the four special strings you&amp;rsquo;ll need (&lt;a href=&#34;http://iag.me/socialmedia/how-to-create-a-twitter-app-in-8-easy-steps/&#34;&gt;&amp;ldquo;How to Register a Twitter App in 8 Easy Steps&amp;rdquo; has a good description of the steps&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;Consumer Key (API Key)&lt;/p&gt;

&lt;p&gt;Consumer Secret (API Secret)&lt;/p&gt;

&lt;p&gt;Access Token&lt;/p&gt;

&lt;p&gt;Access Token Secret&lt;/p&gt;

&lt;p&gt;The Net::Twitter module needs these strings to create its object. The module handles all of the OAuth details without me having to think about them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Net::Twitter;

my $nt = Net::Twitter-&amp;gt;new(
   traits   =&amp;gt; [qw/OAuth API::RESTv1_1/],
   map { $_ =&amp;gt; $ENV{&amp;quot;$_&amp;quot;} || die &amp;quot;ENV $_ not set&amp;quot; }
           qw(     
                consumer_secret
                consumer_key
                access_token
                access_token_secret
                )
   );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In my excellent number program, I wanted to be as simple as possible. I didn&amp;rsquo;t want to re-tweet numbers I already tweeted so I fetched everything I&amp;rsquo;ve tweeted so far and stored it in a hash. Twitter pages in groups of 200 tweets maximum, and this didn&amp;rsquo;t seem like it would be a problem a couple of months ago but I&amp;rsquo;m now up to over 350 of them.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s easy to fetch a bunch of statuses with the &lt;code&gt;user_timeline&lt;/code&gt; method. I need to tell it where to start (&lt;code&gt;min_id&lt;/code&gt; or &lt;code&gt;since_id&lt;/code&gt;). Twitter returns huge JSON structures with lots of information, but Net::Twitter turns that into a Perl data structure for me. I dump what they send and pull out the parts I want:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my %tweets;
STATUSES: while( 1 ) {
  state $min_id = 1;
  state $fetch_size = 200;

  my $max_key = $min_id == 1 ? &#39;since_id&#39; : &#39;max_id&#39;;

  my $statuses = $nt-&amp;gt;user_timeline({
          count       =&amp;gt; $fetch_size,
          screen_name =&amp;gt; &#39;excellent_nums&#39;,
          $max_key    =&amp;gt; $min_id,
          });     

  say { interactive } &amp;quot;Found &amp;quot; . @$statuses . &amp;quot; statuses&amp;quot;;
  $min_id = $statuses-&amp;gt;[-1]{id} - 1 if $min_id == 1;

  foreach my $status ( @$statuses ) {
          $min_id = $status-&amp;gt;{id} - 1 if $min_id &amp;gt; $status-&amp;gt;{id};
          my( $number ) = $status-&amp;gt;{text} =~ m/(\d+)/;
          warn &amp;quot;[$number] has more than one tweet!\n&amp;quot; if exists $tweets{$number};
          $tweets{$number} = undef;
          unless( is_excellent( $number ) ) {
                  warn &amp;quot;Tweet for [$number] is an unexcellent error\n&amp;quot;;
                  }       
          }       

  last if @$statuses &amp;lt; $fetch_size; # must be last page
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This part is complicated for another reason. At the start of the project I was generating the excellent numbers sequentially. When that&amp;rsquo;s the case I only needed to look at the previous tweet to see if it was less than the number I just discovered. When I got to the big numbers, I went wide and worked on different parts of the range in parallel and sometimes on several computers simultaneously. I started to discover the numbers out of order and tweet them out of order. Hence, the paging. I could store the list of tweeted numbers locally, but that&amp;rsquo;s a hassle to manage too since that can be out of sync. I still might do that when this method runs out of steam. I&amp;rsquo;m not likely to get far beyond 500 numbers though.&lt;/p&gt;

&lt;p&gt;Notice that I also &lt;code&gt;warn&lt;/code&gt; if I run into a tweet with a number that I think is a duplicate:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;warn &amp;quot;[$number] has more than one tweet!\n&amp;quot; if exists $tweets{$number};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this was a bigger problem (and it&amp;rsquo;s not anymore), I could use the &lt;code&gt;destroy_status&lt;/code&gt; method to automatically get rid of it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$nt-&amp;gt;destroy_status( $status-&amp;gt;{id} ) if exists $tweets{$number};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I decided not to delete automatically from the program. It&amp;rsquo;s not a problem to have duplicates. It&amp;rsquo;s a bit messy, but it&amp;rsquo;s more messy to delete stuff I want to keep and to retweet it. That risk makes it not worth it for me. I don&amp;rsquo;t want another possible automated mess to clean up.&lt;/p&gt;

&lt;p&gt;Now I know everything I&amp;rsquo;ve tweeted previously and I&amp;rsquo;ve put them in &lt;code&gt;%tweets&lt;/code&gt;. The next part is to tweet what I&amp;rsquo;ve found and haven&amp;rsquo;t stored yet. I also store that in a local file (but remember I want the alerts and the backup!) that I used to populate &lt;code&gt;%numbers&lt;/code&gt;. I skip the numbers I already tweeted and use &lt;code&gt;update&lt;/code&gt; to make the new tweets. Storing new numbers is easy, and when I do it I want to tweet the new numbers in ascending order:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;NUMBER: foreach my $number ( sort { $a &amp;lt;=&amp;gt; $b } keys %numbers ) {
  next NUMBER if exists $tweets{$number};

  $nt-&amp;gt;update( &amp;quot;$number is excellent&amp;quot; );
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This used to be part of the program that found the excellent numbers, but I switched to C for a huge performance bump. I still wanted to tweet from Perl, which is easy. Perl&amp;rsquo;s become the glue holding together lots of different things.&lt;/p&gt;

&lt;p&gt;Once I can read from, post to, and delete from twitter, other applications (or even real people) can follow it. It can be public or private. It&amp;rsquo;s not sophisticated. It&amp;rsquo;s uptime isn&amp;rsquo;t going to win any awards. But it&amp;rsquo;s free and easy for my small task.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to send verification emails using Mojolicious</title>
      <link>http://perltricks.com/article/193/2015/9/18/How-to-send-verification-emails-using-Mojolicious/</link>
      <pubDate>Fri, 18 Sep 2015 11:46:46 +0000</pubDate>
      
      <guid>http://perltricks.com/article/193/2015/9/18/How-to-send-verification-emails-using-Mojolicious/</guid>
      <description>

&lt;p&gt;Everyone has signed up for a website which confirms your email address by sending you a verification email. This is a simple process: if you can respond to this email, you must have access to the email address. Yet for its simplicity, writing such a system might not seem as easy.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at an example. I&amp;rsquo;m going to use &lt;a href=&#34;http://mojolicio.us&#34;&gt;Mojolicious&lt;/a&gt; since it is the web framework that I prefer (and contribute to) but also since its ecosystem is suited to this task. If you&amp;rsquo;d like to follow along as I go, check out the finished &lt;a href=&#34;https://gist.github.com/jberger/91a853ee223737c1a1d1&#34;&gt;script&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;user-storage:a6227821bd9908f56bba33c97dd09154&#34;&gt;User Storage&lt;/h3&gt;

&lt;p&gt;The example application is going to need a persistent mechanism to store user information. A tool I reach for in examples and prototyping is &lt;a href=&#34;https://metacpan.org/pod/DBM::Deep&#34;&gt;DBM::Deep&lt;/a&gt;. It is a file-backed system for storing Perl data structures. To use it, simply create an instance (or &lt;code&gt;tie&lt;/code&gt; one) and use it as a hash reference (array references are possible too); any changes will be saved automagically!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $db = DBM::Deep-&amp;gt;new(&#39;filename.db&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ll store this object in a helper, named &lt;code&gt;users&lt;/code&gt;. In Mojolicious, a helper is a subroutine that can be called as a method on a controller instance or the app itself, or called as a function in a template. They are often used for linkages between application and business or model logic, though here it is providing database access. When the time comes to need access to user data, say from a controller instance &lt;code&gt;$c&lt;/code&gt;, it is as simple as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $user = $c-&amp;gt;users-&amp;gt;{$username};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And likewise to create a user, simply assign to it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$c-&amp;gt;users-&amp;gt;{$username} = {
  email     =&amp;gt; $email,
  password  =&amp;gt; $c-&amp;gt;bcrypt($password),
  confirmed =&amp;gt; 0,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More fields would be stored in a more complete app but this is all that is needed for this example.&lt;/p&gt;

&lt;h3 id=&#34;password-encryption:a6227821bd9908f56bba33c97dd09154&#34;&gt;Password encryption&lt;/h3&gt;

&lt;p&gt;I use an encryption called &lt;code&gt;bcrypt&lt;/code&gt; to store the password. &lt;a href=&#34;https://metacpan.org/pod/Mojolicious::Plugin::Bcrypt&#34;&gt;Mojolicious::Plugin::Bcrypt&lt;/a&gt; is a handy plugin to use Bcrypt encryption with Mojolicious; you load it by simply writing &lt;code&gt;plugin &#39;Bcrypt&#39;;&lt;/code&gt;. This plugin provides two helpers, &lt;code&gt;bcrypt&lt;/code&gt; for encryption and &lt;code&gt;bcrypt_validate&lt;/code&gt; for checking that another value is valid.&lt;/p&gt;

&lt;p&gt;Bcrypt is one of many hashing algorithms with properties that are useful for security. There is no &lt;code&gt;decrypt&lt;/code&gt; function, since this is a one-way algorithm. When validating the password, the best you can know is that if some future input hashes to the same result then it must have been the original password. Storing passwords in this way is good because if a hacker gets database access, they don&amp;rsquo;t get the passwords, just the hashes; they can&amp;rsquo;t be leaked because you simply don&amp;rsquo;t have them.&lt;/p&gt;

&lt;h3 id=&#34;sending-an-email:a6227821bd9908f56bba33c97dd09154&#34;&gt;Sending an email&lt;/h3&gt;

&lt;p&gt;CPAN is replete with modules which can send email. For this example I employ &lt;a href=&#34;https://metacpan.org/pod/Email::Sender&#34;&gt;Email::Sender&lt;/a&gt;, which is the current recommended module (for &lt;a href=&#34;http://shadow.cat/blog/matt-s-trout/mstpan-15/&#34;&gt;example&lt;/a&gt;). Written by our reigning Perl Pumpking Ricardo Signes, this module makes it very easy to send email.&lt;/p&gt;

&lt;p&gt;The app declares a helper to send an email, cleverly called &lt;code&gt;send_email&lt;/code&gt; which takes a target email address, a subject, and a body.&lt;/p&gt;

&lt;p&gt;A nice feature of Email::Sender is that you can specify &lt;a href=&#34;https://metacpan.org/pod/Email::Sender::Manual::QuickStart#specifying-transport-in-the-environment&#34;&gt;transport via the environment&lt;/a&gt;. For prototyping purposes, by setting an environment variable, the email is &amp;ldquo;sent&amp;rdquo; to the terminal. Meanwhile, the Mojolicious &lt;a href=&#34;http://mojolicio.us/perldoc/Mojolicious/Command/eval&#34;&gt;eval&lt;/a&gt; command is a handy way to perform one-line scripts with your app. If I combine these features together, I can see what the resulting email would look like with a one liner:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ EMAIL_SENDER_TRANSPORT=Print ./app.pl eval &#39;app-&amp;gt;send_email(q[me@spam.org], &amp;quot;Care for some SPAM?&amp;quot;, &amp;quot;Well how about it?&amp;quot;)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-email-body:a6227821bd9908f56bba33c97dd09154&#34;&gt;The email body&lt;/h3&gt;

&lt;p&gt;Now that the app can send an email, what should it send? Remember that I would like to send an email with a hyperlink that the user can click to confirm their registration. The hyperlink URL needs to be able to identify the transaction, but since it is being sent in clear text it is important to know that the contents haven&amp;rsquo;t been tampered with. A &lt;a href=&#34;http://jwt.io/&#34;&gt;JSON Web Token&lt;/a&gt;, or JWT, lets you store a data structure as a url-safe string and sign it so that you can be sure that it isn&amp;rsquo;t altered.&lt;/p&gt;

&lt;p&gt;Since the user won&amp;rsquo;t be logged in, I need some other way to know which username to confirm! In this example the JWT payload is only going to contain the username, sent on a round trip to the client&amp;rsquo;s email.&lt;/p&gt;

&lt;p&gt;If instead the app were sending a password reset token I would also want to include a timeout on the JWT to prevent replay attacks. For a simple confirmation though that is probably not necessary.&lt;/p&gt;

&lt;p&gt;I create a helper which initializes an instance of &lt;a href=&#34;https://metacpan.org/pod/Mojo::JWT&#34;&gt;Mojo::JWT&lt;/a&gt; and uses the application&amp;rsquo;s primary &lt;a href=&#34;https://metacpan.org/pod/Mojolicious#secrets&#34;&gt;secret&lt;/a&gt; as its secret. The JWT can also use some other secret, but this is convenient. Note that the example app uses the default set of secrets, but yours should change it to something only you know.&lt;/p&gt;

&lt;p&gt;To create the confirmation URL, the app first sets the claims and encodes to a JWT encoded string containing the data structure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $jwt = $c-&amp;gt;jwt-&amp;gt;claims({username =&amp;gt; $username})-&amp;gt;encode;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it generates a URL to the &amp;ldquo;confirm&amp;rdquo; route, makes it absolute, and appends the query/value pair to the end:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $url = $c-&amp;gt;url_for(&#39;confirm&#39;)-&amp;gt;to_abs-&amp;gt;query(jwt =&amp;gt; $jwt);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Later when the URL is clicked, the app can retrieve the username from the JWT encoded query parameter like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $username = $c-&amp;gt;jwt-&amp;gt;decode($c-&amp;gt;param(&#39;jwt&#39;))-&amp;gt;{username};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that if the JWT (contained in the query parameter) doesn&amp;rsquo;t pass validation on decoding, an exception is thrown; this way you know that if the code succeeds the JWT hasn&amp;rsquo;t been tampered with.&lt;/p&gt;

&lt;p&gt;From there it is a simple matter to mark the user&amp;rsquo;s account as confirmed.&lt;/p&gt;

&lt;h3 id=&#34;the-job-queue:a6227821bd9908f56bba33c97dd09154&#34;&gt;The job queue&lt;/h3&gt;

&lt;p&gt;Many tasks that happen as a result of a web request can be quite slow. Sending email is often a slow process and I don&amp;rsquo;t want to slow down the server in order to add email functionality. Mojolicious employs a non-blocking ioloop internally for performance and one thing you never want to do is block the loop for long periods of time.&lt;/p&gt;

&lt;p&gt;A job queue is a system by which you can push the actual work of doing slow work onto another process. Typically a job queue functions by inserting a record into a database indicating which task is to be done and parameters to be passed to it. The job worker then knows how to perform that task and watches the database until a job needs doing.&lt;/p&gt;

&lt;p&gt;Mojolicious has a job queue spinoff project, named &lt;a href=&#34;https://metacpan.org/pod/Minion&#34;&gt;Minion&lt;/a&gt;. It is the perfect tool for sending email from a job worker to keep the site responsive. Minion ships with a Postgres backend but for this example I will be using the SQLite backend from CPAN. &lt;em&gt;(N.B an earlier version of this article used a file backend that has since been removed).&lt;/em&gt; The task is declared as a subroutine reference to &lt;code&gt;add_task&lt;/code&gt; and later jobs can be created by &lt;code&gt;enqueue&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The app declares a task, called &lt;code&gt;email_task&lt;/code&gt; which is a wrapper for the &lt;code&gt;send_email&lt;/code&gt; helper. It also declare a helper named &lt;code&gt;email&lt;/code&gt;, a nicely Huffmanized name, which enqueues the job (and takes the same arguments). (I&amp;rsquo;ve called the task &lt;code&gt;email_task&lt;/code&gt; to make it clear where that name is used; it could as easily simply have been called &lt;code&gt;email&lt;/code&gt;, but I didn&amp;rsquo;t want the name to be confused with the helper).&lt;/p&gt;

&lt;p&gt;This helper then is all that is needed to send an email via a job worker, well that and a worker. While prototyping, it is handy to start a worker in another terminal by running:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ EMAIL_SENDER_TRANSPORT=Print ./app.pl minion worker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again by setting the transport to &lt;code&gt;Print&lt;/code&gt;, the result will be output in the terminal. The progress of the job can then be tracked via the &lt;code&gt;minion&lt;/code&gt; command as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ ./myapp.pl minion job
$ ./myapp.pl minion job &amp;lt;&amp;lt;id&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;putting-it-all-together:a6227821bd9908f56bba33c97dd09154&#34;&gt;Putting it all together&lt;/h3&gt;

&lt;p&gt;The rest of the web application is a fairly standard Mojolicious app. One thing that I employ is a helper that redirects to the landing (index) page and optionally accepts a message to be displayed after redirect. This message is called a &amp;ldquo;flash&amp;rdquo; message and is stored in the session cookie, valid only on the next request. Using this helper I can easily start the sign-in/sign-up cycle again and tell the user what happened, good or bad. Because setters in Mojolicious are chainable, the helper is simply:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;helper to_index =&amp;gt; sub { shift-&amp;gt;flash(message =&amp;gt; shift)-&amp;gt;redirect_to(&#39;index&#39;) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the template, if the flash message is defined from the previous request, it is used otherwise a default is presented&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;lt;p&amp;gt;&amp;lt;%= flash(&#39;message&#39;) || &#39;Sign in or sign up!&#39; %&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then if the username is already taken, for example, I can stop processing immediately by:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;return $c-&amp;gt;to_index(&amp;quot;Username $username is taken&amp;quot;) if $c-&amp;gt;users-&amp;gt;{$username};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that you know how the pieces work, check out the final &lt;a href=&#34;https://gist.github.com/jberger/91a853ee223737c1a1d1&#34;&gt;script&lt;/a&gt;, or have a look below. Happy Perling!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Mojolicious::Lite;

use DBM::Deep;
use Mojo::JWT;

plugin &#39;Bcrypt&#39;;
plugin &#39;Minion&#39; =&amp;gt; {SQLite =&amp;gt; &#39;minion.db&#39;};

helper users =&amp;gt; sub { state $db = DBM::Deep-&amp;gt;new(&#39;users.db&#39;) };

helper send_email =&amp;gt; sub {
  my ($c, $address, $subject, $body) = @_;

  require Email::Simple;
  require Email::Sender::Simple;

  my $email = Email::Simple-&amp;gt;create(
    header =&amp;gt; [
      To      =&amp;gt; $address,
      From    =&amp;gt; &#39;me@nobody.com&#39;,
      Subject =&amp;gt; $subject,
    ],
    body =&amp;gt; $body,
  );
  Email::Sender::Simple-&amp;gt;send($email);
};

helper jwt =&amp;gt; sub { Mojo::JWT-&amp;gt;new(secret =&amp;gt; shift-&amp;gt;app-&amp;gt;secrets-&amp;gt;[0] || die) };

app-&amp;gt;minion-&amp;gt;add_task(email_task =&amp;gt; sub { shift-&amp;gt;app-&amp;gt;send_email(@_) });

helper email =&amp;gt; sub { shift-&amp;gt;minion-&amp;gt;enqueue(email_task =&amp;gt; [@_]) };

helper to_index =&amp;gt; sub { shift-&amp;gt;flash(message =&amp;gt; shift)-&amp;gt;redirect_to(&#39;index&#39;) };

any &#39;/&#39; =&amp;gt; sub {
  my $c = shift;
  $c-&amp;gt;render(&#39;logged_in&#39;) if $c-&amp;gt;session(&#39;username&#39;);
} =&amp;gt; &#39;index&#39;;

any &#39;/logout&#39; =&amp;gt; sub { shift-&amp;gt;session(expires =&amp;gt; 1)-&amp;gt;to_index };

post &#39;/sign_in&#39; =&amp;gt; sub {
  my $c = shift;
  my $username = $c-&amp;gt;param(&#39;username&#39;);
  return $c-&amp;gt;to_index(&amp;quot;Username $username not found&amp;quot;)
    unless my $user = $c-&amp;gt;users-&amp;gt;{$username};

  return $c-&amp;gt;to_index(&amp;quot;Username $username has not been confirmed&amp;quot;)
    unless $user-&amp;gt;{confirmed};

  return $c-&amp;gt;to_index(&#39;Password not correct&#39;)
    unless $c-&amp;gt;bcrypt_validate($c-&amp;gt;param(&#39;password&#39;) || &#39;&#39;, $user-&amp;gt;{password});

  $c-&amp;gt;session(username =&amp;gt; $username)-&amp;gt;to_index;
};

post &#39;/sign_up&#39; =&amp;gt; sub {
  my $c = shift;

  my $username = $c-&amp;gt;param(&#39;username&#39;);
  return $c-&amp;gt;to_index(&amp;quot;Username $username is taken&amp;quot;)
    if $c-&amp;gt;users-&amp;gt;{$username};

  return $c-&amp;gt;to_index(&#39;Password cannot be blank&#39;)
    unless my $password = $c-&amp;gt;param(&#39;password&#39;);

  return $c-&amp;gt;to_index(&#39;Email cannot be blank&#39;)
    unless my $email = $c-&amp;gt;param(&#39;email&#39;);

  $c-&amp;gt;users-&amp;gt;{$username} = {
    email     =&amp;gt; $email,
    password  =&amp;gt; $c-&amp;gt;bcrypt($password),
    confirmed =&amp;gt; 0,
  };
  my $jwt = $c-&amp;gt;jwt-&amp;gt;claims({username =&amp;gt; $username})-&amp;gt;encode;
  my $url = $c-&amp;gt;url_for(&#39;confirm&#39;)-&amp;gt;to_abs-&amp;gt;query(jwt =&amp;gt; $jwt);
  $c-&amp;gt;email($email, &#39;Confirm registration&#39;, &amp;quot;Please visit $url to confirm&amp;quot;);
  $c-&amp;gt;to_index(&#39;registration complete, please confirm via email&#39;);
};

get &#39;/confirm&#39; =&amp;gt; sub {
  my $c = shift;
  my $username = $c-&amp;gt;jwt-&amp;gt;decode($c-&amp;gt;param(&#39;jwt&#39;))-&amp;gt;{username};
  $c-&amp;gt;users-&amp;gt;{$username}{confirmed} = 1;
  $c-&amp;gt;to_index(&#39;registration confirmed, please log in&#39;);
};

app-&amp;gt;start;

__DATA__

@@ index.html.ep

&amp;lt;p&amp;gt;Hello Guest!&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;%= flash(&#39;message&#39;) || &#39;Sign in or sign up!&#39; %&amp;gt;&amp;lt;/p&amp;gt;

%= form_for sign_in =&amp;gt; begin
  %= label_for username =&amp;gt; &#39;Username&#39;
  %= text_field &#39;username&#39;

  %= label_for password =&amp;gt; &#39;Password&#39;
  %= password_field &#39;password&#39;

  %= label_for email =&amp;gt; &#39;Email&#39;
  %= email_field &#39;email&#39;, placeholder =&amp;gt; &#39;sign up only&#39;

  &amp;lt;br&amp;gt;
  %= submit_button &#39;Sign In&#39;
  %= submit_button &#39;Sign Up&#39;, formaction =&amp;gt; url_for(&#39;sign_up&#39;)
% end

@@ logged_in.html.ep

&amp;lt;p&amp;gt;Welcome back &amp;lt;%= session &#39;username&#39; %&amp;gt;!&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;&amp;lt;%= link_to &#39;Log out&#39; =&amp;gt; &#39;logout&#39; %&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Cache::Reddit or: how to use social media as a temporary data store</title>
      <link>http://perltricks.com/article/171/2015/5/4/Cache--Reddit-or--how-to-use-social-media-as-a-temporary-data-store/</link>
      <pubDate>Mon, 04 May 2015 12:28:31 +0000</pubDate>
      
      <guid>http://perltricks.com/article/171/2015/5/4/Cache--Reddit-or--how-to-use-social-media-as-a-temporary-data-store/</guid>
      <description>

&lt;p&gt;Sometimes crazy ideas are brilliant, but most of the time they are just crazy. I recently uploaded a new module to CPAN: &lt;a href=&#34;https://metacpan.org/pod/Cache::Reddit&#34;&gt;Cache::Reddit&lt;/a&gt;. It&amp;rsquo;s a caching module with a twist: it saves cached data as text posts on Reddit. Is that a good idea? Probably not, it&amp;rsquo;s definitely crazy.&lt;/p&gt;

&lt;h3 id=&#34;setup:915623acbd42e6947b356ad2ec9d95c4&#34;&gt;Setup&lt;/h3&gt;

&lt;p&gt;You probably don&amp;rsquo;t want to do this, but if you were considering using the module, here&amp;rsquo;s how. First you&amp;rsquo;ll need a Reddit account with enough karma to use the API (usually handful of upvoted links and comments is enough). Second you should create your own &lt;a href=&#34;http://www.reddit.com/subreddits/create/&#34;&gt;subreddit&lt;/a&gt; to post to. Install &lt;a href=&#34;https://metacpan.org/pod/Cache::Reddit&#34;&gt;Cache::Reddit&lt;/a&gt; using the command line clients cpan or cpanm&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpan Cache::Reddit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpanm Cache::Reddit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally set the environment variables: &lt;code&gt;reddit_username&lt;/code&gt;, &lt;code&gt;reddit_password&lt;/code&gt;, and &lt;code&gt;reddit_subreddit&lt;/code&gt; (the name of the subreddit that data will be posted to). On Linux / OSX you can do this at the terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ export reddit_username=somename
$ export reddit_password=itsasecret
$ export reddit_subreddit=mycache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To set environment variables on Windows 8, these &lt;a href=&#34;http://winaero.com/blog/how-to-edit-environment-variables-quickly-in-windows-8-1-and-windows-8/&#34;&gt;steps&lt;/a&gt; might work.&lt;/p&gt;

&lt;h3 id=&#34;using-cache-reddit:915623acbd42e6947b356ad2ec9d95c4&#34;&gt;Using Cache::Reddit&lt;/h3&gt;

&lt;p&gt;The module exports the typical caching functions you&amp;rsquo;d expect: &lt;code&gt;set&lt;/code&gt; for saving data, &lt;code&gt;get&lt;/code&gt; for retrieval and &lt;code&gt;remove&lt;/code&gt; for removal. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Cache::Reddit; #exports get, set, remove

my $monthly_revenues = { jan =&amp;gt; 25000, feb =&amp;gt; 23500, mar =&amp;gt; 31000, apr =&amp;gt; 15000 };
my $key = set($monthly_revenues); # serialize and save on reddit
...
my $revenue_data = get($key);
remove($key);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;limitations:915623acbd42e6947b356ad2ec9d95c4&#34;&gt;Limitations&lt;/h3&gt;

&lt;p&gt;Although the data is stored in a failsafe, redundant, backed-up environment in the cloud, frequent users of Reddit will appreciate that the service is likely to unavailable for a few seconds multiple times a day.&lt;/p&gt;

&lt;p&gt;Retrieval from the cache using &lt;code&gt;get&lt;/code&gt; doesn&amp;rsquo;t use a hash lookup; instead Cache::Reddit iterates through all available posts on the subreddit until it finds a match. This yields 0(n) performance, which means that the &lt;code&gt;get&lt;/code&gt; function will get slower the more items are cached. This is not likely to be a performance bottleneck though, as typically a subreddit only holds 1,000 links before they are lost to the ether.&lt;/p&gt;

&lt;p&gt;The data is serialized and deserialized using &lt;a href=&#34;https://metacpan.org/pod/Storable&#34;&gt;Storable&lt;/a&gt;, which may open pose a security risk if the cached data is edited by a mod. Up to 40,000 characters of data can be stored at one time. Unless the subreddit permits both links and text posts, in which case the limit is 10,000 characters. But Cache::Reddit does boast 100% test coverage.&lt;/p&gt;

&lt;h3 id=&#34;looking-forwards:915623acbd42e6947b356ad2ec9d95c4&#34;&gt;Looking forwards&lt;/h3&gt;

&lt;p&gt;In the future I&amp;rsquo;d like to take advantage of Reddit&amp;rsquo;s voting system to implement a crude &lt;a href=&#34;https://en.wikipedia.org/wiki/Least_Recently_Used#LRU&#34;&gt;LRU&lt;/a&gt; cache. Comments could prove to be a powerful version control system. Patches welcome, the source code is on Instagram.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build a Twitter bot with Perl</title>
      <link>http://perltricks.com/article/154/2015/2/23/Build-a-Twitter-bot-with-Perl/</link>
      <pubDate>Mon, 23 Feb 2015 14:12:06 +0000</pubDate>
      
      <guid>http://perltricks.com/article/154/2015/2/23/Build-a-Twitter-bot-with-Perl/</guid>
      <description>

&lt;p&gt;Following on from last week&amp;rsquo;s Reddit bot &lt;a href=&#34;http://perltricks.com/article/151/2015/2/9/Build-a-Reddit-bot-with-Perl&#34;&gt;article&lt;/a&gt;, let&amp;rsquo;s look at how to build a Twitter bot using Perl. As you&amp;rsquo;d expect, Perl makes it easy to do, but before we get to the code, let&amp;rsquo;s talk about advantages.&lt;/p&gt;

&lt;p&gt;Adding tweet automation to an existing app can bring several benefits. Firstly it&amp;rsquo;s a time saver, allowing you to focus on other higher-value activities. Automation provides protection from manual transcription errors like misspelled words and broken urls. Automation also means it&amp;rsquo;s cheaper to increase your tweet volume and all else being equal, a higher tweet volume will lead to more Twitter followers. Sound good? Excellent, let&amp;rsquo;s get to the code then!&lt;/p&gt;

&lt;h3 id=&#34;writing-tweets:12c8fd35ec6bfe5464697c6b32eba8bb&#34;&gt;Writing tweets&lt;/h3&gt;

&lt;p&gt;The core code for writing tweets is very simple. I&amp;rsquo;m using the &lt;a href=&#34;https://metacpan.org/pod/Net::Twitter::Lite&#34;&gt;Net::Twitter::Lite&lt;/a&gt; distribution, which supports the latest version of the Twitter &lt;a href=&#34;https://dev.twitter.com/rest/public&#34;&gt;API&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use Net::Twitter::Lite::WithAPIv1_1;

sub tweet
{
  my ($text) = @_;

  my $twitter = Net::Twitter::Lite::WithAPIv1_1-&amp;gt;new(
    access_token_secret =&amp;gt; $ENV{TWITTER_ACCESS_SECRET},
    consumer_secret     =&amp;gt; $ENV{TWITTER_CONSUMER_SECRET},
    access_token        =&amp;gt; $ENV{TWITTER_ACCESS_TOKEN},
    consumer_key        =&amp;gt; $ENV{TWITTER_CONSUMER_KEY},
    user_agent          =&amp;gt; &#39;TwitterBotExample&#39;,
    ssl =&amp;gt; 1,
  );
  $twitter-&amp;gt;update($text);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code imports &lt;code&gt;Net::Twitter::Lite::WithAPIv1_1&lt;/code&gt; to use the new Twitter API. The subroutine &lt;code&gt;tweet&lt;/code&gt; takes some text as an argument. It then creates a new &lt;code&gt;Net::Twitter::Lite::WithAPIv1_1&lt;/code&gt; object, using environment vars as credentials. If you don&amp;rsquo;t have these credentials already, it&amp;rsquo;s free to register an application for your own Twitter account and &lt;a href=&#34;https://dev.twitter.com/oauth/overview/application-owner-access-tokens&#34;&gt;generate the tokens&lt;/a&gt;. Finally the subroutine calls the &lt;code&gt;update&lt;/code&gt; method to tweet the text.&lt;/p&gt;

&lt;p&gt;Now I can send one tweet by adding this line to my code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;tweet(&amp;quot;This is a computer speaking!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;safety-first:12c8fd35ec6bfe5464697c6b32eba8bb&#34;&gt;Safety first&lt;/h3&gt;

&lt;p&gt;So far so good huh? However this code isn&amp;rsquo;t very safe. What if &lt;code&gt;$text&lt;/code&gt; is not provided as an argument, or our environment variables are not declared, or the call to Twitter fails? I&amp;rsquo;ll add some checks to handle these scenarios:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use Net::Twitter::Lite::WithAPIv1_1;
use Try::Tiny;

sub tweet
{
  my ($text) = @_;

  die &#39;tweet requires text as an argument&#39; unless $text;

  unless ($ENV{TWITTER_CONSUMER_KEY}
          &amp;amp;&amp;amp; $ENV{TWITTER_CONSUMER_SECRET}
          &amp;amp;&amp;amp; $ENV{TWITTER_ACCESS_TOKEN}
          &amp;amp;&amp;amp; $ENV{TWITTER_ACCESS_SECRET})
  {
    die &#39;Required Twitter Env vars are not all defined&#39;;
  }

  try
  {
    my $twitter = Net::Twitter::Lite::WithAPIv1_1-&amp;gt;new(
      access_token_secret =&amp;gt; $ENV{TWITTER_ACCESS_SECRET},
      consumer_secret     =&amp;gt; $ENV{TWITTER_CONSUMER_SECRET},
      access_token        =&amp;gt; $ENV{TWITTER_ACCESS_TOKEN},
      consumer_key        =&amp;gt; $ENV{TWITTER_CONSUMER_KEY},
      user_agent          =&amp;gt; &#39;TwitterBotExample&#39;,
      ssl =&amp;gt; 1,
    );
    $twitter-&amp;gt;update($text);
  }
  catch
  {
    die join(&#39; &#39;, &amp;quot;Error tweeting $text&amp;quot;,
                   $_-&amp;gt;code, $_-&amp;gt;message, $_-&amp;gt;error);
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code is largely the same as before, except now it checks for the required variables before processing. The code also imports &lt;a href=&#34;https://metacpan.org/pod/Try::Tiny&#34;&gt;Try::Tiny&lt;/a&gt; as I added a try/catch block around the twitter code. The catch block will activate if the Twitter interaction throws an exception. Because Net::Twitter::Lite throws structured exceptions, the catch block builds an exception string by extracting information from the structured exception, then calls &lt;code&gt;die&lt;/code&gt; itself.&lt;/p&gt;

&lt;p&gt;You might be wondering if it&amp;rsquo;s necessary to call &lt;code&gt;die&lt;/code&gt; at all. Can&amp;rsquo;t we just return &lt;code&gt;undef&lt;/code&gt; instead and keep our code running? The advantage of calling &lt;code&gt;die&lt;/code&gt; is that the caller of the &lt;code&gt;tweet&lt;/code&gt; subroutine is better placed to decide how to handle the issue, and so we defer that decision to them. If the calling code doesn&amp;rsquo;t handle &lt;code&gt;die&lt;/code&gt; correctly, we know the program will exit. But if we returned &lt;code&gt;undef&lt;/code&gt;, we would have no such assurances. This doesn&amp;rsquo;t mean however that the code &lt;em&gt;has&lt;/em&gt; to exit. Let&amp;rsquo;s assume I had hundreds of tweets to send out, maybe I just want to log the error somewhere and keep going:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;foreach my $text (@tweet_texts)
{
  try
  {
    tweet($text);
  }
  catch
  {
    log_error($_);
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I was printing a sequence of tweets, where ordering is important, I could still log the error but then call &lt;code&gt;die&lt;/code&gt; to exit the program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;foreach my $text (@sequence_of_texts)
{
  try
  {
    tweet($text);
  }
  catch
  {
    log_error($_);
    die $_; # exit the program
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;better-text-handling:12c8fd35ec6bfe5464697c6b32eba8bb&#34;&gt;Better text handling&lt;/h3&gt;

&lt;p&gt;So now the code is safer, how else can it be improved? One famous restriction is that a tweet cannot be longer than 140 characters. Right now if the &lt;code&gt;tweet()&lt;/code&gt; subroutine received a text string longer than 140 characters, the Twitter API would reject it, raise and exception and the code would die. I think we can do better than that.&lt;/p&gt;

&lt;p&gt;When I think about the contents of tweets that I send, I&amp;rsquo;m usually tweeting links to articles about Perl. Invariably they will include some text, a url and a hashtag. It&amp;rsquo;s useful to break these out into separate arguments to &lt;code&gt;tweet()&lt;/code&gt; because to make everything fit, you could truncate the text, but you wouldn&amp;rsquo;t want to truncate a url or hashtag as it might change the meaning and/or break the url.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use Net::Twitter::Lite::WithAPIv1_1;
use Try::Tiny;

sub tweet
{
  my ($text, $url, $hashtag) = @_;

  unless ($text &amp;amp;&amp;amp; $url &amp;amp;&amp;amp; $hashtag)
  {
    die &#39;tweet requires text, url and hashtag arguments&#39;;
  }

  unless ($ENV{TWITTER_CONSUMER_KEY}
          &amp;amp;&amp;amp; $ENV{TWITTER_CONSUMER_SECRET}
          &amp;amp;&amp;amp; $ENV{TWITTER_ACCESS_TOKEN}
          &amp;amp;&amp;amp; $ENV{TWITTER_ACCESS_SECRET})
  {
    die &#39;Required Twitter Env vars are not all defined&#39;;
  }

  # build tweet, max 140 chars
  my $tweet;
  
  if (length(&amp;quot;$text $hashtag&amp;quot;) &amp;lt; 118)
  {
    $tweet = &amp;quot;$text $url $hashtag&amp;quot;;
  }
  elsif (length($text) &amp;lt; 118)
  {
    $tweet = &amp;quot;$text $url&amp;quot;;
  }
  else # shorten text, drop the hashtag
  {
    $tweet = substr($text, 0, 113) . &amp;quot;... &amp;quot; . $url;
  }

  try
  {
    my $twitter = Net::Twitter::Lite::WithAPIv1_1-&amp;gt;new(
      access_token_secret =&amp;gt; $ENV{TWITTER_ACCESS_SECRET},
      consumer_secret     =&amp;gt; $ENV{TWITTER_CONSUMER_SECRET},
      access_token        =&amp;gt; $ENV{TWITTER_ACCESS_TOKEN},
      consumer_key        =&amp;gt; $ENV{TWITTER_CONSUMER_KEY},
      user_agent          =&amp;gt; &#39;TwitterBotExample&#39;,
      ssl =&amp;gt; 1,
    );
    $twitter-&amp;gt;update($tweet);
  }
  catch
  {
    die join(&#39; &#39;, &amp;quot;Error tweeting $text $url $hashtag&amp;quot;,
                   $_-&amp;gt;code, $_-&amp;gt;message, $_-&amp;gt;error);
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Twitter treats urls as having a length of 12 characters. Now the code checks the length of our arguments, truncating &lt;code&gt;$text&lt;/code&gt; if necessary. The hashtag will be included only if there is enough space.&lt;/p&gt;

&lt;p&gt;This code works for me, but you may want to do things a little differently. The Twitter credentials could be stored in a &lt;a href=&#34;http://perltricks.com/article/29/2013/9/17/How-to-Load-YAML-Config-Files&#34;&gt;configuration&lt;/a&gt; file, instead of environment variables. The &lt;code&gt;$hashtag&lt;/code&gt; argument could be an arrayref of hashtags, that are incrementally added to the tweet text, instead of a single text string which restricts it to an all-or-nothing basis.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build a Reddit bot with Perl</title>
      <link>http://perltricks.com/article/151/2015/2/9/Build-a-Reddit-bot-with-Perl/</link>
      <pubDate>Mon, 09 Feb 2015 13:41:04 +0000</pubDate>
      
      <guid>http://perltricks.com/article/151/2015/2/9/Build-a-Reddit-bot-with-Perl/</guid>
      <description>

&lt;p&gt;One of my goals for this year was to post more links to the Perl &lt;a href=&#34;http://www.reddit.com/r/perl&#34;&gt;subreddit&lt;/a&gt;. I&amp;rsquo;m usually good at linking to PerlTricks articles, but not so good at linking to other content. And that&amp;rsquo;s a shame because there are a lot of active Perl blogs out there (I know of at least 25-30).&lt;/p&gt;

&lt;p&gt;A busier Perl subreddit is good for the community; more links on /r/perl should lead to more visitors, and more activity on the subreddit and so on - a virtuous circle. So I built a bot to automate the posting of links. In this article I&amp;rsquo;m going to show you how I did it.&lt;/p&gt;

&lt;h3 id=&#34;reddit-api:f338286cb816fcc4501664bb4edd9fd0&#34;&gt;Reddit API&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ll need a Reddit account to use the API. I like to use &lt;a href=&#34;https://metacpan.org/pod/Reddit::Client&#34;&gt;Reddit::Client&lt;/a&gt; as it works well, has good documentation and maintains a session cache. This is a subroutine for posting links to Reddit:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use warnings;
use strict;
use Reddit::Client;

sub post_reddit_link
{
    my ($title, $url, $subreddit) = @_; 

    my $reddit       = Reddit::Client-&amp;gt;new(
        session_file =&amp;gt; &#39;logs/session_data.json&#39;,
        user_agent   =&amp;gt; &#39;perly_bot/v0.01&#39;,
    );  

    unless ( $reddit-&amp;gt;is_logged_in ) { 
        $reddit-&amp;gt;login( $ENV{REDDIT_USERNAME}, 
                        $ENV{REDDIT_PASSWORD} );
        $reddit-&amp;gt;save_session();
    }   
    
    $reddit-&amp;gt;submit_link(
            subreddit =&amp;gt; $subreddit,
            title     =&amp;gt; $title,
            url       =&amp;gt; $url
    );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code should be fairly self-explanatory. The &lt;code&gt;post_reddit_link&lt;/code&gt; subroutine accepts three parameters: the subreddit to post to, the title of the post, and the URL of the link. It initializes a new Reddit::Client object, passing the path of the session file and the user agent string to use when calling the Reddit API. The session file is just a cache for storing a session cookie.&lt;/p&gt;

&lt;p&gt;Next, the subroutine checks if the &lt;code&gt;$reddit&lt;/code&gt; object has an active session or not, triggering a login request if necessary. I like to store credentials in environment variables: that way the code and any config files can still be hosted on a public repository, without risk of sharing your login details with anyone. The last bit of code calls &lt;code&gt;submit_link&lt;/code&gt; method to post the link to the Reddit API.&lt;/p&gt;

&lt;p&gt;This code will work in ideal scenarios, but what if something goes wrong? For example, Reddit imposes restrictions on the posting of links: the same link cannot be posted twice to the same subreddit, proxy domains are banned and links cannot be posted too frequently. In order to capture the error messages, I&amp;rsquo;m going to wrap the &lt;code&gt;submit_link&lt;/code&gt; method in a try/catch block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use warnings;
use strict;
use Reddit::Client;
use Try::Tiny;
use Time::Piece;

open my $ERROR_LOG, &#39;&amp;gt;&amp;gt;&#39;, &#39;logs/error.log&#39; or die $!;

sub post_reddit_link
{
    my ($title, $url, $subreddit) = @_; 

    my $reddit       = Reddit::Client-&amp;gt;new(
        session_file =&amp;gt; &#39;logs/session_data.json&#39;,
        user_agent   =&amp;gt; &#39;perly_bot/v0.01&#39;,
    );  

    unless ( $reddit-&amp;gt;is_logged_in ) { 
        $reddit-&amp;gt;login( $ENV{REDDIT_USERNAME}, 
                        $ENV{REDDIT_PASSWORD} );
        $reddit-&amp;gt;save_session();
    }   
    
    try {
        $reddit-&amp;gt;submit_link(
            subreddit =&amp;gt; $subreddit,
            title     =&amp;gt; $title,
            url       =&amp;gt; $url
        );
    } catch {
        log_error(&amp;quot;Error posting $title $url $_&amp;quot;);
    };
}

sub log_error
{
    my $datetime = localtime;
    say $ERROR_LOG $datetime_now-&amp;gt;datetime . &amp;quot;\t$_[0]&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to the try/catch, I&amp;rsquo;ve added a &lt;code&gt;log_error&lt;/code&gt; subroutine which will write error messages to the error log.&lt;/p&gt;

&lt;h3 id=&#34;reading-blog-feeds:f338286cb816fcc4501664bb4edd9fd0&#34;&gt;Reading blog feeds&lt;/h3&gt;

&lt;p&gt;Now I have a subroutine for posting links to Reddit, I need a way to monitor blog feeds and post links to new articles. Most blogs provide feed data via RSS or atom data, for example &lt;a href=&#34;http://blogs.perl.org&#34;&gt;blogs.perl.org&lt;/a&gt; uses atom. I can monitor this feed using &lt;a href=&#34;https://metacpan.org/pod/HTTP::Tiny&#34;&gt;HTTP::Tiny&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/XML::Atom::Client&#34;&gt;XML::Atom::Client&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use XML::Atom::Client;
use HTTP::Tiny;

sub check_feed
{
    my ($url) = @_;

    my $ua = HTTP::Tiny-&amp;gt;new;
    my $response = $ua-&amp;gt;get($url);
    if ( $response-&amp;gt;{success} )
    {
        my $posts = 
          XML::Atom::Feed-&amp;gt;new( Stream =&amp;gt; \$response-&amp;gt;{content} );

        foreach my $post ( $posts-&amp;gt;entries )
        {
            post_reddit_link(
                $post-&amp;gt;title,
                $post-&amp;gt;link-&amp;gt;href,
                &#39;perl&#39;
            );
        }
    }
    else
    {
        log_error(
&amp;quot;Error requesting $url. $response-&amp;gt;{status} $response-&amp;gt;{reason}&amp;quot;
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code declares a subroutine called &lt;code&gt;check_feed&lt;/code&gt; which accepts a URL as parameter. It fetches the URL content using HTTP::Tiny, and if successful, loops through every blog post in an atom feed, calling &lt;code&gt;post_reddit_link&lt;/code&gt; on each post. As it stands, this code is going to cause problems. We only want to post relevant and new content to the Perl subreddit, but this code will post a link for every blog post returned by the feed URL.&lt;/p&gt;

&lt;p&gt;To check for relevant content, I can use a regex to match against keywords. If the text contains words like &amp;ldquo;Perl&amp;rdquo; or &amp;ldquo;CPAN&amp;rdquo;, I assume it&amp;rsquo;s Perl related. This is the regex:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;#  must contain a Perl keyword to be considered relevant
my $looks_perly = qr/\b(?:perl|cpan|cpanminus|moose|metacpan|modules?)\b/i;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To filter out stale content, I need to set a threshold for how long posts should be considered fresh. I can then subtract the publication date of the blog post from the current datetime to see if the publication date exceeds my threshold or not. I&amp;rsquo;m going to use 24 hours as my threshold:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Time::Piece;
use Time::Seconds;

my $datetime_post = 
  Time::Piece-&amp;gt;strptime($post-&amp;gt;published, &#39;%Y-%m-%dT%H:%M:%SZ&#39;);
my $datetime_now = localtime;

if ( $datetime_post &amp;gt; $datetime_now - ONE_DAY )
{
   ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code uses the &lt;code&gt;strptime&lt;/code&gt; function in Time::Piece to extract the publication datetime of the post. It then compares the datetime of the post with the current datetime minus 24 hours (&amp;ldquo;ONE_DAY&amp;rdquo; is a constant for 24 hours that is exported by Time::Seconds).&lt;/p&gt;

&lt;h3 id=&#34;wrap-up:f338286cb816fcc4501664bb4edd9fd0&#34;&gt;Wrap up&lt;/h3&gt;

&lt;p&gt;Putting it all together, the code looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use warnings;
use strict;
use Reddit::Client;
use Try::Tiny;
use Time::Piece;
use Time::Seconds;
use XML::Atom::Client;
use HTTP::Tiny;

open my $ERROR_LOG, &#39;&amp;gt;&amp;gt;&#39;, &#39;logs/error.log&#39; or die $!;

#  must contain a Perl keyword to be considered relevant
my $looks_perly = qr/\b(?:perl|cpan|cpanminus|moose|metacpan|modules?)\b/i;

# post links for new posts on blogs.perl.org
check_feed(&#39;http://blogs.perl.org/atom.xml&#39;);

sub post_reddit_link
{
    my ($title, $url, $subreddit) = @_;

    my $reddit       = Reddit::Client-&amp;gt;new(
        session_file =&amp;gt; &#39;logs/session_data.json&#39;,
        user_agent   =&amp;gt; &#39;perly_bot/v0.01&#39;,
    );

    unless ( $reddit-&amp;gt;is_logged_in ) {
        $reddit-&amp;gt;login( $ENV{REDDIT_USERNAME},
                        $ENV{REDDIT_PASSWORD} );
        $reddit-&amp;gt;save_session();
    }

    try {
        $reddit-&amp;gt;submit_link(
            subreddit =&amp;gt; $subreddit,
            title     =&amp;gt; $title,
            url       =&amp;gt; $url
        );
    } catch {
        log_error(&amp;quot;Error posting $title $url $_&amp;quot;);
    };
}

sub log_error
{
    my $datetime = localtime;
    say $ERROR_LOG $datetime-&amp;gt;datetime . &amp;quot;\t$_[0]&amp;quot;;
}

sub check_feed
{
    my ($url) = @_;

    my $ua = HTTP::Tiny-&amp;gt;new;
    my $response = $ua-&amp;gt;get($url);

    if ( $response-&amp;gt;{success} )
    {
        my $posts =
          XML::Atom::Feed-&amp;gt;new( Stream =&amp;gt; \$response-&amp;gt;{content} );

        foreach my $post ( $posts-&amp;gt;entries )
        {
            my $datetime_post =
              Time::Piece-&amp;gt;strptime($post-&amp;gt;published, &#39;%Y-%m-%dT%H:%M:%SZ&#39;);
            my $datetime_now = localtime;

            # if fresh post and contains Perl keyword
            if (   $datetime_post &amp;gt; $datetime_now - ONE_DAY
                &amp;amp;&amp;amp; $post-&amp;gt;summary =~ $looks_perly)
            {
                post_reddit_link(
                    $post-&amp;gt;title,
                    $post-&amp;gt;link-&amp;gt;href,
                    &#39;perl&#39;
                );
            }
        }
    }
    else
    {
        log_error(
&amp;quot;Error requesting $url. $response-&amp;gt;{status} $response-&amp;gt;{reason}&amp;quot;
        );
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When run, this script will check blogs.perl.org for new posts, and submit them to /r/perl.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a lot more that could be done with this script: for instance it only supports atom feeds, but many blog feeds use RSS. The URLs to check must be hard coded into the script - it would be better to take them from a configurable list. Finally, there is no URL caching, so running this script twice in 24 hours will lead to it attempting to post the same links to Reddit twice. For an extended example that addresses these issues and more, check out my Perly-Bot GitHub &lt;a href=&#34;https://github.com/dnmfarrell/Perly-Bot&#34;&gt;repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Automated Internet Explorer screenshots using Win32::OLE</title>
      <link>http://perltricks.com/article/139/2014/12/11/Automated-Internet-Explorer-screenshots-using-Win32--OLE/</link>
      <pubDate>Thu, 11 Dec 2014 14:44:25 +0000</pubDate>
      
      <guid>http://perltricks.com/article/139/2014/12/11/Automated-Internet-Explorer-screenshots-using-Win32--OLE/</guid>
      <description>

&lt;h3 id=&#34;background:97eeb34526f592925997048598be600f&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;Some time ago I &lt;a href=&#34;http://blog.nu42.com/2012/06/using-win32ole-with-events-to-capture.html&#34;&gt;wrote&lt;/a&gt; about using Perl&amp;rsquo;s Win32::OLE to drive Internet Explorer in response to a &lt;a href=&#34;http://stackoverflow.com/a/11220026/100754&#34;&gt;question&lt;/a&gt; on Stackoverflow.&lt;/p&gt;

&lt;p&gt;At the time I was still clinging to Windows XP. Since then, I have upgraded to Windows 8.1 Pro 64-bit, and instead of using &lt;a href=&#34;http://www.activestate.com/activeperl/ppm-perl-modules&#34;&gt;PPMs&lt;/a&gt; for &lt;a href=&#34;http://www.activestate.com/activeperl&#34;&gt;ActivePerl&lt;/a&gt;, I have been using &lt;a href=&#34;http://blog.nu42.com/2014/11/64-bit-perl-5201-with-visual-studio.html&#34;&gt;Visual Studio 2013&lt;/a&gt; to build &lt;code&gt;perl&lt;/code&gt;, and the modules I need.&lt;/p&gt;

&lt;p&gt;I have been using Perl&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/Win32::OLE&#34;&gt;Win32::OLE&lt;/a&gt; to drive Internet Explorer for various purposes for almost 10 years now. There is really not much to it other than having to read copious amounts of Microsoft documentation. It always amazes me how, after all these years, there is no language or environment as well documented as Perl, not just in terms of the amount of information provided, but also the ease with which you can find clear, correct, and useful information.&lt;/p&gt;

&lt;p&gt;In any case, while the organization of the information leaves a lot to be desired, a good starting point for finding information on driving Internet Explorer via OLE is the InternetExplorer object &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa752084%28v=vs.85%29&#34;&gt;documentation&lt;/a&gt; on MSDN. If you want to interact with the content within an InternetExplorer object, you can consult the MSHTML Scripting Object Interfaces &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh801967%28v=vs.85%29.aspx&#34;&gt;topic&lt;/a&gt;. It also helps to know a little bit about the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/19z074ky.aspx&#34;&gt;OLE&lt;/a&gt; interface.&lt;/p&gt;

&lt;p&gt;Reading brian d foy&amp;rsquo;s article on &lt;a href=&#34;https://perltricks.com/article/138/2014/12/7/Controlling-Firefox-from-Perl&#34;&gt;controlling Firefox from Perl&lt;/a&gt;, I noticed that &lt;a href=&#34;https://metacpan.org/search?q=Win32-IE-Mechanize&#34;&gt;Win32::IE::Mechanize&lt;/a&gt; has disappeared from CPAN. The &lt;a href=&#34;http://www.perlmonks.org?node_id=1061372&#34;&gt;discussion on PerlMonks&lt;/a&gt; did not make much sense to me, as I remember very clearly using Win32::OLE to drive Internet Explorer 8 for a massive scraping job.&lt;/p&gt;

&lt;p&gt;I decided to look at my old screenshot utility, and see what changes were needed to get it to run on Windows 8, using Internet Explorer 10. My &lt;a href=&#34;https://gist.github.com/nanis/3dac6b386bd056095e12&#34;&gt;revised working script is available in a GitHub gist&lt;/a&gt;. Here, I am going to cover the highlights.&lt;/p&gt;

&lt;h3 id=&#34;tracing-execution:97eeb34526f592925997048598be600f&#34;&gt;Tracing execution&lt;/h3&gt;

&lt;p&gt;The idea is to use the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa768283%28v=vs.85%29.aspx&#34;&gt;DWebBrowserEvents2&lt;/a&gt; to figure out the right time to capture the browser window. I decided to see if my answer from 2012 still worked. I pointed it to my personal website, and it failed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Win32::OLE(0.1712) error 0x80020009: &amp;quot;Exception occurred&amp;quot;
    in METHOD/PROPERTYGET &amp;quot;StatusText&amp;quot; at iescreenshot.pl line 38.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The cause of the problem lay in accessing the &lt;code&gt;StatusText&lt;/code&gt; property of the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa752084%28v=vs.85%29&#34;&gt;Internet Explorer object&lt;/a&gt;. Apparently, IE10 no longer exposes this property. Well, I had only used it so as to give some idea of what was happening. I decided instead to write a quick logging function which could be used with all events:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub log_browser_event {
    my $event = shift;
    no warnings &#39;uninitialized&#39;;
    my $args = eval { join(&#39; &#39; =&amp;gt; map valof($_), @_) };
    say &amp;quot;$event: $args&amp;quot;;
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not an example of perfect code, but, I am trying to keep this short and sweet.&lt;/p&gt;

&lt;h3 id=&#34;event-handling:97eeb34526f592925997048598be600f&#34;&gt;Event handling&lt;/h3&gt;

&lt;p&gt;We are only interested in two events: &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa768282%28v=vs.85%29.aspx&#34;&gt;DocumentComplete&lt;/a&gt;, so we know when to take a screenshot, and &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa768340%28v=vs.85%29.aspx&#34;&gt;onQuit&lt;/a&gt;, so we can quit cleanly if the user closes the browser window before we get to that point.&lt;/p&gt;

&lt;p&gt;You initialize OLE events using the call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;Win32::OLE-&amp;gt;WithEvents(
    $object,
    $handler,
    $interface
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, presumably, your &lt;code&gt;$handler&lt;/code&gt; has some giant switch statement, dispatching on the basis of the actual events received. Instead, I opted for a dispatch table:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;const my %BrowserEvents =&amp;gt; (
    DocumentComplete =&amp;gt; sub {
        $do_take_screenshot = 1;
        Win32::MessageLoop-&amp;gt;QuitMessageLoop;
    },
    OnQuit =&amp;gt; sub {
        $do_take_screenshot = 0;
        Win32::MessageLoop-&amp;gt;QuitMessageLoop;
    },
    _ =&amp;gt; sub { },
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the use of &lt;a href=&#34;https://metacpan.org/pod/Win32::MessageLoop&#34;&gt;Win32::MessageLoop-&amp;gt;QuitMessageLoop&lt;/a&gt; instead of &lt;code&gt;Win32::OLE-&amp;gt;QuitMessageLoop&lt;/code&gt; to avoid spurious sleep calls.&lt;/p&gt;

&lt;p&gt;Then, I initialize the OLE events interface using:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;Win32::OLE-&amp;gt;WithEvents(
    $browser,
    sub { $handler-&amp;gt;(\%BrowserEvents, @_) },
    &#39;DWebBrowserEvents2&#39;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$handler&lt;/code&gt; in this case just logs the event, and consults the dispatch table to see if we are interested in the event:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub WebBrowserEventHandler {
    my $handlers = shift;
    my $browser = shift;
    my $event = shift;

    log_browser_event($event, @_);

    my $handler = exists $handlers-&amp;gt;{$event}
                ? $handlers-&amp;gt;{$event}
                : $handlers-&amp;gt;{_}
    ;
    $handler-&amp;gt;($browser, $event, @_);
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Upon receiving either &lt;code&gt;DocumentComplete&lt;/code&gt; or &lt;code&gt;onQuit&lt;/code&gt;, we terminate the message loop, which returns control to the navigation function. At that point, the only thing left is to check if we should capture a screenshot. After that, the program terminates.&lt;/p&gt;

&lt;h3 id=&#34;capturing-the-internet-explorer-window:97eeb34526f592925997048598be600f&#34;&gt;Capturing the Internet Explorer window&lt;/h3&gt;

&lt;p&gt;When I ran this revised script, and tried to take screenshots using &lt;a href=&#34;https://metacpan.org/pod/Imager::Screenshot&#34;&gt;Imager::Screenshot&lt;/a&gt;, I got screenshots with only the frame of the browser, and none of the content. I am not sure what&amp;rsquo;s going on, and I will try to diagnose that issue later. For now, since I was using the venerable &lt;a href=&#34;https://metacpan.org/pod/Win32::GuiTest&#34;&gt;Win32::GuiTest&lt;/a&gt; module anyway, I decided to use the &lt;code&gt;Win32::GuiTest::DibSect&lt;/code&gt; class it provides:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub take_screenshot {
    my $browser = shift;

    wait_until_ready($browser);

    my $hwnd = $browser-&amp;gt;{HWND};
    my $title = $browser-&amp;gt;{Document}{title};
    $title =~ s/[^A-Za-z0-9_-]+/-/g;

    my $ds = Win32::GuiTest::DibSect-&amp;gt;new;

    my $fgwnd = GetForegroundWindow();
    SetForegroundWindow $hwnd;
    $ds-&amp;gt;CopyWindow($hwnd);
    SetForegroundWindow $fgwnd;

    $ds-&amp;gt;SaveAs(&amp;quot;$title.bmp&amp;quot;);
    $ds-&amp;gt;Destroy;

    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;waiting-for-the-document-to-be-rendered:97eeb34526f592925997048598be600f&#34;&gt;Waiting for the document to be rendered&lt;/h3&gt;

&lt;p&gt;With that in place, I was still getting the occasional screenshot with a blank document area. If I understand this correctly, the fact that the &lt;code&gt;DocumentReady&lt;/code&gt; event fired does not mean the document has been fully rendered. It just means that you can manipulate the DOM. So, I added a simple spin loop for the browser to stop being &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa752050%28v=vs.85%29&#34;&gt;busy&lt;/a&gt;. This is by no means foolproof, but it has worked for most sites have tried. Sites with a lot of AJAXy stuff tend to have issues with this. There are site-specific ways of dealing with that, but that&amp;rsquo;s beyond the scope of this article.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub wait_until_ready {
    my $browser = shift;
    {
        local $| = 1;
        while ($browser-&amp;gt;Busy) {
            print &#39;.&#39;;
            sleep 1;
        }
    }
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, you can run the script from the command line with a simple &lt;code&gt;perl iescreenshot.pl perltricks.com&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;the-webdriver-api:97eeb34526f592925997048598be600f&#34;&gt;The WebDriver API&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ie/dn725045%28v=vs.85%29.aspx&#34;&gt;WebDriver API&lt;/a&gt; might obviate the need for using any other solution to drive Internet Explorer, but, until that is available everywhere, &lt;a href=&#34;https://metacpan.org/pod/Win32::OLE&#34;&gt;Win32::OLE&lt;/a&gt; is more than adequate.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:97eeb34526f592925997048598be600f&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Using &lt;a href=&#34;https:/metacpan.org/pod/Win32::OLE&#34;&gt;Win32::OLE&lt;/a&gt; to drive Internet Explorer has been very helpful to me in the past. Taking a screenshot is just a simple, proof-of-concept exercise. The beauty of using Perl is that once you reach a page containing the information you want, you can use Perl&amp;rsquo;s excellent HTML parsing modules to get exactly what you want out of it, and then, say, save it to an Excel worksheet, generate PDF document, or just stuff it in a database somewhere.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Controlling Firefox from Perl</title>
      <link>http://perltricks.com/article/138/2014/12/8/Controlling-Firefox-from-Perl/</link>
      <pubDate>Mon, 08 Dec 2014 14:13:27 +0000</pubDate>
      
      <guid>http://perltricks.com/article/138/2014/12/8/Controlling-Firefox-from-Perl/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve been playing with &lt;a href=&#34;http://www.metacpan.org/module/WWW::Mechanize::Firefox&#34;&gt;WWW::Mechanize::Firefox&lt;/a&gt;. It&amp;rsquo;s like the LWP-backended &lt;a href=&#34;http://www.metacpan.org/module/WWW::Mechanize&#34;&gt;WWW::Mechanize&lt;/a&gt;, but with a browser doing all the work. Instead of doing it all in Perl, I can use it as the glue language that it is.&lt;/p&gt;

&lt;p&gt;Sometimes &lt;a href=&#34;http://www.metacpan.org/module/WWW::Mechanize&#34;&gt;WWW::Mechanize&lt;/a&gt;, &lt;a href=&#34;http://www.metacpan.org/module/LWP::UserAgent&#34;&gt;LWP::UserAgent&lt;/a&gt;, or &lt;a href=&#34;http://www.metacpan.org/module/Mojo::UserAgent&#34;&gt;Mojo::UserAgent&lt;/a&gt; aren&amp;rsquo;t enough. For basic web scraping and automation they work well, but fail miserably for anything that requires JavaScript. Some people have luck with SpiderMonkey (&lt;a href=&#34;https://metacpan.org/search?q=spidermonkey&amp;amp;&#34;&gt;with several Perl interfaces&lt;/a&gt;), but that still isn&amp;rsquo;t the whole browser environment.&lt;/p&gt;

&lt;p&gt;Before you start, you need the &lt;a href=&#34;https://www.mozilla.org&#34;&gt;Firefox&lt;/a&gt; browser (or one of its forks) with the &lt;a href=&#34;https://addons.mozilla.org/en-us/firefox/addon/mozrepl/&#34;&gt;MozRepl&lt;/a&gt; add-on, which provides an interactive JavaScript console that you can telnet into. Once activated, you can connect to the console and can control the browser.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://farm8.staticflickr.com/7503/15324164413_0a43aeb932.jpg&#34; title=&#34;activate_mozrepl by brian d foy, on Flickr&#34;&gt;&lt;img src=&#34;https://farm8.staticflickr.com/7503/15324164413_0a43aeb932.jpg&#34; alt=&#34;activate\_mozrepl&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I have to know JavaScript to control Firefox directly. I can telnet into the MozRepl server and issue commands. It&amp;rsquo;s a bit more work than I&amp;rsquo;d like to do.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://farm9.staticflickr.com/8680/15941835341_f064e9e2a3.jpg&#34; title=&#34;mozrepl_telnet by brian d foy, on Flickr&#34;&gt;&lt;img src=&#34;https://farm9.staticflickr.com/8680/15941835341_f064e9e2a3.jpg&#34; alt=&#34;mozrepl\_telnet&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not going to control Firefox directly, though, because I&amp;rsquo;m going to let some Perl modules do that for me. The basic interface of &lt;a href=&#34;http://www.metacpan.org/module/WWW::Mechanize::Firefox&#34;&gt;WWW::Mechanize::Firefox&lt;/a&gt; is the same as &lt;a href=&#34;http://www.metacpan.org/module/WWW::Mechanize&#34;&gt;WWW::Mechanize&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;#!/usr/local/perls/perl-5.20.0/bin/perl
use v5.10;
use WWW::Mechanize::Firefox;

my $mech = WWW::Mechanize::Firefox-&amp;gt;new;
$mech-&amp;gt;autoclose_tab( 0 );

$mech-&amp;gt;get( &#39;http://www.perltricks.com&#39; );

foreach my $link ( $mech-&amp;gt;links ) {
    state $count = 0;
    say $count++, &amp;quot;: &amp;quot;, $link-&amp;gt;url;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I get a list of the links on the PerlTricks main page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0: http://perltricks.com/favicon.ico
1: http://perltricks.com/feed/atom
2: http://perltricks.com/feed/rss
3: http://perltricks.com/css/bootstrap.min.css
4: http://perltricks.com/css/carousel.css
5: http://perltricks.com/css/perltricks.css
6: https://twitter.com/intent/follow?screen_name=perltricks
7: http://perltricks.com/feed/rss
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s not even the good part yet.&lt;/p&gt;

&lt;h3 id=&#34;executing-javascript:b571cb2b36a22a2464e2b146c6144eec&#34;&gt;Executing JavaScript&lt;/h3&gt;

&lt;p&gt;Since I&amp;rsquo;m connected to a JavaScript terminal, I can evaluate JavaScript code. The &lt;code&gt;eval&lt;/code&gt; returns the result and its type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use v5.10;
use WWW::Mechanize::Firefox;

my $mech = WWW::Mechanize::Firefox-&amp;gt;new;
$mech-&amp;gt;autoclose_tab( 0 );

my( $result, $type ) = $mech-&amp;gt;eval( &#39;2+2&#39; );

say &amp;quot;2+2 is $result (type $type)&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;2+2 is 4 (type number)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That evaluates the JavaScript in its own context, which isn&amp;rsquo;t that interesting for me. I want to interact and control parts of a web page. To do that, I use the &lt;code&gt;eval_in_page&lt;/code&gt;. That runs the JavaScript with everything else going on in the current tab, including all the JavaScript code it has loaded. Here&amp;rsquo;s an example that uses the StackExchange JavaScript to change the view from the desktop mode to the mobile mode:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use v5.10;
use WWW::Mechanize::Firefox;

my $mech = WWW::Mechanize::Firefox-&amp;gt;new;
$mech-&amp;gt;autoclose_tab( 0 );

$mech-&amp;gt;get( &#39;http://www.stackoverflow.com/&#39; );
sleep 5;
$mech-&amp;gt;eval_in_page( &#39;StackExchange.switchMobile(&amp;quot;on&amp;quot;)&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I run this, the screen changes from the full site to the mobile site.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://farm9.staticflickr.com/8640/15943126852_07692bfc09.jpg&#34; title=&#34;screenshots by brian d foy, on Flickr&#34;&gt;&lt;img src=&#34;https://farm9.staticflickr.com/8640/15943126852_07692bfc09.jpg&#34; alt=&#34;screenshots&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;some-problems:b571cb2b36a22a2464e2b146c6144eec&#34;&gt;Some problems&lt;/h3&gt;

&lt;p&gt;This approach has some problem though, almost none of which come from Perl. If I want to automate something that makes many requests or runs for a long time, Firefox is likely to have problems. Over time, &lt;a href=&#34;https://support.mozilla.org/en-US/kb/firefox-uses-too-much-memory-ram&#34;&gt;it&amp;rsquo;s memory footprint grows&lt;/a&gt;, leading to poor performance and crashes. Sometimes the connection to the console breaks, taking down my program with it.&lt;/p&gt;

&lt;p&gt;Because of this, I limit my use of &lt;a href=&#34;http://www.metacpan.org/module/WWW::Mechanize::Firefox&#34;&gt;WWW::Mechanize::Firefox&lt;/a&gt; to the parts of my problem that require JavaScript. I can extract the information I need then use &lt;a href=&#34;http://www.metacpan.org/module/Mojo::UserAgent&#34;&gt;Mojo::UserAgent&lt;/a&gt; to handle the other parts.&lt;/p&gt;

&lt;h3 id=&#34;similar-solutions:b571cb2b36a22a2464e2b146c6144eec&#34;&gt;Similar solutions&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;http://www.metacpan.org/module/WWW::Mechanize::Firefox&#34;&gt;WWW::Mechanize::Firefox&lt;/a&gt; isn&amp;rsquo;t the only way to do this sort of thing. &lt;a href=&#34;http://blogs.perl.org/users/robhammond/2013/02/web-scraping-with-perl-phantomjs.html&#34;&gt;Rob Hammond posted on blogs.perl.org about PhantomJS&lt;/a&gt;, which received some comments about &lt;a href=&#34;http://www.metacpan.org/module/WWW::WebKit&#34;&gt;WWW::WebKit&lt;/a&gt;. There used to be a Win32::IE::Mechanize, but apparently it &lt;a href=&#34;http://www.perlmonks.org/?node_id=1061372&#34;&gt;doesn&amp;rsquo;t work in IE 8&lt;/a&gt;. &lt;a href=&#34;http://www.seleniumhq.org&#34;&gt;Selenium&lt;/a&gt; and &lt;a href=&#34;http://www.metacpan.org/module/Test::WWW::Selenium&#34;&gt;Test::WWW::Selenium&lt;/a&gt; is another tool that I could use, but that&amp;rsquo;s more geared to browser acceptance testing and replays.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Join the discussion on the Perl &lt;a href=&#34;http://www.reddit.com/r/perl/comments/2onaz4/controlling_firefox_from_perl_by_brian_d_foy/&#34;&gt;subreddit&lt;/a&gt; about this article!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; &lt;em&gt;last paragraph updated to include Selenium reference. 2014-12-09&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Easily check your IP address with Perl</title>
      <link>http://perltricks.com/article/116/2014/9/18/Easily-check-your-IP-address-with-Perl/</link>
      <pubDate>Thu, 18 Sep 2014 12:22:54 +0000</pubDate>
      
      <guid>http://perltricks.com/article/116/2014/9/18/Easily-check-your-IP-address-with-Perl/</guid>
      <description>

&lt;p&gt;Every now and then I&amp;rsquo;ll run into a problem where I need to programmatically check my IP address. Each time I&amp;rsquo;ve hand-crafted a solution, which is fine, but good programming is DRY programming, and so I finally wrote a module to do it. The module is called &lt;a href=&#34;https://metacpan.org/pod/WWW::curlmyip&#34;&gt;WWW::curlmyip&lt;/a&gt; because it uses the &lt;a href=&#34;http://curlmyip.com&#34;&gt;curlmyip.com&lt;/a&gt; service. I find the module useful and you might too.&lt;/p&gt;

&lt;h3 id=&#34;core-perl-solution:cf26d793cfd057bc371af7c785bc0d25&#34;&gt;Core Perl solution&lt;/h3&gt;

&lt;p&gt;Before we look at the module, let&amp;rsquo;s consider a Perl solution using only core Perl code. I can grab my IP address from the terminal with a single line of Perl:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl -MHTTP::Tiny -e &#39;print HTTP::Tiny-&amp;gt;new-&amp;gt;get(q{http://curlmyip.com})-&amp;gt;{content}&#39;
121.45.140.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Tip:&lt;/strong&gt; if you&amp;rsquo;re on Windows use double quotes instead of singles.&lt;/p&gt;

&lt;p&gt;Well that was easy. But notice how I didn&amp;rsquo;t have to append a newline to the output? That&amp;rsquo;s because curlmyip.com returns the IP address with a newline appended. If we want to use the IP address as an input to any other program, we&amp;rsquo;ll need to &lt;code&gt;chomp&lt;/code&gt; that newline away. The code would then be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl -MHTTP::Tiny -E &#39;$ip=HTTP::Tiny-&amp;gt;new-&amp;gt;get(q{http://curlmyip.com})-&amp;gt;{content}; chomp $ip; say $ip&#39;
121.45.140.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not so clean anymore is it? In fact it would be a stretch to call this a &amp;ldquo;one liner&amp;rdquo; at all. What about if I wanted to add exception handling, to &lt;code&gt;die&lt;/code&gt; and print a useful error message? Once you get to this stage, it&amp;rsquo;s time to think about putting the code into a module.&lt;/p&gt;

&lt;h3 id=&#34;using-www-curlmyip:cf26d793cfd057bc371af7c785bc0d25&#34;&gt;Using WWW::curlmyip&lt;/h3&gt;

&lt;p&gt;The module exports a &lt;code&gt;get_ip&lt;/code&gt; function which returns the IP address. It&amp;rsquo;s super simple to use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use WWW::curlmyip;

my $ip = get_ip();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, so good. But what can you do with this information? In the past I&amp;rsquo;ve had programs check my IP address when connected to a VPN, or to TOR to confirm my real IP is masked. The other obvious use case is geolocation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;#!/usr/bin/env perl

use WWW::curlmyip;
use Geo::IP;

my $ip = get_ip();

my $geoip = Geo::IP-&amp;gt;open(&#39;GeoLiteCity.dat&#39;, GEOIP_STANDARD);
my $record = $geoip-&amp;gt;record_by_addr($ip);

print &amp;quot;You are in $record-&amp;gt;{region_name}, $record-&amp;gt;{country_code}\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this code I retrieve my IP address and then lookup my location using the &lt;a href=&#34;https://metacpan.org/pod/Geo::IP&#34;&gt;Geo::IP&lt;/a&gt; module from MaxMind. Saving the code as &lt;code&gt;whereami.pl&lt;/code&gt; and running it outputs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ whereami.pl
You are in New York, US
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The geolocation data could also be used an an input to last week&amp;rsquo;s weather &lt;a href=&#34;http://perltricks.com/article/114/2014/9/11/Get-a-weather-report-at-the-terminal-with-Perl&#34;&gt;script&lt;/a&gt; to automatically retrieve the weather forecast for your local area.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:cf26d793cfd057bc371af7c785bc0d25&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s a simple task but hopefully WWW::curlmyip makes obtaining your IP address a little easier. If your interested in Geo::IP, check out Gabor Szabo&amp;rsquo;s recent &lt;a href=&#34;http://perlmaven.com/using-travis-ci-and-installing-geo-ip-on-linux#h2&#34;&gt;guide&lt;/a&gt; on how to install it. Finally, if you want to get your IP address and location in a single request, take a look at my other new module, &lt;a href=&#34;https://metacpan.org/pod/WWW::ipinfo&#34;&gt;WWW::ipinfo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generate static websites from dynamic Perl web apps</title>
      <link>http://perltricks.com/article/102/2014/7/15/Generate-static-websites-from-dynamic-Perl-web-apps/</link>
      <pubDate>Tue, 15 Jul 2014 12:26:52 +0000</pubDate>
      
      <guid>http://perltricks.com/article/102/2014/7/15/Generate-static-websites-from-dynamic-Perl-web-apps/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Static websites aren&amp;rsquo;t suitable for every situation, but they have several advantages over dynamic apps; they&amp;rsquo;re more efficient, more secure and simpler to deploy. That said, developing and maintaining a static site is a pain, there&amp;rsquo;s just too much repetitive boilerplate code. Enter &lt;a href=&#34;https://metacpan.org/pod/wallflower&#34;&gt;Wallflower&lt;/a&gt;, it generates static websites from PSGI compatible Perl web applications. You get the best of both worlds: develop the routes, templates and unit tests in your favourite web framework but deploy it as a static website with Wallflower.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;requirements:29419c887d0bf32d7cca4c904ddd08fe&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;The CPAN Testers &lt;a href=&#34;http://matrix.cpantesters.org/?dist=App-Wallflower+1.004&#34;&gt;results&lt;/a&gt; for the latest version (v1.004) of App::Wallflower show it runs on just about any Perl and operating system, including Windows. You can install it from CPAN by going to the command line and typing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpan App::Wallflower
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wallflower-in-action:29419c887d0bf32d7cca4c904ddd08fe&#34;&gt;Wallflower in action&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s create a simple application using &lt;a href=&#34;https://metacpan.org/pod/Dancer2&#34;&gt;Dancer2&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ dancer2 -a MyApp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will create a skeleton application for us. Now change into the root application directory and create a new directory to hold the static files, we&amp;rsquo;ll call it &amp;ldquo;static&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cd MyApp
$ mkdir static
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all we need to generate the static site with wallflower:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ wallflower --a bin/app.pl --d static
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wallflower will request the application root page (&amp;lsquo;/&amp;rsquo;) and spider all links it finds from there, copying the files to the static folder. This includes files referenced in your html and css, such as JavaScript files. If your app has links to all of its pages, this is all you need.&lt;/p&gt;

&lt;h3 id=&#34;test-the-static-site-with-nginx:29419c887d0bf32d7cca4c904ddd08fe&#34;&gt;Test the static site with nginx&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s deploy the site with nginx locally (you&amp;rsquo;ll need nginx installed for this). First create the virtual host file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;server {
    listen 80;
    server_name localhost;
    root /var/www/MyApp/static;
    location / {
        index index.html;
        rewrite ^/$ /index.html break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assuming a unix-like platform, save the virtual host file to &amp;ldquo;/etc/nginx/sites-available/localhost&amp;rdquo;. Next enter these commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ sudo mkdir /var/www/MyApp
$ sudo cp static /var/www/MyApp
$ cd /etc/nginx/sites-enabled
$ sudo ln -s ../sites-available/localhost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to start nginx. On RHEL/Fedora/CentOS you can start nginx with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ sudo nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On Ubuntu:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sudo service nginx start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now check out the site at &lt;a href=&#34;http://localhost:&#34;&gt;http://localhost:&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/102/dancer2.png&#34; alt=&#34;The default Dancer app - statically deployed&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Looks pretty good to me!&lt;/p&gt;

&lt;h3 id=&#34;wallflower-tips:29419c887d0bf32d7cca4c904ddd08fe&#34;&gt;Wallflower Tips&lt;/h3&gt;

&lt;p&gt;A few things I&amp;rsquo;ve found whilst using Wallflower:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use absolute urls over relative ones. So if you host your font files in your css directory, use: &amp;ldquo;/css/MyFont.ttf&amp;rdquo; instead of &amp;ldquo;MyFont.ttf&amp;rdquo; in your css files.&lt;/li&gt;
&lt;li&gt;Think about files you use but aren&amp;rsquo;t directly linked to in your app&amp;rsquo;s HTML pages, the sitemap.xml file for example. Feed urls for these files to Wallflower with the -F option.&lt;/li&gt;
&lt;li&gt;Watch out for urls in commented code as Wallflower will copy these too!&lt;/li&gt;
&lt;li&gt;The Wallflower docs recommend using extensions in your urls to ensure the correct content-type is set. I found this wasn&amp;rsquo;t required when I deployed the files with nginx.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;conclusion:29419c887d0bf32d7cca4c904ddd08fe&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Whether you prefer developing applications with Catalyst, Dancer or Mojolicious, Wallflower is a useful tool that can be incorporated into your development and deployment process. For further examples of Wallflower in action, check out the &lt;a href=&#34;https://metacpan.org/pod/Wallflower::Tutorial&#34;&gt;tutorial&lt;/a&gt; and advent calendar &lt;a href=&#34;http://www.perladvent.org/2012/2012-12-22.html&#34;&gt;entry&lt;/a&gt; by Wallflower creator Philippe Bruhat (BooK).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Cover image &lt;a href=&#34;http://creativecommons.org/licenses/by/4.0/&#34;&gt;©&lt;/a&gt; &lt;a href=&#34;https://www.flickr.com/photos/ruthanddave/9432335346/in/photolist-9YgULK-6CwkPH-m68vYZ-4P7TsV-4Pc9dL-7UqEXc-8rbEQq-mPFbgf-Hw6fU-2JcQ24-7ZdMJc-5q1xn5-fnvbFu-fpNhu5-bY6j7J-6HC9cQ-7Y666Z-4RGjZ5-c5bJ5A-5Ma2Kx-7UshUJ-buamir-qLy2D-26mzb-nUfKdk-818aoT-4ne9U5-azaNvR-c7Ztsj-sbu9W-4hrgcG-8r8yrv-hdmVrd-a72iqb-4Kebyi-aEpfqd-6cdRLZ-7iqNqm-6XsteA-b8crZZ-ubPgJ-8pBxDZ-6R63RH-6AnSCX-byKj2-8b97G8-d6X7B-dddPtT-6pUqhf-ejhHg3|&#34;&gt;Ruth Hartnup&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Just how much heavier is Catalyst than Dancer2?</title>
      <link>http://perltricks.com/article/85/2014/5/5/Just-how-much-heavier-is-Catalyst-than-Dancer2-/</link>
      <pubDate>Mon, 05 May 2014 12:29:09 +0000</pubDate>
      
      <guid>http://perltricks.com/article/85/2014/5/5/Just-how-much-heavier-is-Catalyst-than-Dancer2-/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Within the Perl community it is received wisdom that Catalyst is a heavyweight web framework with many dependencies and that Dancer2 is a micro web framework that&amp;rsquo;s more agile than a Cirque du Soleil acrobat. But is it true?&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;tech-specs:e19552eba592fbca5a97d9be32189ba0&#34;&gt;Tech Specs&lt;/h3&gt;

&lt;p&gt;The comparison was between &lt;a href=&#34;https://metacpan.org/pod/release/JJNAPIORK/Catalyst-Runtime-5.90062/lib/Catalyst/Runtime.pm&#34;&gt;Catalyst 5.90062&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/release/XSAWYERX/Dancer2-0.140000&#34;&gt;Dancer2 0.14&lt;/a&gt;. For local tests the machine used was a 2011 MacBook Air running Fedora 19 and Perl 5.16.3.&lt;/p&gt;

&lt;h3 id=&#34;number-of-dependencies:e19552eba592fbca5a97d9be32189ba0&#34;&gt;Number of Dependencies&lt;/h3&gt;

&lt;p&gt;The greatest perceived difference between Catalyst and Dancer2 is the number of dependencies each has, with Catalyst being thought to have &amp;ldquo;too many&amp;rdquo;. For example at the recent German Perl workshop, Dancer2 development lead Sawyer X &lt;a href=&#34;http://www.youtube.com/watch?v=91xDp_Eus5c&amp;amp;t=12m09s&#34;&gt;joked&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We&amp;rsquo;re not pulling off half of CPAN like maybe a different web framework [Catalyst]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To compare the two frameworks, we need to compare all of their dependencies; not just those first-order dependencies used by the framework, but also those used by the modules used by the framework and so on. Fortunately this is an easy comparison to make using &lt;a href=&#34;https://stratopan.com/&#34;&gt;Stratopan&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I created two stacks, one for &lt;a href=&#34;https://stratopan.com/sillymoose/WebStuff/Catalyst/graphs&#34;&gt;Catalyst&lt;/a&gt; and one for &lt;a href=&#34;https://stratopan.com/sillymoose/WebStuff/Dancer2/graphs&#34;&gt;Dancer2&lt;/a&gt;. Their respective dependency graphs are shown below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/85/catalyst%20dependencies.png&#34; alt=&#34;Catalyst framework&#34; /&gt;
&lt;img src=&#34;http://perltricks.com/images/85/dancer2%20dependencies.png&#34; alt=&#34;Dancer2 framework&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Tabulating the Stratopan data for the two stacks we get:&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;33%&#34; /&gt;
&lt;col width=&#34;33%&#34; /&gt;
&lt;col width=&#34;33%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;Framework&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Direct Dependencies&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Recursive Dependencies&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Catalyst&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;44&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;114&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;Dancer2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;29&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;96&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;+15&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;+18&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Stratopan reveals that while Catalyst required 15 more modules than Dancer2 (+52%), when considering recursive dependencies, the Catalyst stack is only 19% larger than the Dancer2 stack. Interestingly, over 61% of the 96 distributions Dancer2 uses are used by Catalyst.&lt;/p&gt;

&lt;h3 id=&#34;testing:e19552eba592fbca5a97d9be32189ba0&#34;&gt;Testing&lt;/h3&gt;

&lt;p&gt;When installing a CPAN module, the module tests usually take the longest time of the installation process and can contribute to the perceived &amp;ldquo;size&amp;rdquo; of the module. As the maturer framework, perhaps Catalyst simply has more tests than Dancer2, and therefore it&amp;rsquo;s installation process takes longer?&lt;/p&gt;

&lt;p&gt;To check for this, I tested both frameworks installation tests:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl Makefile.PL
$ make
$ make test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Catalyst&amp;rsquo;s test results:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;Files=166, Tests=3374, 179 wallclock secs ( 0.85 usr  0.16 sys + 172.95 cusr  4.56 csys = 178.52 CPU)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dancer2&amp;rsquo;s results:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;Files=78, Tests=1112, 21 wallclock secs ( 0.38 usr  0.07 sys + 19.68 cusr  1.46 csys = 21.59 CPU)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These results show that Catalyst ran 3,374 tests over 3 minutes compared to Dancer2&amp;rsquo;s 1,112 tests over 21 seconds. So while Catalyst did run more tests, it was also slower in executing them; Dancer2 executed 53 tests per second and Catalyst managed 19 tests per second.&lt;/p&gt;

&lt;p&gt;What would explain this discrepancy? Perhaps Dancer2 has more trivial tests that run quicker than Catalyst&amp;rsquo;s tests. As a control I checked the code coverage of each framework&amp;rsquo;s test suite using &lt;a href=&#34;https://metacpan.org/pod/Devel::Cover&#34;&gt;Devel::Cover&lt;/a&gt;. Dancer2&amp;rsquo;s total test coverage was 84.7% whilst Catalyst&amp;rsquo;s was 85.5% - a negligible difference.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:e19552eba592fbca5a97d9be32189ba0&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;So is Catalyst&amp;rsquo;s &amp;ldquo;heavyweight&amp;rdquo; reputation deserved? Whilst it does not have a significantly greater number of dependencies than Dancer2, during installation Dancer2&amp;rsquo;s test suite runs far faster than Catalyst&amp;rsquo;s and with a similar code coverage. This doesn&amp;rsquo;t mean Dancer2&amp;rsquo;s test suite is better than Catalyst&amp;rsquo;s (Catalyst&amp;rsquo;s test suite could have higher cyclomatic complexity). But it does show that Dancer2&amp;rsquo;s simpler micro-framework approach offers benefits beyond fast startups and application development time. As a Catalyst user, I&amp;rsquo;ve found Catalyst to be plenty fast for my needs (like PerlTricks.com), however its startup time is noticeably slow and during installation tests the Catalyst test application is started and stopped multiple times. I expect that contributes more to discrepancy in installation times between Dancer2 and Catalyst than anything else.&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F85%2F2014%2F5%2F5%2FJust-how-much-heavier-is-Catalyst-than-Dancer2-&amp;amp;text=Just+how+much+heavier+is+Catalyst+than+Dancer2%3F&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F85%2F2014%2F5%2F5%2FJust-how-much-heavier-is-Catalyst-than-Dancer2-&amp;amp;via=perltricks&#34;&gt;tweet&lt;/a&gt; about it!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simple web framework FastCGI caching with nginx - part 2</title>
      <link>http://perltricks.com/article/77/2014/3/17/Simple-web-framework-FastCGI-caching-with-nginx---part-2/</link>
      <pubDate>Mon, 17 Mar 2014 01:54:09 +0000</pubDate>
      
      <guid>http://perltricks.com/article/77/2014/3/17/Simple-web-framework-FastCGI-caching-with-nginx---part-2/</guid>
      <description>

&lt;p&gt;&lt;em&gt;In &lt;a href=&#34;http://perltricks.com/article/76/2014/3/11/Simple-web-framework-FastCGI-caching-with-nginx-part-1&#34;&gt;part 1&lt;/a&gt; of this series, we covered how to cache FastCGI responses with nginx and how to purge the cache on demand. We saw how easy it is to setup caching with the main Perl web frameworks (Catalyst, Dancer and Mojolicious). In this article we&amp;rsquo;ll use Nginx::FastCGI::Cache to manage our cached responses and gain some useful benefits along the way.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;requirements:fa5e57e16e5afa820891a6788e36f753&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ll need Perl v5.12.3 or greater to install &lt;a href=&#34;https://metacpan.org/pod/Nginx::FastCGI::Cache&#34;&gt;Nginx::FastCGI::Cache&lt;/a&gt;. The CPAN Testers &lt;a href=&#34;http://matrix.cpantesters.org/?dist=Nginx-FastCGI-Cache+0.008&#34;&gt;results&lt;/a&gt; show that it runs on most platforms including Windows. To install the module using CPAN, just open the terminal and type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpan Nginx::FastCGI::Cache
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;nginx-fastcgi-caching-explained:fa5e57e16e5afa820891a6788e36f753&#34;&gt;nginx fastcgi caching explained&lt;/h3&gt;

&lt;p&gt;In an nginx virtual host file, the &amp;ldquo;fastcgi_cache_path&amp;rdquo; directive sets the root directory from where nginx will build the cache. nginx uses the variables of the &amp;ldquo;fastcgi_cache_key&amp;rdquo; directive to create an md5 hexadecimal hash key as the filename. The &amp;ldquo;levels&amp;rdquo; value determines the number of subdirectories and the subdirectories name length. For example, with this configuration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;fastcgi_cache_path  /var/cache/nginx levels=1:2
                    keys_zone=app_cache:50m
                    inactive=60m;
fastcgi_cache_key &amp;quot;$scheme$request_method$host$request_uri&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A GET request for &amp;ldquo;&lt;a href=&#34;http://perltricks.com/&amp;quot;&#34;&gt;http://perltricks.com/&amp;quot;&lt;/a&gt; would have a key of &amp;ldquo;httpGETperltricks.com/&amp;rdquo;, and be stored at: &amp;ldquo;/var/cache/nginx/4/85/200d51ef65b0a76de421f8f1ec047854&amp;rdquo;. Note that the name of the first subdirectory is the last letter of the md5 hash (&amp;ldquo;4&amp;rdquo;) and the second subdirectory name the previous two letters (&amp;ldquo;85&amp;rdquo;) - this is because of the levels value of &amp;ldquo;1:2&amp;rdquo; set in the nginx virtual host file. Deleting the file &amp;ldquo;/var/cache/nginx/4/85/200d51ef65b0a76de421f8f1ec047854 will purge it from nginx&amp;rsquo;s cache.&lt;/p&gt;

&lt;h3 id=&#34;introducing-nginx-fastcgi-cache:fa5e57e16e5afa820891a6788e36f753&#34;&gt;Introducing Nginx::FastCGI::Cache&lt;/h3&gt;

&lt;p&gt;I wrote &lt;a href=&#34;https://metacpan.org/pod/Nginx::FastCGI::Cache&#34;&gt;Nginx::FastCGI::Cache&lt;/a&gt; to make it easy to purge individually cached fastcgi responses from the nginx cache. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Nginx::FastCGI::Cache;
 
my $nginx_cache = Nginx::FastCGI::Cache-&amp;gt;new({ location =&amp;gt; &#39;/var/cache/nginx&#39; });
$nginx_cache-&amp;gt;purge_file(&amp;quot;http://perltricks.com/&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will convert the URL into the md5 hashed cache key, and delete it from the nginx cache directory. By default &amp;ldquo;purge_file&amp;rdquo; assumes the HTTP request type is GET. If you want to purge a file for a different request type, simply include it as a parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$nginx_cache-&amp;gt;purge_file(&amp;quot;http://perltricks.com/&amp;quot;, &amp;quot;HEAD&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to blow away the whole cache, use the &amp;ldquo;purge_cache&amp;rdquo; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$nginx_cache-&amp;gt;purge_cache;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These two methods should be all that&amp;rsquo;s required to conveniently manage the nginx cache from your favourite Perl web application.&lt;/p&gt;

&lt;h3 id=&#34;portability:fa5e57e16e5afa820891a6788e36f753&#34;&gt;Portability&lt;/h3&gt;

&lt;p&gt;In part 1 our purge cache code used a system call to the GNU find program to delete all the files in the cache. Whilst this is fine as a quick hack, using an external program limits the portability of the code (it wouldn&amp;rsquo;t run on Windows for example). Nginx::FastCGI::Cache uses Perl&amp;rsquo;s opendir and unlink functions to read the cache directory and delete files, which should work on all platforms that Perl runs on.&lt;/p&gt;

&lt;h3 id=&#34;safety-first:fa5e57e16e5afa820891a6788e36f753&#34;&gt;Safety First&lt;/h3&gt;

&lt;p&gt;Whenever you have a program that is going to recursively delete all files in a directory, you want to be sure that it&amp;rsquo;s looking at the correct directory. That&amp;rsquo;s why the &amp;ldquo;location&amp;rdquo; is a mandatory parameter for the Nginx::FastCGI::Cache constructor - no default location is assumed. Additionally, should the Perl process not have sufficient permissions to read the cache directory or delete a cached file, Nginx::FastCGI::Cache will &lt;a href=&#34;http://perldoc.perl.org/Carp.html#NAME&#34;&gt;croak&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;other-nginx-considerations:fa5e57e16e5afa820891a6788e36f753&#34;&gt;Other nginx considerations&lt;/h3&gt;

&lt;p&gt;By default, nginx will not cache a fastcgi response that includes a &amp;ldquo;Set-Cookie&amp;rdquo; header. Depending on how you are using cookies, you may want to have nginx cache the response and ignore the &amp;ldquo;Set-Cookie&amp;rdquo; header. This can be done by adding this line to your virtual host file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;fastcgi_ignore_headers &amp;quot;Set-Cookie&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bear in mind that the &amp;ldquo;set-Cookie&amp;rdquo; header will be removed from the response altogether, so this is useful when serving uniform responses that do not distinguish between users with session cookies and those without.&lt;/p&gt;

&lt;p&gt;By default nginx will only cache GET and HEAD requests. This is a good default, but you may want to restrict the cache to just GET responses, or enable other kinds of HTTP requests such as POST. If so, add the fastcgi_cache_methods directive to your nginx virtual host file. For example to only cache GET requests:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;fastcgi_cache_methods GET;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The nginx &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&#34;&gt;documentation&lt;/a&gt; provides comprehensive detail on the fastcgi module.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:fa5e57e16e5afa820891a6788e36f753&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Whether you are using Catalyst, Dancer or Mojolicious, setting the appropriate caching headers is easy (see &lt;a href=&#34;http://perltricks.com/article/76/2014/3/11/Simple-web-framework-FastCGI-caching-with-nginx-part-1&#34;&gt;part 1&lt;/a&gt;). Consider using &lt;a href=&#34;https://metacpan.org/pod/Nginx::FastCGI::Cache&#34;&gt;Nginx::FastCGI::Cache&lt;/a&gt; with nginx to conveniently purge the cache on demand.&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F77%2F2014%2F3%2F16%2FSimple-web-framework-FastCGI-caching-with-nginx-part-2&amp;amp;text=Simple+web+framework+FastCGI+caching+with+nginx+-+part+2&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F77%2F2014%2F3%2F16%2FSimple-web-framework-FastCGI-caching-with-nginx-part-2&amp;amp;via=perltricks&#34;&gt;retweet&lt;/a&gt; it!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simple web framework FastCGI caching with nginx - part 1</title>
      <link>http://perltricks.com/article/76/2014/3/11/Simple-web-framework-FastCGI-caching-with-nginx---part-1/</link>
      <pubDate>Tue, 11 Mar 2014 03:18:00 +0000</pubDate>
      
      <guid>http://perltricks.com/article/76/2014/3/11/Simple-web-framework-FastCGI-caching-with-nginx---part-1/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Fastcgi server caching is a wonderful technique for improving response times and reducing load on a web application. In part 1 of this series we look at how to cache responses with Catalyst, Dancer and Mojolocious and how to clear the cache on-demand when using the nginx web server. Before you know it, your web application will be faster than a racing llama!&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;fastcgi-server-caching-explained:8c253a4acb451f68f821b231698a79ac&#34;&gt;FastCGI server caching explained&lt;/h3&gt;

&lt;p&gt;FastCGI server caching is when the FastCGI application sets a caching header in its response to an upstream server. The &lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.3&#34;&gt;max-age header&lt;/a&gt; defines in seconds from the time of the request how long to cache the response message for. If it&amp;rsquo;s correctly configured, the upstream server will cache the response, and for the duration of the max-age value, return the cached response to all requests to the same URL. As a bonus the max-age header can be passed back to the requester, and it will be cached in their browser as well.&lt;/p&gt;

&lt;p&gt;FastCGI server caching brings the following benefits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cut response times by as much as 95%.&lt;/li&gt;
&lt;li&gt;Reduce load on the the FastCGI application (imagine 1 request per hour per URL).&lt;/li&gt;
&lt;li&gt;Reduce load on the the web server with browser caching.&lt;/li&gt;
&lt;li&gt;Avoid corrupt memory risks of simultaneous read/write when caching responses in the FastCGI application.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;how-to-cache-your-catalyst-mojolicious-dancer-response:8c253a4acb451f68f821b231698a79ac&#34;&gt;How to cache your Catalyst / Mojolicious / Dancer response&lt;/h3&gt;

&lt;p&gt;All of the major Perl frameworks support server caching and the good news is it&amp;rsquo;s easy to implement. For example, if $seconds is number of seconds to cache the response for, in Catalyst add this line to a controller method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$c-&amp;gt;response-&amp;gt;header(&#39;Cache-Control&#39; =&amp;gt; &amp;quot;max-age=$seconds&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Mojolicious, add this code to your controller action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$self-&amp;gt;res-&amp;gt;headers-&amp;gt;cache_control(&#39;max-age=$seconds&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And for Dancer, update a route with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;header &#39;max-age&#39; =&amp;gt; &#39;$seconds&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;how-to-setup-nginx-fastcgi-caching:8c253a4acb451f68f821b231698a79ac&#34;&gt;How to setup nginx FastCGI caching&lt;/h3&gt;

&lt;p&gt;To enable nginx caching, add the fastcgi cache directives to to your virtual host config file. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;fastcgi_cache_path  /var/nginx/cache levels=1:2
                    keys_zone=fcgi_cache:50m
                    inactive=60m;
fastcgi_cache_key &amp;quot;$scheme$request_method$host$request_uri&amp;quot;;
fastcgi_buffers 256 4k; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code specifies the cache directory, zone name, cache key and buffers (see the &lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html&#34;&gt;manual&lt;/a&gt; for details). The code should be outside your server declaration. Within your server declaration, add:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;fastcgi_cache fcgi_cache;
fastcgi_cache_valid 200 1s;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code defines the cache zone to use (&amp;ldquo;fcgi_cache&amp;rdquo;), sets the cache size to 200mb and by default caches a response for 1 second. The max-age header will override the default cache time, but you may want to choose a value other than 1 second, depending on your application&amp;rsquo;s needs. Here is a complete example virtual host file with fastcgi caching:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;fastcgi_cache_path  /var/nginx/cache levels=1:2
                    keys_zone=PerlTricks:50m
                    inactive=60m;
fastcgi_cache_key &amp;quot;$scheme$request_method$host$request_uri&amp;quot;;
fastcgi_buffers 256 4k;

server {
    listen 80 default;
    server_name perltricks.com;
    try_files $uri @fcgi;
    location @fcgi {
        fastcgi_cache PerlTricks;
        fastcgi_cache_valid 200 5m;
        fastcgi_pass unix:/tmp/perltricks.socket;
        include /etc/nginx/fastcgi.conf;
        fastcgi_param SCRIPT_NAME /;
    }   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For an in-depth look at the configuring the nginx fastcgi cache, check out this &lt;a href=&#34;https://www.digitalocean.com/community/articles/how-to-setup-fastcgi-caching-with-nginx-on-your-vps&#34;&gt;useful article&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;clearing-the-cache:8c253a4acb451f68f821b231698a79ac&#34;&gt;Clearing the cache&lt;/h3&gt;

&lt;p&gt;Whilst caching responses can deliver huge benefits, it would be nice to be able to clear the cache on-demand, in case the application state changes. Fortunately with nginx this is super-easy with Perl - all you have to do is delete all files in the fastcgi_cache_path declared in the virtual host config file. For example, on Unix-based systems this works:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub clear_cache {
    if (-e &#39;/var/nginx/cache&#39;) {
        system(&#39;find /var/nginx/cache -type f -exec rm -f {} \;&#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion:8c253a4acb451f68f821b231698a79ac&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;All of the major Perl web frameworks support FastCGI server caching. It&amp;rsquo;s easy to set up and with nginx, easy to manage. However there is more that can be done: in part 2 of this series we&amp;rsquo;ll make our cache management more precise by adding the ability to clear specific URL responses from the cache, rather than obliterating the whole cache in one go. We&amp;rsquo;ll also look at how to make the &amp;ldquo;clear_cache&amp;rdquo; subroutine safer and Windows compatible.&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F76%2F2014%2F3%2F11%2FSimple-web-framework-FastCGI-caching-with-nginx-part-1&amp;amp;text=Simple+web+framework+FastCGI+caching+with+nginx+-+part+1&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F76%2F2014%2F3%2F11%2FSimple-web-framework-FastCGI-caching-with-nginx-part-1&amp;amp;via=perltricks&#34;&gt;retweet&lt;/a&gt; it!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Cover picture © David Hoshor licensed via &lt;a href=&#34;http://creativecommons.org/licenses/by/2.0/&#34;&gt;Creative Commons&lt;/a&gt;. The picture has been digitally enhanced.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Download a YouTube video with one line of Perl</title>
      <link>http://perltricks.com/article/63/2014/1/26/Download-a-YouTube-video-with-one-line-of-Perl/</link>
      <pubDate>Sun, 26 Jan 2014 22:41:17 +0000</pubDate>
      
      <guid>http://perltricks.com/article/63/2014/1/26/Download-a-YouTube-video-with-one-line-of-Perl/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Downloading YouTube videos with Perl is easy when you&amp;rsquo;re packing the right module. That module is &lt;a href=&#34;https://metacpan.org/pod/WWW::YouTube::Download&#34;&gt;WWW::YouTube::Download&lt;/a&gt;. Here&amp;rsquo;s how you can download a video in one line of Perl.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;*&lt;strong&gt;Edit&lt;/strong&gt; - this article was updated on 27/1/2014 to describe the &amp;ldquo;youtube-download&amp;rdquo; app that comes with WWW::YouTube::Download.*&lt;/p&gt;

&lt;h3 id=&#34;warning:530784e281eacfc273aaf409e299faae&#34;&gt;Warning&lt;/h3&gt;

&lt;p&gt;You should only download videos which you have permission to do so. The following is just an example of how to do this, when you have permission.&lt;/p&gt;

&lt;h3 id=&#34;requirements:530784e281eacfc273aaf409e299faae&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ll need to install WWW::YouTube::Download. The CPAN Testers &lt;a href=&#34;http://matrix.cpantesters.org/?dist=WWW-YouTube-Download+0.56&#34;&gt;results&lt;/a&gt; for the latest version (0.56 at the time of writing) show that it runs on all major platforms.&lt;/p&gt;

&lt;p&gt;You can install the module via CPAN at the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpan WWW:YouTube::Download
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;use-the-youtube-download-app:530784e281eacfc273aaf409e299faae&#34;&gt;Use the youtube-download app&lt;/h3&gt;

&lt;p&gt;When you install WWW::YouTube::Download, it comes with a command-line app, &amp;ldquo;youtube-download&amp;rdquo;. Using it couldn&amp;rsquo;t be easier. Simply open the command line and type the program name with the URL or video id of the video to download. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ youtube-download http://www.youtube.com/watch?v=ju1IMxGSuNE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*&lt;strong&gt;NB&lt;/strong&gt; - using the app as shown above is the easiest way to use the tool - however at the time of writing I was not aware of the command line tool. Read on for the one liner example.*&lt;/p&gt;

&lt;h3 id=&#34;download-a-video-in-one-line-of-perl:530784e281eacfc273aaf409e299faae&#34;&gt;Download a video in one line of Perl&lt;/h3&gt;

&lt;p&gt;At the command line, type or paste the following command, replacing $id with the id of the video you want to download:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl -MWWW::YouTube::Download -e &#39;WWW::YouTube::Download-&amp;gt;new-&amp;gt;download(q/$id/)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;explaining-the-one-liner:530784e281eacfc273aaf409e299faae&#34;&gt;Explaining the one liner&lt;/h3&gt;

&lt;p&gt;This one liner is simple. First we load WWW::YouTube::Download using the &amp;ldquo;-M&amp;rdquo; switch. Then the &amp;ldquo;-e&amp;rdquo; switch tells Perl to execute the code between the apostrophes. We then initiate a WWW::YouTube::Download object with new, and immediately call the &lt;a href=&#34;https://metacpan.org/pod/WWW::YouTube::Download#download-video_id-args&#34;&gt;download&lt;/a&gt; method on the new object. We use the quoting construct &amp;ldquo;q//&amp;rdquo; to quote strings without using quote marks as this makes the one liner more cross-platform compatible.&lt;/p&gt;

&lt;h3 id=&#34;on-windows:530784e281eacfc273aaf409e299faae&#34;&gt;On Windows&lt;/h3&gt;

&lt;p&gt;On Windows, you&amp;rsquo;ll need to replace the apostrophes with double quotes (&amp;ldquo;).&lt;/p&gt;

&lt;h3 id=&#34;how-to-get-the-video-id:530784e281eacfc273aaf409e299faae&#34;&gt;How to get the video id&lt;/h3&gt;

&lt;p&gt;The video id is the alphanumeric code value for &amp;ldquo;v&amp;rdquo; in the URL of the video you want to download. For example with this URL:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;http://www.youtube.com/watch?v=ju1IMxGSuNE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;ju1IMxGSuNE&amp;rdquo; is the video id, because if you look in the URL after the question mark, v=ju1IMxGSuNE, which means &amp;ldquo;the value for v equals ju1IMxGSuNE&amp;rdquo;. If you have a URL but can&amp;rsquo;t work out the video id, WWW::YouTube::Download provides a video_id method. This one liner will print out the video id, just replace $url with the actual YouTube URL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl -MWWW::YouTube::Download -E &#39;say WWW::YouTube::Download-&amp;gt;new-&amp;gt;video_id(q{$url})&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-perl-script-to-download-youtube-videos:530784e281eacfc273aaf409e299faae&#34;&gt;A Perl script to download YouTube videos&lt;/h3&gt;

&lt;p&gt;We can expand the concepts used in the one liner into a fully-fledged Perl script, called &amp;ldquo;download.pl&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;#!/usr/bin/env perl
use strict;
use warnings;
use WWW::YouTube::Download;

if (@ARGV) {
    my $tube = WWW::YouTube::Download-&amp;gt;new;
    my $video_id = $tube-&amp;gt;video_id($ARGV[0]);
    $tube-&amp;gt;download($video_id, { filename =&amp;gt; &#39;{title}{suffix}&#39; }); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The script takes a YouTube URL as an argument. It gets the video id of the URL, then downloads the video into the current directory. As an added bonus, the script will save the file with the title of the video, instead of the default which is the video id. You can run the script at the command line, passing the URL of the YouTube video to download. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ ./download.pl http://www.youtube.com/watch?v=ju1IMxGSuNE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may need to set the script&amp;rsquo;s permissions to executable using chmod:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ chmod 755 download.pl
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion:530784e281eacfc273aaf409e299faae&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;WWW::YouTube::Download is easy to use, fast and just works. The module&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/WWW::YouTube::Download&#34;&gt;documentation&lt;/a&gt; is easy to follow. Thanks to Yuji Shimada for writing it!&lt;/p&gt;

&lt;p&gt;There is more to WWW::YouTube::Download than shown here - one interesting feature is that you can specify the video format (if more than one is available). By default the module downloads the highest quality video available.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Display beautiful Perl code in HTML without JavaScript</title>
      <link>http://perltricks.com/article/60/2014/1/13/Display-beautiful-Perl-code-in-HTML-without-JavaScript/</link>
      <pubDate>Mon, 13 Jan 2014 01:34:32 +0000</pubDate>
      
      <guid>http://perltricks.com/article/60/2014/1/13/Display-beautiful-Perl-code-in-HTML-without-JavaScript/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Would you like to display beautiful syntax-highlighted Perl code on the web without using JavaScript? Maybe you&amp;rsquo;d like to use an existing &lt;a href=&#34;http://google-code-prettify.googlecode.com/svn/trunk/styles/index.html&#34;&gt;CSS markup theme&lt;/a&gt; without having to write in-line CSS in your Perl code? If yes, take a look at &lt;a href=&#34;https://metacpan.org/pod/PPI::Prettify&#34;&gt;PPI::Prettify&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;background:74c69b2f99de951b26ebaa1f686e5212&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://code.google.com/p/google-code-prettify/&#34;&gt;prettify.js&lt;/a&gt; library does a wonderful job of robustly syntax coloring a large number of different languages for displaying code on the web. It&amp;rsquo;s used on blogs.perl.org; we use it on PerlTricks.com. But because Perl is an ambiguous language, prettify.js often doesn&amp;rsquo;t tokenize all of the code correctly. What&amp;rsquo;s worse is if a user has JavaScript disabled, the code will not be highlighted at all. That&amp;rsquo;s why I wrote &lt;a href=&#34;https://metacpan.org/pod/PPI::Prettify&#34;&gt;PPI::Prettify&lt;/a&gt;. It runs in the backend using PPI::Document so it&amp;rsquo;s faster more accurate than prettify.js, but outputs the same HTML codes as prettify.js does, enabling you to re-use any of the existing CSS themes available (&lt;a href=&#34;http://google-code-prettify.googlecode.com/svn/trunk/styles/index.html&#34;&gt;here&lt;/a&gt;, &lt;a href=&#34;%0Ahttp://jmblog.github.io/color-themes-for-google-code-prettify/&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;%0Ahttp://stanleyhlng.com/prettify-js/#theme-bootstrap-light&#34;&gt;here&lt;/a&gt; for example).&lt;/p&gt;

&lt;h3 id=&#34;requirements:74c69b2f99de951b26ebaa1f686e5212&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ll need PPI::Prettify and can install it via CPAN at the terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpan PPI::Prettify
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In terms of OS compatibility, PPI::Prettify is pure-Perl so you should be able to run it on any platform that has Perl installed.&lt;/p&gt;

&lt;h3 id=&#34;tokenizing-inline-perl-code:74c69b2f99de951b26ebaa1f686e5212&#34;&gt;Tokenizing inline Perl code&lt;/h3&gt;

&lt;p&gt;PPI::Prettify exports a prettify() method that takes a string of Perl code, and returns it tokenized with &amp;lt;span&amp;gt; tags. To be safe, PPI::Prettify employs HTML encoding on all token content. Let&amp;rsquo;s whip up a quick script to demo prettify():&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use warnings;
use strict;
use PPI::Prettify;

read(main::DATA, my $code, 500);

print prettify({ code =&amp;gt; $code });

__DATA__
# a simple OO class

package Shape;

sub new {
    my ($class, $args) = @_;
    my $self = {
        color  =&amp;gt; $args-&amp;gt;{color} || &#39;black&#39;,
        length =&amp;gt; $args-&amp;gt;{length} || 1,
        width  =&amp;gt; $args-&amp;gt;{width} || 1,
    };
    return bless $self, $class;
}

sub get_area {
    my $self = shift;
    return $self-&amp;gt;{length} * $self-&amp;gt;{width};
}

sub get_color {
    my $self = shift;
    return $self-&amp;gt;{color};
}

sub set_color {
    my ($self, $color) = @_;
    $self-&amp;gt;{color} = $color;
}

1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The script uses the &lt;a href=&#34;http://perltricks.com/article/24/2013/5/11/Perl-tokens-you-should-know&#34;&gt;__DATA__&lt;/a&gt; token to create a filehandle to some inline Perl code (The code is a simple OO example taken from our article &lt;a href=&#34;http://perltricks.com/article/25/2013/5/20/Old-School-Object-Oriented-Perl&#34;&gt;Old School Object Oriented Perl&lt;/a&gt;). The read function slurps the filehandle contents into $code. We then use the prettify() function to tokenize and markup the Perl code.&lt;/p&gt;

&lt;p&gt;Running that script returns the Perl code surrounded by &amp;lt;span&amp;gt; tags. This is a summary of the markup produced by prettify():&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;lt;pre class=&amp;quot;prettyprint&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;com&amp;quot;&amp;gt;# a simple OO class
&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;pln&amp;quot;&amp;gt;
&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;kwd&amp;quot;&amp;gt;package&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;pln&amp;quot;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;atn&amp;quot;&amp;gt;Shape&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;pln&amp;quot;&amp;gt;;&amp;lt;/span&amp;gt;
...
&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example below shows how the markup looks in HTML (using the &lt;a href=&#34;http://code.google.com/p/google-code-prettify/source/browse/trunk/styles/desert.css?r=198&#34;&gt;desert&lt;/a&gt; CSS theme).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# a simple OO class

package Shape;

sub new {
    my ($class, $args) = @_;
    my $self = {
        color  =&amp;gt; $args-&amp;gt;{color} || &#39;black&#39;,
        length =&amp;gt; $args-&amp;gt;{length} || 1,
        width  =&amp;gt; $args-&amp;gt;{width} || 1,
    };
    return bless $self, $class;
}

sub get_area {
    my $self = shift;
    return $self-&amp;gt;{length} * $self-&amp;gt;{width};
}

sub get_color {
    my $self = shift;
    return $self-&amp;gt;{color};
}

sub set_color {
    my ($self, $color) = @_;
    $self-&amp;gt;{color} = $color;
}

1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two things to note here: disabling JavaScript will have no effect on the syntax highlighting above, as it&amp;rsquo;s generated in backend using PPI::Prettify. Second, the code displays multiline comments correctly, (everything after &lt;a href=&#34;http://perltricks.com/article/24/2013/5/11/Perl-tokens-you-should-know&#34;&gt;__DATA__&lt;/a&gt;) unlike prettify.js.&lt;/p&gt;

&lt;h3 id=&#34;tokenizing-perl-code-stored-in-a-file:74c69b2f99de951b26ebaa1f686e5212&#34;&gt;Tokenizing Perl code stored in a file&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s easy to prettify existing Perl code from a file. You can do this in one line of Perl at the terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl -MPPI::Prettify -MFile::Slurp -e &#39;$code=read_file(&amp;quot;output&amp;quot;);print prettify({code=&amp;gt;$code})&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;advanced-feature-1-debug-mode:74c69b2f99de951b26ebaa1f686e5212&#34;&gt;Advanced feature 1: debug mode&lt;/h3&gt;

&lt;p&gt;The prettify() method also takes an optional debug parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $html = prettify({ code =&amp;gt; $code, debug =&amp;gt; 1 });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Debug mode will provide the same output, however every tag will be given a &amp;ldquo;title&amp;rdquo; attribute with the original PPI::Token class as the value. This can help you to understand how the original PPI::Token class maps to the markup by hovering the cursor over the text. The code from earlier has been printed with debug mode turned on. Try hovering!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# a simple OO class

package Shape;

sub new {
    my ($class, $args) = @_;
    my $self = {
        color  =&amp;gt; $args-&amp;gt;{color} || &#39;black&#39;,
        length =&amp;gt; $args-&amp;gt;{length} || 1,
        width  =&amp;gt; $args-&amp;gt;{width} || 1,
    };
    return bless $self, $class;
}

sub get_area {
    my $self = shift;
    return $self-&amp;gt;{length} * $self-&amp;gt;{width};
}

sub get_color {
    my $self = shift;
    return $self-&amp;gt;{color};
}

sub set_color {
    my ($self, $color) = @_;
    $self-&amp;gt;{color} = $color;
}

1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;advanced-feature-2-override-the-mapping:74c69b2f99de951b26ebaa1f686e5212&#34;&gt;Advanced feature 2: override the mapping&lt;/h3&gt;

&lt;p&gt;You may want to change how certain tokens of Perl code are marked up. PPI::Prettify exports the mapping in a hashref, called $MARKUP_RULES. Every PPI::Token class is a key, with the value being the CSS class name that prettify.js uses (and the prettify CSS themes expect). For example PPI::Token::Comment is mapped to &amp;ldquo;com&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&#39;PPI::Token::Comment&#39; =&amp;gt; &#39;com&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Combined with debug mode, it should be straightforward to change the mapping of a particular PPI::Token class to the prettify class you require.&lt;/p&gt;

&lt;h3 id=&#34;alternatives:74c69b2f99de951b26ebaa1f686e5212&#34;&gt;Alternatives&lt;/h3&gt;

&lt;p&gt;Consider using Adam Kennedy&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/PPI::HTML&#34;&gt;PPI::HTML&lt;/a&gt; if you are happy writing inline-CSS in your Perl code, or need more detailed markup than the 10 or so classes provided by PPI::Prettify. It&amp;rsquo;s a more mature module and can do line numbering too.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

