<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Perl6 on Perl programming news, code and culture</title>
    <link>http://perltricks.com/categories/perl6/</link>
    <description>Recent content in Perl6 on Perl programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 31 Dec 2015 19:08:59 +0000</lastBuildDate>
    <atom:link href="http://perltricks.com/categories/perl6/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How to get Perl 6 now</title>
      <link>http://perltricks.com/article/207/2015/12/31/How-to-get-Perl-6-now/</link>
      <pubDate>Thu, 31 Dec 2015 19:08:59 +0000</pubDate>
      
      <guid>http://perltricks.com/article/207/2015/12/31/How-to-get-Perl-6-now/</guid>
      <description>

&lt;p&gt;Great news, Perl 6 was &lt;a href=&#34;https://perl6advent.wordpress.com/2015/12/25/christmas-is-here/&#34;&gt;released&lt;/a&gt; on Christmas Day; finally us geeks got something we wanted for Christmas. Send the books back Grandma! (unless you got &lt;a href=&#34;http://perltricks.com/article/205/2015/12/21/Modern-Perl-4th-edition--a-review&#34;&gt;Modern Perl&lt;/a&gt;).&lt;/p&gt;

&lt;h3 id=&#34;installation-on-linux-osx:961206b7582ff32549d5b3ed6ab9aa7e&#34;&gt;Installation on Linux, OSX&lt;/h3&gt;

&lt;p&gt;On Linux and Mac the easiest way to get Perl 6 is with &lt;a href=&#34;https://github.com/tadzik/rakudobrew&#34;&gt;rakudobrew&lt;/a&gt;. You&amp;rsquo;ll need the typical software development tools like &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt;. On OSX Apple&amp;rsquo;s &lt;a href=&#34;https://developer.apple.com/opensource/&#34;&gt;Command Line Tools app&lt;/a&gt; provides most of these and is easy to install. On Linux they&amp;rsquo;re available via the package manager. Once you have the prerequisite tools installed, you can install rakudobrew via the terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ git clone https://github.com/tadzik/rakudobrew ~/.rakudobrew
$ export PATH=~/.rakudobrew/bin:$PATH
$ rakudobrew build moar
$ rakudobrew build panda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will install &lt;code&gt;perl6&lt;/code&gt; and &lt;code&gt;panda&lt;/code&gt; the Perl 6 package manager.&lt;/p&gt;

&lt;h3 id=&#34;installation-on-windows:961206b7582ff32549d5b3ed6ab9aa7e&#34;&gt;Installation on Windows&lt;/h3&gt;

&lt;p&gt;On Windows it&amp;rsquo;s a different story. I was unable to get rakudobrew to work on Windows, which is a shame as it&amp;rsquo;s such a convenient tool. If you&amp;rsquo;re feeling adventurous, you can &lt;a href=&#34;http://perltricks.com/article/135/2014/11/18/Building-Perl-6-with-Visual-Studio-2013&#34;&gt;build your own Perl 6 with Visual Studio&lt;/a&gt;. Sinan Unur has &lt;a href=&#34;https://www.nu42.com/2015/12/perl6-rakudo-released.html&#34;&gt;blogged&lt;/a&gt; about building panda with the same toolset.&lt;/p&gt;

&lt;p&gt;Alternatively you can use the latest &lt;a href=&#34;http://rakudo.org/downloads/star/&#34;&gt;Rakudo Star distribution&lt;/a&gt; which comes with a convenient &lt;code&gt;.msi&lt;/code&gt; installer. Unfortunately the most recent Rakudo Star distribution is from September, so you won&amp;rsquo;t benefit from the last 3 months of updates to Perl 6 (a new version should be available soon). If you&amp;rsquo;ve installed Rakudo Star, you&amp;rsquo;ll need to add the Perl 6 binaries to your path. You can do that using &lt;code&gt;cmd.exe&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; SETX PATH &amp;quot;%PATH%;C:\rakudo\bin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now start a new &lt;code&gt;cmd.exe&lt;/code&gt; terminal, and you&amp;rsquo;ll be use Perl 6. Rakudo Star ships with Panda too, so you&amp;rsquo;ll be able to start installing Perl 6 modules right away.&lt;/p&gt;

&lt;h3 id=&#34;useful-perl-6-resources:961206b7582ff32549d5b3ed6ab9aa7e&#34;&gt;Useful Perl 6 resources&lt;/h3&gt;

&lt;p&gt;So you&amp;rsquo;ve got Perl 6 installed, now what? To keep up to date with Perl 6 developments, I read the &lt;a href=&#34;https://p6weekly.wordpress.com/&#34;&gt;Perl 6 Weekly&lt;/a&gt; blog. The &lt;a href=&#34;http://perlweekly.com/&#34;&gt;Perl Weekly&lt;/a&gt; newsletter also includes Perl 6 articles, so be sure to subscribe if you haven&amp;rsquo;t already. The official website &lt;a href=&#34;http://perl6.org/&#34;&gt;Perl6.org&lt;/a&gt; is a good reference for all things Perl 6 related. Wendy has posted a &lt;a href=&#34;https://wendyga.wordpress.com/2015/12/25/why-would-you-want-to-use-perl-6-some-answers/&#34;&gt;useful list&lt;/a&gt; of Perl 6 features.&lt;/p&gt;

&lt;p&gt;Here at PerlTricks.com, we&amp;rsquo;ve got several Perl 6 articles that may be of interest:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://perltricks.com/article/144/2015/1/13/How-to-create-a-grammar-in-Perl-6&#34;&gt;How to create a Grammar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://perltricks.com/article/170/2015/4/30/Parsing-Perl-5-pod-with-Perl-6&#34;&gt;Parsing Perl 5 Pod with Perl 6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://perltricks.com/article/136/2014/11/20/Get-started-with-Perl-6-one-liners&#34;&gt;Get started with Perl 6 One Liners&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://perltricks.com/article/177/2015/6/9/Get-to-grips-with-Prove--Perl-s-test-workhorse&#34;&gt;How to run Perl 6 tests with prove&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://perltricks.com/article/194/2015/9/22/Activating-Perl-6-syntax-highlighting-in-Vim&#34;&gt;Activate Perl 6 syntax highlighting in Vim&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; - Visual Studio article now includes instructions for VS2015. Added link to nu42.com. 2016-01-04&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Activating Perl 6 syntax highlighting in Vim</title>
      <link>http://perltricks.com/article/194/2015/9/22/Activating-Perl-6-syntax-highlighting-in-Vim/</link>
      <pubDate>Tue, 22 Sep 2015 22:16:48 +0000</pubDate>
      
      <guid>http://perltricks.com/article/194/2015/9/22/Activating-Perl-6-syntax-highlighting-in-Vim/</guid>
      <description>

&lt;p&gt;Modern versions of the Vim text editor ship with Perl 6 syntax highlighting, but automatically activating it is tricky because Perl 6 files can have ambiguous file extensions. It can get tiresome to correct the file type every time you open a Perl 6 file, so I&amp;rsquo;m going to show you a few tricks that I use to make Vim detect Perl 6 files automatically.&lt;/p&gt;

&lt;h3 id=&#34;showing-and-setting-the-filetype-in-vim:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Showing and setting the filetype in Vim&lt;/h3&gt;

&lt;p&gt;First of all I want to make sure that syntax highlighting is turned on by default, so I add this option to my &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;syntax on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To edit your &lt;code&gt;.vimrc&lt;/code&gt; just start Vim and enter this command &lt;code&gt;:e $MYVIMRC&lt;/code&gt;. Save your changes with &lt;code&gt;:w&lt;/code&gt;, and then reload your &lt;code&gt;.vimrc&lt;/code&gt; with &lt;code&gt;:so %&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now that I have syntax highlighting turned on, I need to know how set Vim&amp;rsquo;s file type to Perl 6 when I&amp;rsquo;m working with Perl 6 files. I can see the current file type by typing this command &lt;code&gt;:set filetype?&lt;/code&gt;. To set the file type to Perl 6, I use this command &lt;code&gt;:set filetype=perl6&lt;/code&gt;. The &lt;code&gt;filetype&lt;/code&gt; keyword can be shortened to &lt;code&gt;ft&lt;/code&gt;. In which case the last command becomes &lt;code&gt;:set ft=perl6&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;detecting-perl-6-files:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Detecting Perl 6 files&lt;/h3&gt;

&lt;p&gt;Now the challenge becomes correctly detecting when I&amp;rsquo;m working with Perl 6 files in Vim. Perl 6 scripts shouldn&amp;rsquo;t be a problem: Vim (not Vi) automatically parses the &lt;a href=&#34;https://en.wikipedia.org/wiki/Shebang_line&#34;&gt;shebang&lt;/a&gt; line to determine the file type. However this fails when the script has an extension like &lt;code&gt;.pl&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;use-the-pm6-file-extension:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Use the .pm6 file extension&lt;/h4&gt;

&lt;p&gt;Vim will automatically use Perl 6 syntax highlighting if the file extension is &lt;code&gt;.pm6&lt;/code&gt;. So when working with Perl 6 module files, it&amp;rsquo;s better to use this extension. This doesn&amp;rsquo;t help when I&amp;rsquo;m working on other people&amp;rsquo;s Perl 6 projects however. It also doesn&amp;rsquo;t help for test files, which do not have an equivalent Perl 6 file extension (&lt;code&gt;.t6&lt;/code&gt; test files are ignored when installing Perl 6 modules).&lt;/p&gt;

&lt;h4 id=&#34;use-a-modeline:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Use a modeline&lt;/h4&gt;

&lt;p&gt;A modeline is a line of code in the text of the file which Vim reads and executes. So to activate Perl 6 syntax highlighting I just need to add this modeline to every Perl 6 file I work with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# vim: filetype=perl6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Take a look at the &lt;a href=&#34;https://github.com/Mouq/json5/blob/master/lib/JSON5/Tiny.pm6#L54&#34;&gt;source code&lt;/a&gt; of JSON5::Tiny for a real-World example. To Perl 6 this code looks just like an ordinary comment, but Vim will use it to turn on Perl 6 syntax highlighting. The modeline can appear anywhere in the code, but it&amp;rsquo;s better to place it at the start or end of the file.&lt;/p&gt;

&lt;p&gt;Older versions of Vim (pre 7.3) and when Vim is run under root privileges, disable modelines as a security risk. Don&amp;rsquo;t run Vim as root! But if you have an older Vim, you can turn on modelines with &lt;code&gt;:set modeline&lt;/code&gt;. As with &lt;code&gt;filetype&lt;/code&gt;, modeline can be abbreviated to &lt;code&gt;ml&lt;/code&gt;, so &lt;code&gt;set ml&lt;/code&gt; works too. To activate modelines automatically, add this line to your &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set ml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The downside of using modelines? First there is aforementioned security risk for older Vims. Also it feels impure to add editor directives to the code I&amp;rsquo;m working with, as not everyone uses Vim. These seem like minor issues though.&lt;/p&gt;

&lt;h4 id=&#34;use-a-local-vimrc:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Use a local vimrc&lt;/h4&gt;

&lt;p&gt;Often different Open Source projects will have different coding conventions that I need to follow, so it can be helpful to use a local vimrc file to store these project-specific settings. This works for syntax highlighting too. In order to use local vimrc files, I add the following code to my &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if filereadable(&amp;quot;.vimrc.local&amp;quot;)
  so .vimrc.local
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will check the current working directory for &lt;code&gt;.vimrc.local&lt;/code&gt; file, and automatically execute it if it finds it. &lt;strong&gt;Warning&lt;/strong&gt; this is a security risk - Vim will execute ANY instruction in a local vimrc, so I am very careful when working with projects that are not my own. Next I create a &lt;code&gt;.vimrc.local&lt;/code&gt; file in the root project directory and add this auto command to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;au Bufnewfile,bufRead *.pm,*.t,*.pl set filetype=perl6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when I open or create any file with a Perl extension, Vim will set the syntax highlighting to Perl 6. I like this technique because it&amp;rsquo;s not intrusive: it doesn&amp;rsquo;t require any changes to the Perl 6 files themselves, so it works well on shared projects (I never check-in my local vimrc to the Git repo).&lt;/p&gt;

&lt;h4 id=&#34;use-code-detection:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Use code detection&lt;/h4&gt;

&lt;p&gt;I can also have Vim try to detect Perl 6 code automatically. Two directives which would indicate we&amp;rsquo;re working with Perl 6 instead of Perl 5 code: the shebang line and the &lt;code&gt;use v6;&lt;/code&gt; directive. To check for these, I&amp;rsquo;ll add a function to my .vimrc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function! LooksLikePerl6 ()
  if getline(1) =~# &#39;^#!.*/bin/.*perl6&#39;
    set filetype=perl6
  else
    for i in [1,2,3,4,5]
      if getline(i) == &#39;use v6;&#39;
        set filetype=perl6
        break
      endif
    endfor
  endif
endfunction

au bufRead *.pm,*.t,*.pl call LooksLikePerl6()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function uses &lt;code&gt;getline()&lt;/code&gt; to check the first line of the file to see if it looks like a Perl 6 shebang. This should work well for &lt;code&gt;.pl&lt;/code&gt; scripts, but Perl 6 module files will not have a shebang, so the next part of the script checks the first 5 lines of the file for the &lt;code&gt;use v6;&lt;/code&gt; directive. The last line of code is an auto command which will call the function anytime we open file with a Perl file extension.&lt;/p&gt;

&lt;p&gt;The main drawback of this technique is that not all Perl 6 code uses the &lt;code&gt;use v6;&lt;/code&gt; directive, and so when working with module files, the code detection can fail. However the code detection could be improved to use more rules for detecting Perl 6 code such as class declarations. The &lt;a href=&#34;https://github.com/vim-perl/vim-perl&#34;&gt;vim-perl&lt;/a&gt; plugin has more sophisticated Perl 6 code detection &lt;a href=&#34;https://github.com/vim-perl/vim-perl/blob/master/ftdetect/perl11.vim&#34;&gt;rules&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;complete-vimrc:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Complete .vimrc&lt;/h3&gt;

&lt;p&gt;This &lt;code&gt;.vimrc&lt;/code&gt; contains all the code shown above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;syntax on

&amp;quot;Recognize modeline # vim: filetype=perl6
set ml

&amp;quot;check for a local vimrc
if filereadable(&amp;quot;.vimrc.local&amp;quot;)
  so .vimrc.local
endif

&amp;quot;check for Perl 6 code
function! LooksLikePerl6 ()
  if getline(1) =~# &#39;^#!.*/bin/.*perl6&#39;
    set filetype=perl6
  else
    for i in [1,2,3,4,5]
      if getline(i) == &#39;use v6;&#39;
        set filetype=perl6
        break
      endif
    endfor
  endif
endfunction

au bufRead *.pm,*.t,*.pl call LooksLikePerl6()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;So that&amp;rsquo;s it, four useful-but-imperfect techniques for detecting file types in Vim. I tend to use a combination of all four. This would be a nice problem not to have. I&amp;rsquo;d like the Perl 6 community to agree and encourage unambiguous file extensions like &lt;code&gt;.pm6&lt;/code&gt;, &lt;code&gt;.t6&lt;/code&gt; and &lt;code&gt;.pl6&lt;/code&gt;. Larry Wall called this &amp;ldquo;free advertising&amp;rdquo;. It&amp;rsquo;s also a simple way to make Perl 6 programmers more productive. Not every text editor is as customizable as Vim.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Parsing Perl 5 pod with Perl 6</title>
      <link>http://perltricks.com/article/170/2015/4/30/Parsing-Perl-5-pod-with-Perl-6/</link>
      <pubDate>Thu, 30 Apr 2015 13:14:23 +0000</pubDate>
      
      <guid>http://perltricks.com/article/170/2015/4/30/Parsing-Perl-5-pod-with-Perl-6/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve just finished developing a Perl 5 pod &lt;a href=&#34;https://github.com/dnmfarrell/Pod-Perl5&#34;&gt;parser&lt;/a&gt; written in Perl 6. Developing the grammar was surprisingly easy, which is a testament to Perl 6 as I&amp;rsquo;m no genius coder. With help from the folks at #perl6, I did learn some interesting things along the way, and wanted to share them. Plus, code!&lt;/p&gt;

&lt;p&gt;By the way, if you haven&amp;rsquo;t read my &lt;a href=&#34;http://perltricks.com/article/144/2015/1/13/How-to-create-a-grammar-in-Perl-6&#34;&gt;introduction&lt;/a&gt; to Perl 6 grammars, check it out first, and the rest of this article should make more sense.&lt;/p&gt;

&lt;h3 id=&#34;developing-the-grammar:78d208860f81988c9597decb37b0b553&#34;&gt;Developing the grammar&lt;/h3&gt;

&lt;p&gt;In Perl 6 a grammar is a special type of class for parsing text. The idea is to declare a series of regexes using the &lt;code&gt;token&lt;/code&gt; method, which are then used to parse input. For &lt;a href=&#34;https://github.com/dnmfarrell/Pod-Perl5/blob/master/lib/Pod/Perl5/Grammar.pm&#34;&gt;Pod::Perl5::Grammar&lt;/a&gt; I literally worked my way through &lt;a href=&#34;http://perldoc.perl.org/perlpod.html&#34;&gt;perlpod&lt;/a&gt;, the Perl 5 pod specification, writing tokens as I went.&lt;/p&gt;

&lt;p&gt;There were a few challenges. First, consider how would you define a regex for lists? In pod, lists can contain lists, so can a definition include itself? The answer is yes, a recursive definition is fine, as long as it doesn&amp;rsquo;t match a zero length string, which leads to an infinite loop. Here&amp;rsquo;s the definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;token over_back { &amp;lt;over&amp;gt;
                    [
                      &amp;lt;_item&amp;gt; | &amp;lt;paragraph&amp;gt; | &amp;lt;verbatim_paragraph&amp;gt; | &amp;lt;blank_line&amp;gt; |
                      &amp;lt;_for&amp;gt; | &amp;lt;begin_end&amp;gt; | &amp;lt;pod&amp;gt; | &amp;lt;encoding&amp;gt; | &amp;lt;over_back&amp;gt;
                    ]*
                    &amp;lt;back&amp;gt;
                  }

token over      { ^^\=over [\h+ &amp;lt;[0..9]&amp;gt;+ ]? \n }
token _item     { ^^\=item \h+ &amp;lt;name&amp;gt;
                    [
                        [ \h+ &amp;lt;paragraph&amp;gt;  ]
                      | [ \h* \n &amp;lt;blank_line&amp;gt; &amp;lt;paragraph&amp;gt;? ]
                    ]
                  }
token back      { ^^\=back \h* \n }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The token &lt;code&gt;over_back&lt;/code&gt; describes an entire list from start to finish. It basically says that a list must begin with an &lt;code&gt;=over&lt;/code&gt; and end with &lt;code&gt;=back&lt;/code&gt;, and can have a whole bunch of things in between, including another &lt;code&gt;over_back&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;For simplicity&amp;rsquo;s sake, I tried to name the tokens the same as how they&amp;rsquo;re written in pod. In some cases this wasn&amp;rsquo;t possible, for instance &lt;code&gt;item&lt;/code&gt; causes a namespace clash with another method that the Grammar class inherits. So watch out for those cases, you&amp;rsquo;ll get weird errors (this is a &lt;a href=&#34;https://rt.perl.org/rt3//Public/Bug/Display.html?id=77350&#34;&gt;bug&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;This is one pattern I really love and used over and over in the grammar:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;[ &amp;lt;pod_section&amp;gt; | &amp;lt;?!before &amp;lt;pod_section&amp;gt; &amp;gt; .]*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The pattern is useful when you have a pattern to capture, but if there&amp;rsquo;s no matching pattern ignore everything else. In this case, &lt;code&gt;pod_section&lt;/code&gt; is a token that defines a section of pod, but pod is often written inline with Perl code, which the grammar should ignore. So the second half of the definition uses a negative lookahead &lt;code&gt;?!before&lt;/code&gt; to check the next character is not a &lt;code&gt;pod_section&lt;/code&gt;, and uses a period &lt;code&gt;.&lt;/code&gt; to match everything else (including newlines). Both conditions are grouped in square brackets with an asterisk placed &lt;strong&gt;outside&lt;/strong&gt; the group in order to check one character at a time.&lt;/p&gt;

&lt;p&gt;The grammar can be used to parse standalone and inline pod. It will extract every pod section it finds into match object (basically a Perl data structure), ready for processing. It&amp;rsquo;s easy to use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Pod::Perl5::Grammar;

my $match = Pod::Perl5::Grammar.parse($pod);

# or

my $match = Pod::Perl5::Grammar.parsefile(&amp;quot;/path/to/some.pod&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;action-classes:78d208860f81988c9597decb37b0b553&#34;&gt;Action classes&lt;/h3&gt;

&lt;p&gt;So far so cool, but we can do more. Action classes are regular Perl 6 classes that can be given to the grammar at parse time. They provide behavior (actions) for token matching events. Just name the methods in the action class the same as the token they should be executed on. I wrote a pod-to-HTML action &lt;a href=&#34;https://github.com/dnmfarrell/Pod-Perl5/blob/master/lib/Pod/Perl5/ToHTML.pm&#34;&gt;class&lt;/a&gt;. Here is the method for converting &lt;code&gt;=head1&lt;/code&gt; to HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;method head1 ($/)
{
  self.add_to_html(&#39;body&#39;, &amp;quot;&amp;lt;h1&amp;gt;{$/&amp;lt;singleline_text&amp;gt;.Str}&amp;lt;/h1&amp;gt;\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every time the grammar matches a head1 token, this method executes. It&amp;rsquo;s passed the regex capture variable &lt;code&gt;$/&lt;/code&gt;, which contains the head1 regex capture, from which it extracts the text string.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a cool fact: action classes are even easier to write than grammars. It would be trivial to write a pod to markdown converter using Pod::Perl5::Grammar, unless someone beats me to it (hint, hint). That said, I did encounter a few challenges along the way.&lt;/p&gt;

&lt;p&gt;Essentially for HTML conversion, each action class method can just extract the text from it&amp;rsquo;s matching token, reformat it as required, and print it out. This approach worked great until I encountered nested tokens like formatting codes, which sit within a paragraph of text. You don&amp;rsquo;t want to go from this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;There are different ways to emphasize text, I&amp;lt;this is in italics&amp;gt; and  B&amp;lt;this is in bold&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;i&amp;gt;this is in italics&amp;lt;/i&amp;gt;
&amp;lt;b&amp;gt;this is in bold&amp;lt;/b&amp;gt;
&amp;lt;p&amp;gt;There are different ways to emphasize text, I&amp;lt;this is in italics&amp;gt; and  B&amp;lt;this is in bold&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can happen because the italics and bold token regexes match first. So to get around this issue, I used a buffer to store the HTML from the transformed sub-tokens, and then when a paragraph token is matched, it substitutes its own text with the contents of the buffer. The action class code for this looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;method paragraph ($/ is copy)
{
  my $original_text = $/&amp;lt;text&amp;gt;.Str.chomp;
  my $para_text = $/&amp;lt;text&amp;gt;.Str.chomp;

  for self.get_buffer(&#39;paragraph&#39;).reverse -&amp;gt; $pair # reverse as we&#39;re working outside in
  {
    $para_text = $para_text.subst($pair.key, {$pair.value});
  }
  self.add_to_html(&#39;body&#39;, &amp;quot;&amp;lt;p&amp;gt;{$para_text}&amp;lt;/p&amp;gt;\n&amp;quot;);
  self.clear_buffer(&#39;paragraph&#39;);
  }

method italic ($/)
{
  self.add_to_buffer(&#39;paragraph&#39;, $/.Str =&amp;gt; &amp;quot;&amp;lt;i&amp;gt;{$/&amp;lt;multiline_text&amp;gt;.Str}&amp;lt;/i&amp;gt;&amp;quot;);
}

method bold ($/)
{
  self.add_to_buffer(&#39;paragraph&#39;, $/.Str =&amp;gt; &amp;quot;&amp;lt;b&amp;gt;{$/&amp;lt;multiline_text&amp;gt;.Str}&amp;lt;/b&amp;gt;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One thing to watch out for with action classes is regex handling. &lt;strong&gt;Every&lt;/strong&gt; action class example I&amp;rsquo;ve seen uses &lt;code&gt;$/&lt;/code&gt; in the method signature. This is a mistake, as guess what this does:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;method head1 ($/)
{
  if $/.Str ~~ m/foobar/ # silly example
  {
    self.add_to_html(&#39;body&#39;, &amp;quot;&amp;lt;h1&amp;gt;{$/&amp;lt;singleline_text&amp;gt;.Str}\n&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Cannot assign to a readonly variable or a value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mushroom cloud-style boom. When &lt;code&gt;$/&lt;/code&gt; is passed to &lt;code&gt;head1&lt;/code&gt; it is read only. Executing &lt;strong&gt;any&lt;/strong&gt; regex in the same lexical scope will attempt to overwrite &lt;code&gt;$/&lt;/code&gt;. This bit me a few times and with help from #perl6, I ended up using this pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;method head1 ($/ is copy)
{
  my $match = $/;
  if $match.Str ~~ m/foobar/
  {
    self.add_to_html(&#39;body&#39;, &amp;quot;&amp;lt;h1&amp;gt;{$match&amp;lt;singleline_text&amp;gt;.Str}&amp;lt;/h1&amp;gt;\n&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding &lt;code&gt;is copy&lt;/code&gt; to the signature creates a copy instead of a reference for &lt;code&gt;$/&lt;/code&gt;. I then copy the match variable into &lt;code&gt;$match&lt;/code&gt;, so that the following regex can clobber &lt;code&gt;$/&lt;/code&gt;. I *think* a better solution is this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;method head1 ($match)
{
  if $match.Str ~~ m/foobar/
  {
    self.add_to_html(&#39;body&#39;, &amp;quot;&amp;lt;h1&amp;gt;{$match&amp;lt;singleline_text&amp;gt;.Str}&amp;lt;/h1&amp;gt;\n&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think it&amp;rsquo;s that simple, just don&amp;rsquo;t name the signature parameter &lt;code&gt;$/&lt;/code&gt; and all the headaches disappear. I haven&amp;rsquo;t tested this extensively&amp;hellip;&lt;/p&gt;

&lt;p&gt;To use an action class, just pass it to the grammar:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Pod::Perl5::Grammar;
use Pod::Perl5::ToHTML;

my $actions = Pod::Perl5::ToHTML.new;
my $match = Pod::Perl5::Grammar.parse($pod, :$actions);

# or
my $match = Pod::Perl5::Grammar.parse($pod, :actions($actions));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the first example I used a named positional argument &lt;code&gt;:$actions&lt;/code&gt;. This &lt;strong&gt;must&lt;/strong&gt; be called actions to work. In the second example I named the argument like this: &lt;code&gt;:actions($actions)&lt;/code&gt;, in which case the action class object can be called whatever you want.&lt;/p&gt;

&lt;h3 id=&#34;improving-pod:78d208860f81988c9597decb37b0b553&#34;&gt;Improving pod&lt;/h3&gt;

&lt;p&gt;PerlTricks.com articles are written in HTML. Special snowflake style HTML with class names and &lt;code&gt;span&lt;/code&gt; tags. This is a pain for writers to use and a pain to edit. I&amp;rsquo;d love to use pod as the source - it would be easier for writers to use and faster for me to edit. That said, I&amp;rsquo;d like to extend pod with some useful features for blogging. For instance, you may be familiar with formatting codes like &lt;code&gt;B&amp;lt;...&amp;gt;&lt;/code&gt; for bold and the like. Well, what about &lt;code&gt;@&amp;lt; ... &amp;gt;&lt;/code&gt; for a Twitter references, or &lt;code&gt;M&amp;lt; ... &amp;gt;&lt;/code&gt; for &lt;a href=&#34;https://metacpan.org/&#34;&gt;MetaCPAN&lt;/a&gt; links?&lt;/p&gt;

&lt;p&gt;As Perl 6 grammars are classes, they can be inherited and overridden. So I can add my Twitter and Metacpan formatting codes to the grammar like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;grammar Pod::Perl5::Grammar::PerlTricks is Pod::Perl5::Grammar
{
  token twitter  { @\&amp;lt; &amp;lt;name&amp;gt; \&amp;gt; }
  token metacpan { M\&amp;lt; &amp;lt;name&amp;gt; \&amp;gt; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ll also need to override the &lt;code&gt;format_codes&lt;/code&gt; token to include the new tokens:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;token format_codes  {
  [
    &amp;lt;italic&amp;gt;|&amp;lt;bold&amp;gt;|&amp;lt;code&amp;gt;|&amp;lt;link&amp;gt;
    |&amp;lt;escape&amp;gt;|&amp;lt;filename&amp;gt;|&amp;lt;singleline&amp;gt;
    |&amp;lt;index&amp;gt;|&amp;lt;zeroeffect&amp;gt;|&amp;lt;twitter|&amp;lt;metacpan&amp;gt;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s that easy. The new grammar will parse all pod, plus my two new formatting codes. Of course the action class Pod::Perl5::Pod can be extended and overridden too, and would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;Pod::Perl5::ToHTML::PerlTricks is Pod::Perl5::ToHTML
{
  method twitter ($match)
  {
    self.add_to_buffer(&#39;paragraph&#39;,
      $match.Str =&amp;gt;
&amp;quot;&amp;lt;a href=&amp;quot;http://twitter.com/{$match&amp;lt;name&amp;gt;.Str}&amp;quot;&amp;gt;{$match&amp;lt;name&amp;gt;.Str}&amp;lt;/a&amp;gt;&amp;quot;);
  }
  method metacpan ($match)
  {
    self.add_to_buffer(&#39;paragraph&#39;, 
      $match.Str =&amp;gt; 
&amp;quot;&amp;lt;a href=&amp;quot;https://metacpan.org/pod//{$match&amp;lt;name&amp;gt;.Str}&amp;quot;&amp;gt;{$match&amp;lt;name&amp;gt;.Str}&amp;lt;/a&amp;gt;&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wait-there-s-more:78d208860f81988c9597decb37b0b553&#34;&gt;Wait, there&amp;rsquo;s more&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s a cleaner way to manage groups of tokens, it&amp;rsquo;s called &lt;a href=&#34;http://design.perl6.org/S06.html#Routine_modifiers&#34;&gt;multi-dispatch&lt;/a&gt;. Instead of defining &lt;code&gt;format_codes&lt;/code&gt; as a list of alternative tokens it can match against, we declare a prototype method, and declare each formatting method as a &lt;code&gt;multi&lt;/code&gt; of the prototype. Check this out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;proto token format_codes  { * }
multi token format_codes:italic { I\&amp;lt; &amp;lt;multiline_text&amp;gt;  \&amp;gt;  }
multi token format_codes:bold   { B\&amp;lt; &amp;lt;multiline_text&amp;gt;  \&amp;gt;  }
multi token format_codes:code   { C\&amp;lt; &amp;lt;multiline_text&amp;gt;  \&amp;gt;  }
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when this grammar is inherited, there is no need to override &lt;code&gt;format_codes&lt;/code&gt;. Instead I can declare the new tokens as multis:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;grammar Pod::Perl5::Grammar::PerlTricks is Pod::Perl5::Grammar
{
  token format_codes:twitter  { @\&amp;lt; &amp;lt;name&amp;gt; \&amp;gt; }
  token format_codes:metacpan { M\&amp;lt; &amp;lt;name&amp;gt; \&amp;gt; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using multi-dispatch also has the modest benefit of simplifying the data extraction path when working with a match object. For instance, these code extracts the link section from the 3rd paragraph of a pod block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;is $match&amp;lt;pod_section&amp;gt;[0]&amp;lt;paragraph&amp;gt;[2]&amp;lt;text&amp;gt;&amp;lt;format_codes&amp;gt;[0]&amp;lt;link&amp;gt;&amp;lt;section&amp;gt;.Str # regular version
is $match&amp;lt;pod_section&amp;gt;[0]&amp;lt;paragraph&amp;gt;[2]&amp;lt;text&amp;gt;&amp;lt;format_codes&amp;gt;[0]&amp;lt;section&amp;gt;.Str # multi dispatch equivalent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the first example, the format token name &lt;code&gt;link&lt;/code&gt; is required. But with multi-dispatch, we can remove that, as shown in the second example.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:78d208860f81988c9597decb37b0b553&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;So that&amp;rsquo;s what I learned; overall writing a pod parser in Perl 6 was straightforward. If you&amp;rsquo;re programming in Perl 6 and have questions, I&amp;rsquo;d highly recommend the &lt;a href=&#34;http://perl6.org/community/irc&#34;&gt;#perl6&lt;/a&gt; irc channel on freenode, the people there were friendly and responsive.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; &lt;em&gt;Multi-dispatch example added. Thanks to Jonathan Scott Duff for providing the multi-dispatch explanation and code. 2015-05-01&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to create a grammar in Perl 6</title>
      <link>http://perltricks.com/article/144/2015/1/13/How-to-create-a-grammar-in-Perl-6/</link>
      <pubDate>Tue, 13 Jan 2015 15:45:36 +0000</pubDate>
      
      <guid>http://perltricks.com/article/144/2015/1/13/How-to-create-a-grammar-in-Perl-6/</guid>
      <description>

&lt;p&gt;In programming, a grammar is a set of rules for parsing text. They&amp;rsquo;re incredibly useful, for instance you can use a grammar to check if a text string conforms to a specific standard or not. Perl 6 has native support for grammars - they&amp;rsquo;re so easy to write that once you start using them, you&amp;rsquo;ll find yourself using them everywhere.&lt;/p&gt;

&lt;p&gt;Recently I&amp;rsquo;ve been working on Module::Minter, a simple app to create a base skeleton structure for a new Perl 6 module. I needed a way to check that the proposed module name would conform to Perl 6&amp;rsquo;s naming conventions.&lt;/p&gt;

&lt;p&gt;Module names can be described as identifiers separated by 2 colons, &lt;a href=&#34;https://github.com/labster/perl6-File-Compare/&#34;&gt;File::Compare&lt;/a&gt; for example*. An identifier must begin with an alpha character (a-z) or an underscore, followed by zero or more alphanumeric characters. So far so good, but it&amp;rsquo;s not that simple; some module names only have a single identifier and no colons like &lt;a href=&#34;https://github.com/tadzik/Bailador/&#34;&gt;Bailador&lt;/a&gt; whilst other modules are more of a mouthful like &lt;a href=&#34;https://github.com/tony-o/perl6-http-server-async-plugins-router-simple/&#34;&gt;HTTP::Server::Async::Plugins::Router::Simple&lt;/a&gt;. This sounds like a job for a grammar!&lt;/p&gt;

&lt;h3 id=&#34;defining-the-grammar:8e6dbbbc22892377a7cfff2143e49efc&#34;&gt;Defining the grammar&lt;/h3&gt;

&lt;p&gt;Perl 6 Grammars are built from regexes. I need two regexes: one for matching identifiers and one for matching the double colon separators. For the identifier regex, I&amp;rsquo;ll use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;lt;[A..Za..z_]&amp;gt; # begins with letter or underscore
&amp;lt;[A..Za..z0..9]&amp;gt; ** 0..* # zero or more alpanumeric
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember we&amp;rsquo;re using Perl 6 regexes, so things might look a little different if you&amp;rsquo;re used to Perl 5 style regexes. A character class is defined by &lt;code&gt;&amp;lt;[ ... ]&amp;gt;&lt;/code&gt; and ranges are defined using the range operator &lt;code&gt;..&lt;/code&gt; instead of a hyphen. This regex matches any leading letter or underscore followed by zero or more alphanumeric characters. Matching two colons is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;\:\: # colon pairs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Grammars are defined using the &lt;code&gt;grammar&lt;/code&gt; keyword, followed by the name of the grammar. I&amp;rsquo;m going to call this grammar &lt;code&gt;Legal::Module::Name&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;grammar Legal::Module::Name
{
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I can add the regexes as tokens to the grammar:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;grammar Legal::Module::Name
{
  token identifier
  {
    # leading alpha or _ only
    &amp;lt;[A..Za..z_]&amp;gt;
    &amp;lt;[A..Za..z0..9]&amp;gt; ** 0..*
  } 
  token separator
  {
    \:\: # colon pairs
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every Grammar needs a token called &lt;code&gt;TOP&lt;/code&gt;, which is the starting point for the grammar:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;grammar Legal::Module::Name
{
  token TOP
  { # identifier followed by zero or more separator identifier pairs
    ^ &amp;lt;identifier&amp;gt; [&amp;lt;separator&amp;gt;&amp;lt;identifier&amp;gt;] ** 0..* $
  }
  token identifier
  {
    # leading alpha or _ only
    &amp;lt;[A..Za..z_]&amp;gt;
    &amp;lt;[A..Za..z0..9]&amp;gt; ** 0..*
  } 
  token separator
  {
    \:\: # colon pairs
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;TOP&lt;/code&gt; token defines a valid module name as one that begins with an identifier token, followed by zero or more separator and identifier token pairs. This is nice to write and maintain - let&amp;rsquo;s say I wanted to change the rules for separators to include hyphens (&amp;lsquo;-&amp;rsquo;), I could just update the separator token regex and the effect would bubble up to the &lt;code&gt;TOP&lt;/code&gt; token definition.&lt;/p&gt;

&lt;h3 id=&#34;using-the-grammar:8e6dbbbc22892377a7cfff2143e49efc&#34;&gt;Using the grammar&lt;/h3&gt;

&lt;p&gt;Now I&amp;rsquo;ve got the grammar, it&amp;rsquo;s time to put it into action. The &lt;code&gt;parse&lt;/code&gt; method runs the grammar on a string and if successful, returns a match object. This code parses the &lt;code&gt;$proposed_module_name&lt;/code&gt; string, and either prints out the match object or an error message if the propose module name is invalid.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $proposed_module_name = &#39;Super::New::Module&#39;;
my $match_obj = Legal::Module::Name.parse($proposed_module_name);

if $match_obj
{
    say $match_obj;
}
else
{
    say &#39;Invalid module name!&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code prints:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;｢Super::New::Module｣
 identifier =&amp;gt; ｢Super｣
 separator =&amp;gt; ｢::｣
 identifier =&amp;gt; ｢New｣
 separator =&amp;gt; ｢::｣
 identifier =&amp;gt; ｢Module｣
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;extracting-content-from-the-match-object:8e6dbbbc22892377a7cfff2143e49efc&#34;&gt;Extracting content from the match object&lt;/h3&gt;

&lt;p&gt;Rather than dumping the contents of the match object to the command line, we can extract matched tokens from the match object. This uses the same quoting syntax often used elsewhere in Perl 6 (e.g. named regexes and hash keys):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;say $match_obj[0].Str; # Super
say $match_obj[1].Str; # New
say $match_obj[2].Str; # Module

say $match_obj; # all 3 captures
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;action-classes:8e6dbbbc22892377a7cfff2143e49efc&#34;&gt;Action Classes&lt;/h3&gt;

&lt;p&gt;So far the grammar can detect if a proposed module name is legal or not, and produces a match object from which it&amp;rsquo;s easy to extract the components of the module name. Perl 6 also let&amp;rsquo;s you add an action class which defines extra behaviour for matched tokens. I&amp;rsquo;d like to add a warning when a module name has too many identifiers, in other words, it&amp;rsquo;s a legal module name, but the user might want to shorten it. First I define the action class itself:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;class Module::Name::Actions
{
  method TOP($/)
  {
    if $&amp;lt;identifier&amp;gt;.elems &amp;gt; 5
    {
      warn &#39;Module name has a lot of identifiers, consider simplifying the name&#39;;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see this is an ordinary Perl 6 class definition. I&amp;rsquo;ve added one method called &lt;code&gt;TOP&lt;/code&gt; which matches the first token in the grammar. I use the named regex syntax to count all identifier matches, and if there are more than 5, fire a warning. This won&amp;rsquo;t stop the code from running, but it might cause the user to reconsider their choice of module name.&lt;/p&gt;

&lt;p&gt;I then initialize the action class and pass it as an argument in to &lt;code&gt;parse&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $actions = Module::Name::Actions.new; 
my $match_obj = Legal-Module-Name.parse($proposed_module_name, :actions($actions));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The grammar will call the matching action class method every time the token is encountered during parsing. In this case that&amp;rsquo;s once per parse, but we could add an additional length length on identifier tokens for example. Check out the &lt;a href=&#34;https://github.com/sillymoose/Module-Minter/blob/master/lib/Module/Minter.pm6&#34;&gt;Module::Minter&lt;/a&gt; source to see how to incorporate a grammar into a module.&lt;/p&gt;

&lt;h3 id=&#34;grammars-in-perl-5:8e6dbbbc22892377a7cfff2143e49efc&#34;&gt;Grammars in Perl 5&lt;/h3&gt;

&lt;p&gt;You can also write grammars in Perl 5. For a solution similar to the Perl 6 implementation, have a look at &lt;a href=&#34;https://metacpan.org/pod/Regexp::Grammars&#34;&gt;Regexp::Grammars&lt;/a&gt; or Ingy Döt Net&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/Pegex&#34;&gt;Pegex&lt;/a&gt; distribution. For a different approach, check out chapter 1 of &lt;a href=&#34;http://www.masteringperl.org/&#34;&gt;Mastering Perl&lt;/a&gt; by brian d foy, which contains an example JSON grammar.&lt;/p&gt;

&lt;p&gt;* This isn&amp;rsquo;t strictly correct - the entire name (colons included) is the identifier.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; &lt;em&gt;added link to Regexp::Grammars. 2015-01-13&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Get started with Perl 6 one liners</title>
      <link>http://perltricks.com/article/136/2014/11/20/Get-started-with-Perl-6-one-liners/</link>
      <pubDate>Thu, 20 Nov 2014 14:04:56 +0000</pubDate>
      
      <guid>http://perltricks.com/article/136/2014/11/20/Get-started-with-Perl-6-one-liners/</guid>
      <description>

&lt;p&gt;One thing that sets Perl apart from other languages is the ability to write small programs in a single line of code, known as a &amp;ldquo;one liner&amp;rdquo;. It&amp;rsquo;s often faster to type a program directly into the terminal than to write a throwaway script. And one liners are powerful too; they&amp;rsquo;re complete Perl programs that can load external libraries but also integrate into the terminal. You can pipe data in or out of a one liner.&lt;/p&gt;

&lt;p&gt;Like its predecessor, Perl 6 supports one liners. And in the same way Perl 6 cleaned up Perl 5&amp;rsquo;s warts elsewhere, the one liner syntax is also better. It&amp;rsquo;s cleaner with fewer special variables and options to memorize. This article aims to get you up-and-running with Perl 6 one liners.&lt;/p&gt;

&lt;h3 id=&#34;the-basics:f134c951b57c0f63005d49172b15ce32&#34;&gt;The basics&lt;/h3&gt;

&lt;p&gt;To get started with one liners, all you really need to understand is the &lt;code&gt;-e&lt;/code&gt; option. This tells Perl to execute what follows as a program. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perl6 -e &#39;say &amp;quot;Hello, World!&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s step through this code.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;perl6&lt;/code&gt; invokes the Perl 6 program&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt; tells Perl 6 to execute&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;say &amp;quot;Hello, World!&amp;quot;&#39;&lt;/code&gt; is the program. Every program must be surrounded in single quotes (except on Windows, see (&lt;a href=&#34;https://github.com/sillymoose/Perl6-One-Liners#converting-for-windows&#34;&gt;converting for Windows&lt;/a&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To run a one-liner, just type it into the terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -e &#39;say &amp;quot;Hello, World!&amp;quot;&#39;
Hello, World!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;file-processing:f134c951b57c0f63005d49172b15ce32&#34;&gt;File processing&lt;/h3&gt;

&lt;p&gt;If you want to load a file, just add the path to the file after the program code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -e &#39;for (lines) { say $_ }&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program prints every line in &lt;code&gt;/path/to/file.txt&lt;/code&gt;. You may know that &lt;code&gt;$_&lt;/code&gt; is the default variable, which in this case is the current line being looped through. &lt;code&gt;lines&lt;/code&gt; is a list that is automatically created for you whenever you pass a filepath to a one-liner. Now let&amp;rsquo;s re-write that one liner, step-by-step. These one liners are all equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -e &#39;for (lines) { say $_ }&#39; /path/to/file.txt
&amp;gt; perl6 -e &#39;for (lines) { $_.say }&#39; /path/to/file.txt
&amp;gt; perl6 -e &#39;for (lines) { .say }&#39; /path/to/file.txt
&amp;gt; perl6 -e &#39;.say for (lines)&#39; /path/to/file.txt
&amp;gt; perl6 -e &#39;.say for lines&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like &lt;code&gt;$_&lt;/code&gt; is the default variable, methods called on the default variable can omit the variable name. They become default methods. So &lt;code&gt;$_.say&lt;/code&gt; becomes &lt;code&gt;.say&lt;/code&gt;. This brevity pays off with one liners - it&amp;rsquo;s less typing!&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;-n&lt;/code&gt; option changes the behavior of the program: it executes the code once for every line of the file. To uppercase and print every line of &lt;code&gt;/path/to/file.txt&lt;/code&gt; you can type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -ne &#39;.uc.say&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-p&lt;/code&gt; option is just like &lt;code&gt;-n&lt;/code&gt; except that it will automatically print &lt;code&gt;$_&lt;/code&gt;. This means that another way we could uppercase a file would be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -pe &#39;$_ = $_.uc&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or by applying a shortcut, this does the same thing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -pe &#39;.=uc&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt; options are really useful and often spare the programmer from extra typing.&lt;/p&gt;

&lt;h3 id=&#34;load-modules:f134c951b57c0f63005d49172b15ce32&#34;&gt;Load modules&lt;/h3&gt;

&lt;p&gt;The final thing you should know is how to load a module. This is really powerful as you can extend Perl 6&amp;rsquo;s capabilities by importing external libraries. The &lt;code&gt;-M&lt;/code&gt; switch stands for load module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -M URI::Encode -e &#39;say encode_uri(&amp;quot;/10 ways to crush it with Perl 6&amp;quot;)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code &lt;code&gt;-M URI::Encode&lt;/code&gt; loads the URI::Encode module, which exports the &lt;code&gt;encode_uri&lt;/code&gt; subroutine. It prints:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;%2F10%20ways%20to%20crush%20it%20with%20Perl%206
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What if you have a module that is not installed in a standard location? In this case using &lt;code&gt;-M&lt;/code&gt; alone won&amp;rsquo;t work, as Perl won&amp;rsquo;t find the module. For these scenarios, just pass use the &lt;code&gt;-I&lt;/code&gt; switch to include the directory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -I lib -M URI::Encode -e &#39;say encode_uri(&amp;quot;www.example.com/10 ways to crush it with Perl 6&amp;quot;)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now Perl 6 will search for URI::Encode in &lt;code&gt;lib&lt;/code&gt; as well as the standard install locations.&lt;/p&gt;

&lt;p&gt;Finally, if you want a summary of all of these options, just use the &lt;code&gt;-h&lt;/code&gt; option:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;    With no arguments, enters a REPL. With a &amp;quot;[programfile]&amp;quot; or the &amp;quot;-e&amp;quot; option, compiles the given program and by default also executes the compiled code.
 
    -c                   check syntax only (runs BEGIN and CHECK blocks)
    --doc                extract documentation and print it as text
    -e program           one line of program
    -h, --help           display this help text
    -n                   run program once for each line of input
    -p                   same as -n, but also print $_ at the end of lines
    -I path              adds the path to the module search path
    -M module            loads the module prior to running the program
    --target=[stage]     specify compilation stage to emit
    --optimize=[level]   use the given level of optimization (0..3)
    -t, --trace=[flags]  enable trace flags, see &#39;parrot --help-debug&#39;
    --encoding=[mode]    specify string encoding mode
    -o, --output=[name]  specify name of output file
    -v, --version        display version information
    --stagestats         display time spent in the compilation stages
    --ll-exception       display a low level backtrace on errors
    --profile            print profile information to standard error
    --doc=[module]       Use Pod::To::[module] to render inline documentation.
     
    Note that only boolean single-letter options may be bundled.

    Output from --profile can be visualized by kcachegrind.

    To modify the include path, you can set the PERL6LIB environment variable:

    PERL6LIB=&amp;quot;lib&amp;quot; perl6 example.pl

    For more information, see the perl6(1) man page.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion:f134c951b57c0f63005d49172b15ce32&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This article was adapted from my open source &lt;a href=&#34;https://github.com/sillymoose/Perl6-One-Liners&#34;&gt;book&lt;/a&gt;, which has lots of example Perl 6 one liners, many of which were contributed by the Perl 6 community. If you&amp;rsquo;re interested in learning more Perl 6, I&amp;rsquo;d recommend visiting the official &lt;a href=&#34;http://perl6.org/&#34;&gt;website&lt;/a&gt;, which has links to the IRC channel and official documentation.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Perl 6 with Visual Studio 2013</title>
      <link>http://perltricks.com/article/135/2014/11/18/Building-Perl-6-with-Visual-Studio-2013/</link>
      <pubDate>Tue, 18 Nov 2014 13:34:36 +0000</pubDate>
      
      <guid>http://perltricks.com/article/135/2014/11/18/Building-Perl-6-with-Visual-Studio-2013/</guid>
      <description>

&lt;p&gt;I think the last time I tried playing around with anything related to Perl 6 was at least two years ago. Recently, &lt;a href=&#34;https://fosdem.org/2015/schedule/event/get_ready_to_party/&#34;&gt;an understated entry&lt;/a&gt; in Fosdem &amp;lsquo;15 schedule caught the Perl community&amp;rsquo;s attention:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The last pieces are finally falling into place. After years of design and implementation, 2015 will be the year that Perl 6 officially launches for production use.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since then, Microsoft made &lt;a href=&#34;http://blog.nu42.com/2014/11/64-bit-perl-5201-with-visual-studio.html&#34;&gt;Visual Studio 2013 freely available&lt;/a&gt; for individuals and small teams. Up to this point, I had been using the compiler that comes with Windows SDK 7.1 with decent results, but, of course, couldn&amp;rsquo;t resist the temptation to build Perl 5.20.1 with the new compiler.&lt;/p&gt;

&lt;p&gt;This was followed by an encouraging question from &lt;a href=&#34;http://www.reddit.com/r/perl/comments/2m3t6s/%CE%BD42_64bit_perl_5201_with_visual_studio_2013/cm1iqnb&#34;&gt;David Farrell&lt;/a&gt;: &amp;ldquo;Have you thought about compiling Rakudo?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Well, I hadn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;I had been anticipating too many headaches from not using *nix tools, but I decided to give it a shot. Perl 6 really couldn&amp;rsquo;t be ready enough that I could just get the source and build it, could it?&lt;/p&gt;

&lt;p&gt;I started with Rakudo Star - a Perl 6 distribution that bundles some useful modules and a package manager. I downloaded &lt;a href=&#34;http://rakudo.org/downloads/star/&#34;&gt;rakudo-star-2014.09.tar.gz&lt;/a&gt;, extracted it and ran the configure script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;C:\Src&amp;gt; perl Configure.pl --gen-moar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This configures Perl 6 to use &lt;a href=&#34;http://moarvm.com/&#34;&gt;MoarVM&lt;/a&gt;, one of several virtual machines that Perl 6 can be built for. From that point on, it was just a matter of following a few prompts and soon I had a &lt;code&gt;perl6&lt;/code&gt; that was churning through the specification tests.&lt;/p&gt;

&lt;p&gt;Those did take a while. In the end there were about a dozen test failures which represent a tiny fraction of the total number of tests.&lt;/p&gt;

&lt;h3 id=&#34;compiling-rakudo-from-source:8e521b9a6a55a3a00378444bf2aee097&#34;&gt;Compiling Rakudo from source&lt;/h3&gt;

&lt;p&gt;Using the two months old Rakudo Star distribution left me wanting more. So I headed over to &lt;a href=&#34;https://github.com/rakudo/rakudo/&#34;&gt;Rakudo&amp;rsquo;s GitHub repository&lt;/a&gt; and proceeded to checkout and build the default branch.&lt;/p&gt;

&lt;p&gt;If you want to build Rakudo from source you will need &lt;a href=&#34;http://git-scm.com/&#34;&gt;Git&lt;/a&gt; for this to work. There are several options available, including &lt;a href=&#34;https://windows.github.com/&#34;&gt;GitHub Windows&lt;/a&gt; and &lt;a href=&#34;http://git-scm.com/download/win&#34;&gt;Git for Windows&lt;/a&gt;. I prefer to use &lt;a href=&#34;https://www.cygwin.com/&#34;&gt;Cygwin&lt;/a&gt; versions of *nixy utilities by adding Cygwin&amp;rsquo;s executable locations &lt;em&gt;last&lt;/em&gt; in my &lt;code&gt;%PATH%&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Once you have a version of Git installed, these are the steps to follow:&lt;/p&gt;

&lt;p&gt;Open a &amp;ldquo;VS2013 x64 Native Tools Command Prompt&amp;rdquo;. You can find the shortcuts under &lt;code&gt;C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\Tools\Shortcuts&lt;/code&gt; (with Visual Studio 2015, the shortcut is under: &lt;code&gt;C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Visual Studio 2015\Visual Studio Tools\Windows Desktop Command Prompts&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Run the following commands to get the Rakudo source and build it for MoarVM:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; git clone https://github.com/rakudo/rakudo.git
&amp;gt; cd rakudo
&amp;gt; perl Configure.pl --gen-moar --gen-nqp --backends=moar --prefix=C:/opt/Perl6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;N.B. Make sure this is a native Windows &lt;code&gt;perl&lt;/code&gt;, not a Cygwin version in case you have those on the path. If you want to be absolutely certain, specify the full path. E.g., in my case, &lt;code&gt;C:\opt\perl-5.20.1\bin\perl Configure.pl ...&lt;/code&gt;. You may also have to adjust the &lt;code&gt;--prefix&lt;/code&gt; path to suit your system.&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;Configure.pl&lt;/code&gt; will pull in the rest of the components necessary to build Rakudo. The rest is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; nmake
&amp;gt; nmake test
&amp;gt; nmake spectest
&amp;gt; nmake install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run spectest only if you are really patient or curious. When those tests were done, I had seven spectest failures. I didn&amp;rsquo;t care much about those at this point. My purpose was to have a &lt;code&gt;perl6&lt;/code&gt; working well enough to let me try, (for the first time ever!), some Perl 6 examples.&lt;/p&gt;

&lt;p&gt;You can also add the &lt;code&gt;Perl6\bin&lt;/code&gt; path to your user path. If everything worked as smoothly as it did for me, try:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -v
This is perl6 version 2014.10-114-gf8f6feb built on MoarVM version
2014.10-17-g05b25a6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And just for fun:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -e &amp;quot;&#39;Hello World!&#39;.say&amp;quot;
Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;installing-perl-6-modules:8e521b9a6a55a3a00378444bf2aee097&#34;&gt;Installing Perl 6 Modules&lt;/h3&gt;

&lt;p&gt;What is Perl without the ability to exploit other people&amp;rsquo;s hard work for your gain?&lt;/p&gt;

&lt;p&gt;Perl 6, just like Perl 5, has a module system. You can find contributed modules at &lt;a href=&#34;http://modules.perl6.org/&#34;&gt;modules.perl6.org&lt;/a&gt;, and install them using &lt;a href=&#34;https://github.com/tadzik/panda/&#34;&gt;panda&lt;/a&gt;. Unfortunately bootstrapping panda didn&amp;rsquo;t work for me due to &lt;a href=&#34;https://github.com/tadzik/File-Find/blob/master/t/01-file-find.t&#34;&gt;test failures with File::Find&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I am not sure if these indicate problems with the underlying library, or problems with the way tests are written. I suspect the latter, but that will have to wait. In the mean time, I will &lt;a href=&#34;http://perl6.org/documentation/&#34;&gt;explore the basic language&lt;/a&gt; to get a better feel for Perl 6.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; - added VS2015 instructions. 2016-01-04&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

