<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Security on Perl programming news, code and culture</title>
    <link>http://perltricks.com/categories/security/</link>
    <description>Recent content in Security on Perl programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 01 Mar 2016 08:57:00 +0000</lastBuildDate>
    <atom:link href="http://perltricks.com/categories/security/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Netanel Rubin&#39;s Perl Jam circus</title>
      <link>http://perltricks.com/article/netanel-rubins-perljam-circus/</link>
      <pubDate>Tue, 01 Mar 2016 08:57:00 +0000</pubDate>
      
      <guid>http://perltricks.com/article/netanel-rubins-perljam-circus/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve just watched Netanel Rubin&amp;rsquo;s Perl Jam 2 &lt;a href=&#34;https://www.youtube.com/watch?v=eH_u3C2WwQ0&#34;&gt;talk&lt;/a&gt; from this year&amp;rsquo;s Chaos Communication Congress. As he&amp;rsquo;s due to give the same talk at &lt;a href=&#34;https://www.blackhat.com/asia-16/&#34;&gt;Black Hat Asia&lt;/a&gt;, I thought it would be good to set the record straight concerning his claims about Perl (&lt;a href=&#34;https://gist.github.com/preaction/978ce941f05769b064f4&#34;&gt;others&lt;/a&gt; have already done so). He makes 3 major claims:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The Perl language is insecure&lt;/li&gt;
&lt;li&gt;Bugzilla &amp;amp; CGI.pm are representative of idiomatic Perl&lt;/li&gt;
&lt;li&gt;Perl doesn&amp;rsquo;t improve&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I&amp;rsquo;m going to address each claim in turn and show why it is false. In my view, Perl remains a powerful, general-purpose language well-suited to tasks like building dynamic web applications, processing big data, and managing systems.&lt;/p&gt;

&lt;h3 id=&#34;claim-1-the-perl-language-is-insecure:d158258b1d06be868d3b174d51dace7b&#34;&gt;Claim 1: The Perl language is insecure&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Function declarations cannot specify argument data types&lt;/p&gt;

&lt;p&gt;&amp;ndash; &lt;cite&gt;Netanel Rubin, The Perl Jam 2&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This isn&amp;rsquo;t true. Since 2008 Perl has supported subroutine signatures, with type checks using the &lt;a href=&#34;https://metacpan.org/pod/Method::Signatures&#34;&gt;Method::Signatures&lt;/a&gt; module. Since 2006 the &lt;a href=&#34;https://metacpan.org/pod/Moose&#34;&gt;Moose&lt;/a&gt; object system provided a fully-fledged &lt;a href=&#34;https://metacpan.org/pod/Moose::Util::TypeConstraints&#34;&gt;type system&lt;/a&gt; and meta object programming interface (there&amp;rsquo;s also &lt;a href=&#34;https://metacpan.org/pod/MooseX::Method::Signatures&#34;&gt;MooseX::Method::Signatures&lt;/a&gt;).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Developers treat hashes and arrays as &amp;ldquo;secure&amp;rdquo; data types &amp;hellip; this is the Perl standard. You&amp;rsquo;re not expected to use it, you have to, as you don&amp;rsquo;t have any other choice. This security mess is a fundamental part of the language.&lt;/p&gt;

&lt;p&gt;&amp;ndash; &lt;cite&gt;Netanel Rubin, The Perl Jam 2&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Netanel starts by describing taint mode and claims that hashes are so secure, hash keys bypass Perl&amp;rsquo;s taint check. It&amp;rsquo;s true that hash keys are never considered tainted. This is documented in &lt;a href=&#34;http://perldoc.perl.org/perlsec.html#Taint-mode&#34;&gt;perlsec&lt;/a&gt; and discussed in depth in Chapter 2 of &lt;a href=&#34;http://masteringperl.org&#34;&gt;Mastering Perl&lt;/a&gt;. But it&amp;rsquo;s not because hashes are assumed to be secure, it&amp;rsquo;s because tainting hash keys involves a huge performance penalty. He never explains his claim as to why arrays are considered secure.&lt;/p&gt;

&lt;p&gt;Perl&amp;rsquo;s &lt;code&gt;ref&lt;/code&gt; function is a reliable and secure way to determine the data type of a reference. Arguments passed to functions are always passed as an array of scalars via &lt;code&gt;@_&lt;/code&gt;. There is no doubt, no ambiguity. It&amp;rsquo;s not required security-wise, but if you want to use them you can use function signatures, types and meta-object programming in Perl. They&amp;rsquo;ve been available for years.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;But I felt all of these points will go unnoticed without an extreme example of Perl&amp;rsquo;s absurdity. So I found an extreme example. One that will clearly show the ridiculousness nature of the language.&lt;/p&gt;

&lt;p&gt;&amp;ndash; &lt;cite&gt;Netanel Rubin, The Perl Jam 2&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is the vulnerable code, from an example CGI application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use CGI;

my $cgi = CGI-&amp;gt;new;

if ($cgi-&amp;gt;upload( &#39;file&#39; )) {
  my $file = $cgi-&amp;gt;param( &#39;file&#39; );
  while (&amp;lt;$file&amp;gt;) {
    print &amp;quot;$_&amp;quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The issue with this code is that if &lt;code&gt;$file&lt;/code&gt; has the value of &lt;code&gt;ARGV&lt;/code&gt;, the diamond operator &lt;code&gt;&amp;lt;$file&amp;gt;&lt;/code&gt; will call &lt;code&gt;open&lt;/code&gt; on every value in &lt;code&gt;@ARGV&lt;/code&gt;. CGI populates &lt;code&gt;@ARGV&lt;/code&gt; with the HTTP query parameters which creates the vulnerability. So if the HTTP query parameter is &lt;code&gt;ls|&lt;/code&gt;, Perl will execute &lt;code&gt;ls&lt;/code&gt;. If the CGI program was running in taint mode, this attack vector would fail. Regardless, it&amp;rsquo;s a well-understood risk, the PLEAC project&amp;rsquo;s Perl &lt;a href=&#34;http://ramenlabs.com/pleac-pdf/pleac_perl.pdf&#34;&gt;recommendations&lt;/a&gt; from 1999 shows how to properly parse file descriptors in CGI parameters (ex 19.4). O&amp;rsquo;Reilly&amp;rsquo;s &lt;a href=&#34;http://www.oreilly.com/openbook/cgi/ch07_04.html&#34;&gt;CGI Programming on the Web&lt;/a&gt; by Shishir Gundavaram recommended parsing metacharacters like &lt;code&gt;|&lt;/code&gt; from user input, which also prevents this attack. That book was published in 1996.&lt;/p&gt;

&lt;p&gt;The piping open behavior is well documented in &lt;a href=&#34;http://perldoc.perl.org/functions/open.html&#34;&gt;open&lt;/a&gt;, &lt;a href=&#34;http://perldoc.perl.org/perlipc.html#Using-open%28%29-for-IPC&#34;&gt;perlipc&lt;/a&gt; and &lt;a href=&#34;http://perldoc.perl.org/perlsec.html&#34;&gt;perlsec&lt;/a&gt;. Chapter 2 of &lt;a href=&#34;http://masteringperl.org&#34;&gt;Mastering Perl&lt;/a&gt; also covers it. It&amp;rsquo;s a useful feature when you want to efficiently process a lot of data from an external command: just like a shell pipe, it creates a socket between the Perl program and the external binary, avoiding the need to read the entire output into memory at once.&lt;/p&gt;

&lt;p&gt;Netanel also identified a SQL injection vulnerability in Bugzilla. The weakness was caused by a poorly coded function which failed to properly validate input used in a dynamic SQL query. The developers should have used the safer pass-by-parameter &lt;a href=&#34;https://metacpan.org/pod/DBI&#34;&gt;DBI&lt;/a&gt; &lt;code&gt;prepare&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt; functions.&lt;/p&gt;

&lt;p&gt;In both cases Perl provided methods for securely parsing untrusted input, but the developers didn&amp;rsquo;t use them.&lt;/p&gt;

&lt;h3 id=&#34;claim-2-bugzilla-cgi-pm-are-representative-of-idiomatic-perl:d158258b1d06be868d3b174d51dace7b&#34;&gt;Claim 2: Bugzilla &amp;amp; CGI.pm are representative of idiomatic Perl&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Like every other Perl project, Bugzilla is heavily using functions that treat scalar and non-scalar argument types very differently.&lt;/p&gt;

&lt;p&gt;&amp;ndash; &lt;cite&gt;Netanel Rubin, The Perl Jam 2&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Netanel is referring to this code from his talk, which uses the argument type to decide what to do:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub test {
  $arg1 = @_; # Get an argument

  if (ref $arg1 eq &#39;HASH&#39;)
    print $arg1{&#39;key&#39;};
  else
    print $arg1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aside from the fact that Netanel&amp;rsquo;s code contains a big error which means it would never work, the claim that every other Perl project is coded in this way is preposterous. &lt;a href=&#34;https://metacpan.org/pod/Dist::Zilla&#34;&gt;Dist::Zilla&lt;/a&gt; is a popular Perl project with over 20,000 lines of code. Can you guess how frequently Dist::Zilla uses the construct Netanel describes? A quick grep of the code shows zero instances. Bugzilla was developed in 1998, it is not an example of &lt;a href=&#34;http://modernperlbooks.com/books/modern_perl_2014/index.html&#34;&gt;Modern Perl&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Regarding CGI.pm, I can&amp;rsquo;t say it better than the official &lt;a href=&#34;https://metacpan.org/pod/CGI#CGI.pm-HAS-BEEN-REMOVED-FROM-THE-PERL-CORE&#34;&gt;documentation&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;CGI.pm HAS BEEN REMOVED FROM THE PERL CORE&lt;/p&gt;

&lt;p&gt;The rationale for this decision is that CGI.pm is no longer considered good practice for developing web applications, including quick prototyping and small web scripts. There are far better, cleaner, quicker, easier, safer, more scalable, more extensible, more modern alternatives available at this point in time.&lt;/p&gt;

&lt;p&gt;&amp;ndash; &lt;cite&gt;CGI.pm documentation&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;claim-3-perl-doesn-t-improve:d158258b1d06be868d3b174d51dace7b&#34;&gt;Claim 3: Perl doesn&amp;rsquo;t improve&lt;/h3&gt;

&lt;p&gt;Things get interesting during the Q&amp;amp;A section of the talk when an audience member says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We use Perl for almost every module that we have at work, and it works really fine. I don&amp;rsquo;t know why you are picking Perl as a language to attack. It&amp;rsquo;s a really old language, and every language you can pick has problems, it doesn&amp;rsquo;t mean that &amp;hellip; you have to stop using it.&lt;/p&gt;

&lt;p&gt;&amp;ndash; &lt;cite&gt;Audience Member, The Perl Jam 2&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Netanel responds:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;C got criticized and it improved. PHP got criticized and it improved. Why can&amp;rsquo;t Perl be criticized too? &amp;hellip; why don&amp;rsquo;t they improve the language?&lt;/p&gt;

&lt;p&gt;&amp;ndash; &lt;cite&gt;Netanel Rubin, The Perl Jam 2&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The funny thing is Perl is improving all the time. Every year there is a major release of Perl which brings new features and enhancements to the language (&lt;a href=&#34;http://perldoc.perl.org/index-history.html&#34;&gt;history&lt;/a&gt;). Last year&amp;rsquo;s &lt;a href=&#34;http://perldoc.perl.org/perldelta.html&#34;&gt;release&lt;/a&gt; included a new operator, the &lt;a href=&#34;http://www.effectiveperlprogramming.com/2015/05/use-perl-5-22s-operator-for-safe-command-line-handling/&#34;&gt;double diamond&lt;/a&gt; &lt;code&gt;&amp;lt;&amp;lt; &amp;gt;&amp;gt;&lt;/code&gt; which disables the piping open behavior shown earlier. CGI.pm was removed from Perl&amp;rsquo;s core modules list in May 2014. Both of those occurrences predate Netanel&amp;rsquo;s talk.&lt;/p&gt;

&lt;p&gt;Instead of waiting for a major release milestone, the Perl development team can fix critical security issues in a minor release if needed (for example see &lt;a href=&#34;http://perldoc.perl.org/perl5163delta.html&#34;&gt;5.16.3&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Perl also has a strong toolchain for evaluating Perl code. &lt;a href=&#34;https://metacpan.org/pod/distribution/Perl-Critic/bin/perlcritic&#34;&gt;Perl::Critic&lt;/a&gt; is a linter that reviews Perl code against recommended coding practices. There is even a &lt;a href=&#34;https://metacpan.org/pod/Perl::Critic::Policy::ValuesAndExpressions::PreventSQLInjection&#34;&gt;policy&lt;/a&gt; to check for potential SQL injection vulnerabilities.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:d158258b1d06be868d3b174d51dace7b&#34;&gt;Conclusion&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;You can&amp;rsquo;t always live in the fear of not knowing what data type you are trying to handle &amp;hellip; not trusting your hashes, not trusting your arrays, what&amp;rsquo;s next, not trusting your own code?&lt;/p&gt;

&lt;p&gt;&amp;ndash; &lt;cite&gt;Netanel Rubin, The Perl Jam 2&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As someone who has years of experience writing professional Perl code, and working with Perl programmers, I do not recognize this experience at all. All Netanel has shown is an attack on some example code from a neglected module and a SQL injection bug in a legacy application.&lt;/p&gt;

&lt;p&gt;Is the Ruby language to blame for a vulnerability in &lt;a href=&#34;http://arstechnica.com/business/2012/03/hacker-commandeers-github-to-prove-vuln-in-ruby/&#34;&gt;Ruby-on-Rails&lt;/a&gt;? Is PHP insecure because over 950 &lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=wordpress&#34;&gt;exploits&lt;/a&gt; were found for WordPress? This isn&amp;rsquo;t a dynamic language issue either; in &lt;a href=&#34;http://danluu.com/empirical-pl&#34;&gt;Static vs. dynamic languages: a literature review&lt;/a&gt; author Dan Luu found little evidence that statically typed languages were safer than dynamic ones.&lt;/p&gt;

&lt;p&gt;Anytime you fail to adequately parse untrusted input you&amp;rsquo;re going to have a bad day. Blaming Perl for developers&amp;rsquo; bad code is like blaming the Alphabet for being turned into 50 Shades of Grey.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Port scanning with Perl, Part II</title>
      <link>http://perltricks.com/article/188/2015/8/15/Port-scanning-with-Perl--Part-II/</link>
      <pubDate>Sat, 15 Aug 2015 15:05:31 +0000</pubDate>
      
      <guid>http://perltricks.com/article/188/2015/8/15/Port-scanning-with-Perl--Part-II/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;http://perltricks.com/article/183/2015/7/20/Port-scanning-with-Perl&#34;&gt;part I&lt;/a&gt; of this article, I showed how to develop a basic forking &lt;a href=&#34;https://gist.github.com/dnmfarrell/3db321fc11b0d85f729d&#34;&gt;port scanner&lt;/a&gt; with Perl. In this article, I&amp;rsquo;ll add some enhancements to make this a truly useful tool.&lt;/p&gt;

&lt;h3 id=&#34;scan-a-range-of-ports:09a1df73d25966850efdcad9f84747ad&#34;&gt;Scan a range of ports&lt;/h3&gt;

&lt;p&gt;The first feature I want to add is the ability to scan user-defined port ranges, instead of the default list of named ports. Because I&amp;rsquo;m using &lt;a href=&#34;https://metacpan.org/pod/Getopt::Long&#34;&gt;Getopt::Long&lt;/a&gt; to parse command line arguments, I can add &lt;code&gt;range&lt;/code&gt; to the parameter options:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;GetOptions (
  &#39;ip=s&#39;        =&amp;gt; \ my $target_ip,
  &#39;range=s&#39;     =&amp;gt; \ my $port_range,
  &#39;h|help|?&#39;    =&amp;gt; sub { pod2usage(2) },
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The port processing &lt;a href=&#34;https://gist.github.com/dnmfarrell/3db321fc11b0d85f729d#file-port_scanner-L53-L57&#34;&gt;code&lt;/a&gt; becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# use named ports if no range was provided
my @ports = shuffle do {
  unless ($port_range)
  {
    map { $port_directory{$_}-&amp;gt;{port} }
      grep { $port_directory{$_}-&amp;gt;{name} !~ /^unknown$/
             &amp;amp;&amp;amp; $port_directory{$_}-&amp;gt;{proto} eq $protocol } keys %port_directory;
  }
  else
  {
    my ($min, $max) = $port_range =~ /([0-9]+)-([0-9]+)/
      or die &amp;quot;port-range must be formatted like this: 100-1000\n&amp;quot;;
    $min..$max;
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I check for the presence of the &lt;code&gt;$port_range&lt;/code&gt; variable, and if it&amp;rsquo;s present I try to parse the minimum and maximum ports using a regex capture. I like this code pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my ($min, $max) = $port_range =~ /([0-9]+)-([0-9]+)/
      or die &amp;quot;port-range must be formatted like this: 100-1000\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because either the port range will be successfully parsed into &lt;code&gt;$min&lt;/code&gt; and &lt;code&gt;$max&lt;/code&gt; or an exception with be thrown. By passing a string ending in a newline to &lt;code&gt;die&lt;/code&gt;, it won&amp;rsquo;t print out a line reference, which makes for cleaner &amp;ldquo;usage&amp;rdquo; style messages.&lt;/p&gt;

&lt;h3 id=&#34;tune-processes-and-frequency:09a1df73d25966850efdcad9f84747ad&#34;&gt;Tune processes and frequency&lt;/h3&gt;

&lt;p&gt;The simple &lt;a href=&#34;https://gist.github.com/dnmfarrell/3db321fc11b0d85f729d&#34;&gt;port scanner&lt;/a&gt; initiates 50 processes, divides the ports to be scanned evenly between all processes, with each process sending one request per second. There are a few issues with this. Firstly if the user wants to scan all 65,535 ports the program will run for at least 20 minutes, which is quite slow. Secondly, some hosts have dynamic firewalls which will start dropping packets if they detect a port scan, so the user may want to be stealthy and slow down the scan speed &lt;em&gt;further&lt;/em&gt;. Ideally then, we should let the user define how many processes to run and how much to delay between each sent packet.&lt;/p&gt;

&lt;p&gt;To capture those arguments, I can add &lt;code&gt;procs&lt;/code&gt; and &lt;code&gt;delay&lt;/code&gt; to &lt;code&gt;GetOptions&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;GetOptions (
  &#39;delay=f&#39;     =&amp;gt; \(my $delay = 1),
  &#39;ip=s&#39;        =&amp;gt; \ my $target_ip,
  &#39;range=s&#39;     =&amp;gt; \ my $port_range,
  &#39;procs=i&#39;     =&amp;gt; \(my $procs = 50),
  &#39;h|help|?&#39;    =&amp;gt; sub { pod2usage(2) },
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code does a few neat things: by using the &lt;code&gt;=i&lt;/code&gt; definition, &lt;code&gt;GetOptions&lt;/code&gt; will do integer type checking for the number of processors. Likewise &lt;code&gt;=f&lt;/code&gt; will enforce a floating-point number type. The other thing this code does is declare and set a default value for the variables within the &lt;code&gt;GetOptions&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;To support &lt;code&gt;sleep&lt;/code&gt; for floating point seconds, I need to import the &lt;a href=&#34;https://metacpan.org/pod/Time::HiRes&#34;&gt;Time::HiRes&lt;/a&gt; module (part of the Perl core):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Time::HiRes &#39;sleep&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the forking &lt;a href=&#34;https://gist.github.com/dnmfarrell/3db321fc11b0d85f729d#file-port_scanner-L68-L91&#34;&gt;code&lt;/a&gt; can become:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;for (1..$procs)
{
  my @ports_to_scan = splice @ports, 0, $batch_size;
  my $parent = fork;
  die &amp;quot;unable to fork!\n&amp;quot; unless defined ($parent);

  if ($parent)
  {
    push(@child_pids, $parent);
    next;
  }

  # child waits until the parent signals to continue
  my $continue = 0;
  local $SIG{CONT} = sub { $continue = 1};
  until ($continue) {}

  for my $target_port (@ports_to_scan)
  {
    sleep($delay);
    send_packet($protocol, $target_port, $flags);
  }
  exit 0; # exit child
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the scanner will now fork &lt;code&gt;$procs&lt;/code&gt; number of processes, and sleep &lt;code&gt;$delay&lt;/code&gt; seconds between each sent packet. This should give users the ability to fine-tune the frequency of packets sent and the run time of the scan.&lt;/p&gt;

&lt;h3 id=&#34;reporting:09a1df73d25966850efdcad9f84747ad&#34;&gt;Reporting&lt;/h3&gt;

&lt;p&gt;The simple scanner prints out every scanned port and the port status. This can be too much information - in most cases the user is interested in vulnerable open ports and doesn&amp;rsquo;t care about filtered or closed ones. On the other hand, the output is missing key information that would be required for a security audit: datetime of execution, program version, parameters used, overall runtime etc. So I need to add this information to the output.&lt;/p&gt;

&lt;p&gt;To calculate the program runtime duration, and print the start datetime I can use the &lt;a href=&#34;https://metacpan.org/pod/Time::Piece&#34;&gt;Time::Piece&lt;/a&gt; module. The module is part of core Perl so there is no need to install it, plus you can do &lt;a href=&#34;http://perltricks.com/article/59/2014/1/10/Solve-almost-any-datetime-need-with-Time--Piece&#34;&gt;almost anything&lt;/a&gt; with it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Time::Piece;

my $start_time = localtime;

...

my $end_time = localtime;
my $duration = $end_time - $start_time;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you import Time::Piece it overrides the localtime and gmtime built in functions to construct Time::Piece objects. Subtracting the start and end times returns a Time::Seconds object which is our runtime duration. Both object types nicely format when printed, so that&amp;rsquo;s all we need to do here. Simple!&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll add a &lt;code&gt;verbose&lt;/code&gt; option to &lt;code&gt;GetOptions&lt;/code&gt;. If this is present, we&amp;rsquo;ll print out all port results, else just the open ones:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;GetOptions (
  &#39;delay=f&#39;     =&amp;gt; \(my $delay = 1),
  &#39;ip=s&#39;        =&amp;gt; \ my $target_ip,
  &#39;range=s&#39;     =&amp;gt; \ my $port_range,
  &#39;procs=i&#39;     =&amp;gt; \(my $procs = 50),
  &#39;verbose&#39;     =&amp;gt; \ my $verbose,
  &#39;h|help|?&#39;    =&amp;gt; sub { pod2usage(2) },
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how for boolean parameters no type declaration is given to &lt;code&gt;GetOptions&lt;/code&gt; (e.g. no &lt;code&gt;=i&lt;/code&gt;). This means that on the command line the user just has to type either &lt;code&gt;--verbose&lt;/code&gt; or &lt;code&gt;-v&lt;/code&gt; and &lt;code&gt;$verbose&lt;/code&gt; will be given a true value.&lt;/p&gt;

&lt;p&gt;Instead of printing out port results in the &lt;code&gt;read_packet()&lt;/code&gt; &lt;a href=&#34;https://gist.github.com/dnmfarrell/3db321fc11b0d85f729d#file-port_scanner-L145&#34;&gt;subroutine&lt;/a&gt;, I&amp;rsquo;m going to return the port number and status back to the calling code and defer the printing until later. This simple change has a two benefits: it&amp;rsquo;s more flexible: I can add more packet parsing routines to &lt;code&gt;read_packet()&lt;/code&gt; without having to add multiple print statements and I can sort the port scan results before printing them. The program can scan ports in a random order but the output should be orderly!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;for (sort { $a &amp;lt;=&amp;gt; $b } keys %port_scan_results)
{
  printf &amp;quot; %5u %-15s %-40s\n&amp;quot;, $_, $port_scan_results{$_}, ($port_directory{&amp;quot;$_/$protocol&amp;quot;}-&amp;gt;{name} || &#39;&#39;)
    if $port_scan_results{$_} =~ /open/ || $verbose;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach has one downside - the results will not be printed to the terminal until all responses have been received or the packet capture times out. What would be &lt;em&gt;really&lt;/em&gt; nice would be to print the sorted results as they are received. For example if we were scanning ports 1 to 100 and had received responses for ports 1 through 10, print those results and wait until we receive a response for port 11. This improvement is left as an exercise for the reader (pull requests welcome!).&lt;/p&gt;

&lt;h3 id=&#34;support-different-types-of-scan:09a1df73d25966850efdcad9f84747ad&#34;&gt;Support different types of scan&lt;/h3&gt;

&lt;p&gt;The simple scanner does a TCP &amp;ldquo;SYN&amp;rdquo; scan. This is a good default, but there are many different &lt;a href=&#34;http://nmap.org/book/man-port-scanning-techniques.html&#34;&gt;types&lt;/a&gt; of port scans we can undertake, which can yield better results against different systems. For example in my testing I&amp;rsquo;ve found the TCP SYN scan relatively useless against Chromebooks and mobile devices.&lt;/p&gt;

&lt;p&gt;As with the other updates, I&amp;rsquo;m going to add new parameters to the &lt;code&gt;GetOptions&lt;/code&gt; function. I want to capture the protocol to use (e.g. TCP, UDP, ICMP) and any flags that should be added to the sent packet. These two variables should give us enough flexibility to support a variety of scans.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;GetOptions (
  &#39;delay=f&#39;     =&amp;gt; \(my $delay = 1),
  &#39;ip=s&#39;        =&amp;gt; \ my $target_ip,
  &#39;range=s&#39;     =&amp;gt; \ my $port_range,
  &#39;procs=i&#39;     =&amp;gt; \(my $procs = 50),
  &#39;type=s&#39;      =&amp;gt; \(my $protocol = &#39;tcp&#39;),
  &#39;flag=s&#39;      =&amp;gt; \ my @flags,
  &#39;verbose&#39;     =&amp;gt; \ my $verbose,
  &#39;h|help|?&#39;    =&amp;gt; sub { pod2usage(2) },
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You might be wondering how it&amp;rsquo;s possible to read the &lt;code&gt;flag&lt;/code&gt; string parameter into the &lt;code&gt;@flags&lt;/code&gt; array. In this scenario, I want to be able to accept one or more flag arguments, so the user can pass them to the port scanner like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ ./port_scanner -flag fin -flag psh -flag urg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or more tersely:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ ./port_scanner -f fin -f psh -f urg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These values will be captured into &lt;code&gt;@flags&lt;/code&gt;. By the way, those three flags are part of a TCP port scanning technique called the &amp;ldquo;Xmas&amp;rdquo; scan. To process the flags I&amp;rsquo;ll use this code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;die &amp;quot;flags are for tcp only!\n&amp;quot; if $protocol ne &#39;tcp&#39; &amp;amp;&amp;amp; @flags;
$flags[0] = &#39;syn&#39; unless @flags || $protocol eq &#39;udp&#39;;
my $flags = { map { $_ =&amp;gt; 1 } @flags };
$flags = {} if exists $flags-&amp;gt;{null};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flags can only be passed for TCP scans, so the first thing thing I&amp;rsquo;m checking here is if we received any flags and the requested protocol is &lt;em&gt;not&lt;/em&gt; TCP, which will raise an exception. The code then reads &lt;code&gt;@flags&lt;/code&gt; into a hashref, defaulting to SYN if the protocol is TCP and no flags were passed. We also support a special type of scan the &amp;ldquo;null&amp;rdquo; scan where no flags are passed at all.&lt;/p&gt;

&lt;p&gt;Now the &lt;a href=&#34;https://gist.github.com/dnmfarrell/3db321fc11b0d85f729d#file-port_scanner-L125-L139&#34;&gt;send_packet&lt;/a&gt; subroutine can be updated to handle different protocols and scans:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub send_packet
{
  my ($protocol, $target_port, $flags) = @_;

  Net::RawIP-&amp;gt;new({ ip =&amp;gt; {
                      saddr =&amp;gt; $local_ip,
                      daddr =&amp;gt; $target_ip,
                    },
                    $protocol =&amp;gt; {
                      source =&amp;gt; $local_port,
                      dest   =&amp;gt; $target_port,
                      %$flags,
                    },
                  })-&amp;gt;send;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The updated subroutine transparently passes the arguments received to &lt;a href=&#34;https://metacpan.org/pod/Net::RawIP&#34;&gt;Net::RawIP&lt;/a&gt;, which handles the details. The remaining ip and port variables are globals and already defined by this point in the code.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://gist.github.com/dnmfarrell/3db321fc11b0d85f729d#file-port_scanner-L145-L171&#34;&gt;read_packet&lt;/a&gt; subroutine also needs to be updated to parse different packet types:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub read_packet
{
  my $raw_data = shift;
  my $ip_data = NetPacket::Ethernet::strip($raw_data);
  my $ip_packet = NetPacket::IP-&amp;gt;decode($ip_data);

  if ($ip_packet-&amp;gt;{proto} == 6)
  {
    my $tcp = NetPacket::TCP-&amp;gt;decode(NetPacket::IP::strip($ip_data));
    my $port = $tcp-&amp;gt;{src_port};

    if ($tcp-&amp;gt;{flags} &amp;amp; SYN)
    {
      return ($port, &#39;open&#39;);
    }
    elsif ($tcp-&amp;gt;{flags} &amp;amp; RST)
    {
      return ($port, &#39;closed&#39;);
    }
    return ($port, &#39;unknown&#39;);
  }
  elsif ($ip_packet-&amp;gt;{proto} == 17)
  {
    my $udp = NetPacket::UDP-&amp;gt;decode(NetPacket::IP::strip($ip_data));
    my $port = $udp-&amp;gt;{src_port};
    return ($port, &#39;open&#39;);
  }
  else
  {
    warn &amp;quot;Received unknown packet protocol: $ip_packet-&amp;gt;{proto}\n&amp;quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we receive a TCP packet, the code examines the packet flags to determine the status of the port. A port is considered open if we receive an ACK/SYN response, which can be tested for by checking the presence of the &lt;code&gt;SYN&lt;/code&gt; flag. An &lt;code&gt;RST&lt;/code&gt; flag indicates the port is closed. Note that to test for presence of the flag we use bitwise &lt;code&gt;&amp;amp;&lt;/code&gt; against the flag constants exported by &lt;a href=&#34;https://metacpan.org/pod/NetPacket::TCP&#34;&gt;NetPacket::TCP&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;UDP is a simpler affair as it doesn&amp;rsquo;t support flags. If we receive a UDP datagram, we treat the port as open.&lt;/p&gt;

&lt;h4 id=&#34;icmp:09a1df73d25966850efdcad9f84747ad&#34;&gt;ICMP&lt;/h4&gt;

&lt;p&gt;Even though we&amp;rsquo;re not sending ICMP messages, we may receive them from the target host. Sometimes hosts return an ICMP message of type &amp;ldquo;destination port unreachable&amp;rdquo; instead of replying with a TCP/UDP packet. The ICMP message will include the IP header of the sender&amp;rsquo;s original message, but IP headers do not include destination ports, so how could we determine the destination port from the ICMP response? One way could be to include the destination port in the data portion of the IP packet. Once we receive the ICMP response, we parse out the IP header and extract the destination port from the data component of the message.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s not all we can do with ICMP responses. An ICMP response can also indicate that a dynamic firewall has started dropping our packets as we&amp;rsquo;ve exceed a rate-limit. It would be nice if an ICMP message was received, the port scanner automatically increased the delay between sending messages. To communicate this update to the sub-processes, we could install a signal handler. In order to &amp;ldquo;see&amp;rdquo; ICMP message responses, the pcap filter would need to be updated to remove the port clause. This introduces a new problem: we may receive messages from the target host that are unrelated to our scan. For now I&amp;rsquo;ve avoided handling ICMP.&lt;/p&gt;

&lt;h3 id=&#34;running-the-new-port-scanner:09a1df73d25966850efdcad9f84747ad&#34;&gt;Running the new port scanner&lt;/h3&gt;

&lt;p&gt;So that&amp;rsquo;s it! The full code can be found &lt;a href=&#34;https://github.com/dnmfarrell/Penetration-Testing-With-Perl/blob/master/port_scanner&#34;&gt;here&lt;/a&gt;. Now let&amp;rsquo;s see some examples of how to run the code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# tcp syn scan of common ports, 100 processes sending packets every 0.25 sec:
$ sudo $(which perl) -i 192.168.1.5 -p 100 -d 0.25

# same as before but print all closed and filtered ports too
$ sudo $(which perl) -i 192.168.1.5 -p 100 -d 0.25 -v

# udp scan
$ sudo $(which perl) -i 192.168.1.5 -t udp

# tcp fin scan
$ sudo $(which perl) -i 192.168.1.5 -f fin

# tcp null scan
$ sudo $(which perl) -i 192.168.1.5 -f null

# tcp xmas scan
$ sudo $(which perl) -i 192.168.1.5- f fin -f psh -f urg
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion:09a1df73d25966850efdcad9f84747ad&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve built something that&amp;rsquo;s beginning to resemble a professional tool: a customizable, high performance TCP/UDP port scanner with useful reporting. By developing our own solution and not relying on tools like nmap, we can achieve a deeper understanding of how networking works and the skills required to scan a host.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Port scanning with Perl</title>
      <link>http://perltricks.com/article/183/2015/7/20/Port-scanning-with-Perl/</link>
      <pubDate>Mon, 20 Jul 2015 13:14:57 +0000</pubDate>
      
      <guid>http://perltricks.com/article/183/2015/7/20/Port-scanning-with-Perl/</guid>
      <description>

&lt;p&gt;My recent infosec articles have focused on livehost discovery on a network. Inspired by Douglas Berdeaux&amp;rsquo;s &lt;a href=&#34;https://www.packtpub.com/networking-and-servers/penetration-testing-perl-raw&#34;&gt;Penetration Testing with Perl&lt;/a&gt;, I&amp;rsquo;ve assembled a potent &lt;a href=&#34;https://github.com/dnmfarrell/Penetration-Testing-With-Perl&#34;&gt;collection&lt;/a&gt; of livehost scanners including ARP, echo, SMB and Netbios. Each of these have different strengths and weaknesses. Regardless, once you&amp;rsquo;ve discovered a livehost and you want to probe for vulnerabilities, a port scan is the logical next step.&lt;/p&gt;

&lt;h3 id=&#34;port-scanning-explained:0226148b78d51ab3b712e314ee5a8000&#34;&gt;Port Scanning Explained&lt;/h3&gt;

&lt;p&gt;An IP address identifies the network location of a computer, but once the computer receives a UDP datagram or TCP packet it then needs to decide where to route it internally within itself. Every TCP/UDP parcel contains a &amp;ldquo;destination port&amp;rdquo; field, which is where the computer will attempt to deliver the packet/datagram. Every computer has 65,535 available TCP and UDP ports for services to use. Many are already assigned for common services, like 22 for SSH, 25 for SMTP and 80 for HTTP.&lt;/p&gt;

&lt;p&gt;Port scanning is the act of probing the ports of another computer to understand which ports are &amp;ldquo;open&amp;rdquo; (have services listening on them), &amp;ldquo;filtered&amp;rdquo; (prevented access by a firewall) and &amp;ldquo;closed&amp;rdquo; (have no services listening on them). Once the attacker has an idea of which ports are open, they can begin probing those services for weaknesses. For example, if I ran a port scan against a remote server and found port 25 SMTP to be open, I could try a number of attacks against it. I could telnet to the livehost&amp;rsquo;s IP address on port 25, and attempt to discover a username on the system using the &amp;lsquo;VRFY&amp;rsquo; command. Once I had a username, I could proceed with a brute force password cracking attempt - possibly on port 22 or against a web application if it was running on the host. I may not even need a username and password if I succeed in a buffer overflow attack against the email service listening on port 25.&lt;/p&gt;

&lt;h3 id=&#34;port-scanning-with-perl:0226148b78d51ab3b712e314ee5a8000&#34;&gt;Port scanning with Perl&lt;/h3&gt;

&lt;p&gt;A basic port scanner needs to be able to take an IP address of a livehost, enumerate a list of ports, send a packet to each port on the livehost and listen and decode the responses. Perl has a number of modules that make this easier. I&amp;rsquo;m going to step through each requirement one by one.&lt;/p&gt;

&lt;h4 id=&#34;parsing-command-line-arguments:0226148b78d51ab3b712e314ee5a8000&#34;&gt;Parsing command line arguments&lt;/h4&gt;

&lt;p&gt;We can use &lt;a href=&#34;https://metacpan.org/pod/Getopt::Long&#34;&gt;Getopt::Long&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Pod::Usage&#34;&gt;Pod::Usage&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Getopt::Long;
use Pod::Usage;

GetOptions (
  &#39;help|?&#39;    =&amp;gt; sub { pod2usage(2) },
  &#39;ip=s&#39;      =&amp;gt; \my $target_ip,
);

# validate required args are given
die &amp;quot;Missing --ip parameter, try --help\n&amp;quot; unless $target_ip;

__END__

=head1 NAME

port_scanner - a concurrent randomized tcp/udp port scanner written in Perl

=head1 SYNOPSIS

port_scanner [options]

 Options:
  --ip,     -i   ip address to scan e.g. 10.30.1.52
  --help,   -h   display this help text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;GetOptions&lt;/code&gt; function parses command line arguments and assigns them to variables. Getop::Long can handle shortened option names so &lt;code&gt;--ip 10.0.1.5&lt;/code&gt; and &lt;code&gt;-i 10.0.1.5&lt;/code&gt; will both assign the IP address to the variable &lt;code&gt;$target_ip&lt;/code&gt;. If the program receives &lt;code&gt;--help&lt;/code&gt;, &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;-?&lt;/code&gt; it will print out the documentation using &lt;code&gt;pod2usage&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;discovering-the-local-ip-and-port:0226148b78d51ab3b712e314ee5a8000&#34;&gt;Discovering the local IP and port&lt;/h4&gt;

&lt;p&gt;To send an IP packet, we need both the destination and the local IP address. We&amp;rsquo;ll also need a local port.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Net::Address::IP::Local;
use IO::Socket::INET;

my $local_ip   = Net::Address::IP::Local-&amp;gt;public;

# find a random free port by opening a socket using the protocol
my $local_port = do {
  my $socket = IO::Socket::INET-&amp;gt;new(Proto =&amp;gt; &#39;tcp&#39;, LocalAddr =&amp;gt; $local_ip);
  my $socket_port = $socket-&amp;gt;sockport();
  $socket-&amp;gt;close;
  $socket_port;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the local ip address, I call the &lt;code&gt;public&lt;/code&gt; method provided by the &lt;a href=&#34;https://metacpan.org/pod/Net::Address::IP::Local&#34;&gt;Net::Address::IP::Local&lt;/a&gt; module. Easy! Finding a local port that is available is more involved. In theory any unnamed port should be available, but there might be another service already using it. Instead I create a new socket object using &lt;a href=&#34;https://metacpan.org/pod/IO::Socket::INET&#34;&gt;IO::Socket::INET&lt;/a&gt; without specifying a local port. Under the hood, this attempts to open a socket on port zero, and the operating system will then automatically assign an available port to the socket (zero is reserved). This has the added benefit of randomizing the local port used by the scanner every time it runs. I then save the port number the socket was opened on, and close the socket.&lt;/p&gt;

&lt;h4 id=&#34;getting-a-list-of-ports-to-scan:0226148b78d51ab3b712e314ee5a8000&#34;&gt;Getting a list of ports to scan&lt;/h4&gt;

&lt;p&gt;For our simple scanner, I&amp;rsquo;ll focus on scanning named ports, that is port numbers pre-assigned to services by the &lt;a href=&#34;http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml&#34;&gt;IANA&lt;/a&gt;. Fortunately for us, the developers behind the popular NMAP tool have already assembled a text &lt;a href=&#34;https://github.com/dnmfarrell/Penetration-Testing-With-Perl/blob/master/data/nmap-services.txt&#34;&gt;file&lt;/a&gt; of named ports, and I&amp;rsquo;ll use this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use List::Util &#39;shuffle&#39;;

my %port_directory;
open my $port_file, &#39;&amp;lt;&#39;, &#39;data/nmap-services.txt&#39;
  or die &amp;quot;Error reading data/nmap-services.txt $!\n&amp;quot;;

while (&amp;lt;$port_file&amp;gt;)
{
  next if /^#/; # skip comments
  chomp;
  my ($name, $number_protocol, $probability, $comments) = split /\t/;
  my ($port, $proto) = split /\//, $number_protocol;

  $port_directory{$number_protocol} = {
    port        =&amp;gt; $port,
    proto       =&amp;gt; $proto,
    name        =&amp;gt; $name,
    probability =&amp;gt; $probability,
    comments    =&amp;gt; $comments,
  };free
}

my @ports = shuffle do {
    map { $port_directory{$_}-&amp;gt;{port} }
      grep { $port_directory{$_}-&amp;gt;{name} !~ /^unknown$/
             &amp;amp;&amp;amp; $port_directory{$_}-&amp;gt;{proto} eq &#39;tcp&#39; } keys %port_directory;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code starts by importing the &lt;code&gt;shuffle&lt;/code&gt; function from &lt;a href=&#34;https://metacpan.org/pod/List::Util&#34;&gt;List::Util&lt;/a&gt;, which I use later to randomize the order of the list of ports. I then open a filehandle to the nmap-services text file, loop through it building the &lt;code&gt;%port_directory&lt;/code&gt; hash. Finally I loop through the the port directory with &lt;code&gt;grep&lt;/code&gt;, extracting all the tcp ports not labeled &amp;ldquo;unknown&amp;rdquo;, use &lt;code&gt;map&lt;/code&gt; to extract the port number from the hash, shuffling the port numbers to randomize their entry into &lt;code&gt;@ports&lt;/code&gt; (shuffle may be unnecessary in newer versions of Perl as hash key order is randomized anyway).&lt;/p&gt;

&lt;h4 id=&#34;sending-packets-and-listening-for-responses:0226148b78d51ab3b712e314ee5a8000&#34;&gt;Sending packets and listening for responses&lt;/h4&gt;

&lt;p&gt;We need to send packets and listen for responses simultaneously, because if we send the packets first and &lt;em&gt;then&lt;/em&gt; listen for packets, we might have missed some responses in the interim. To do this I use &lt;code&gt;fork&lt;/code&gt; to create child processes for sending packets, and use the parent process to listen for responses.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Net::Pcap;
use POSIX qw/WNOHANG ceil/;

# apportion the ports to scan between processes
my $procs = 50;
my $batch_size = ceil(@ports / $procs);
my %total_ports = map { $_ =&amp;gt; &#39;filtered&#39; } @ports; # for reporting
my @child_pids;

for (1..$procs)
{
  my @ports_to_scan = splice @ports, 0, $batch_size;
  my $parent = fork;
  die &amp;quot;unable to fork!\n&amp;quot; unless defined ($parent);

  if ($parent)
  {
    push(@child_pids, $parent);
    next;
  }

  # child waits until the parent signals to continue
  my $continue = 0;
  local $SIG{CONT} = sub { $continue = 1};
  until ($continue) {}

  for my $target_port (@ports_to_scan)
  {
    sleep(1);
    send_packet($target_port);
  }
  exit 0; # exit child
}

# setup parent packet capture
my $device_name = pcap_lookupdev(\my $err);
pcap_lookupnet($device_name, \my $net, \my $mask, \$err);
my $pcap = pcap_open_live($device_name, 1024, 0, 1000, \$err);
pcap_compile(
  $pcap,
  \my $filter,
  &amp;quot;(src net $target_ip) &amp;amp;&amp;amp; (dst port $local_port)&amp;quot;,
  0,
  $mask
);
pcap_setfilter($pcap,$filter);

# signal the child pids to start sending
kill CONT =&amp;gt; $_ for @child_pids;

until (waitpid(-1, WNOHANG) == -1) # until all children exit
{
  my $packet_capture = pcap_next_ex($pcap,\my %header,\my $packet);

  if($packet_capture == 1)
  {
    read_packet($packet);
  }
  elsif ($packet_capture == -1)
  {
    warn &amp;quot;libpcap errored while reading a packet\n&amp;quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a lot of code to process, but l&amp;rsquo;m going to cover the broad strokes. The code forks 50 child processes and assigns a batch of ports to each child. I install a signal handler for the &lt;code&gt;CONT&lt;/code&gt; signal in each child, and pause the child processes until that signal is received. This is to stop the children from going ahead and firing off packets that the parent is not ready to capture. Once all the children have been created, the parent process sets up a packet capture object using &lt;a href=&#34;https://metacpan.org/pod/Lib::Pcap&#34;&gt;Lib::Pcap&lt;/a&gt;. The capture object is given a filter for the &lt;code&gt;$target_ip&lt;/code&gt; and the &lt;code&gt;$local_port&lt;/code&gt; which we discovered earlier.&lt;/p&gt;

&lt;p&gt;The parent then signals the children processes using &lt;code&gt;kill&lt;/code&gt; and the children begin sending packets using &lt;code&gt;send_packet&lt;/code&gt; (defined below). Finally the parent process starts a loop listening for packets using &lt;code&gt;waitpid&lt;/code&gt; to determine when all of the children have finished sending their packets and exited. During the loop, the parent calls &lt;code&gt;read_packet&lt;/code&gt; (defined below) every time it receives a new packet.&lt;/p&gt;

&lt;p&gt;You might be wondering what the constant &lt;code&gt;WNOHANG&lt;/code&gt; is for. When &lt;code&gt;waitpid&lt;/code&gt; is called with -1, it attempts to reap any terminated child processes. In the excellent &lt;a href=&#34;http://www.amazon.com/Network-Programming-Perl-Lincoln-Stein/dp/0201615711&#34;&gt;Network Programming with Perl&lt;/a&gt;, Lincoln Stein explains there are three scenarios which can cause &lt;code&gt;waitpid&lt;/code&gt; to hang or lose track of child processes; if a child process is terminated or restarted by a signal, if two child processes terminate at virtually the same time or if the parent process inadvertently creates new children via system calls. &lt;code&gt;WNOHANG&lt;/code&gt; protects against these scenarios to ensure all child processes will be properly reaped by the parent process.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s look at the &lt;code&gt;send_packet&lt;/code&gt; subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Net::RawIP;

sub send_packet
{
  my ($target_port) = @_;

  Net::RawIP-&amp;gt;new({ ip =&amp;gt; {
                      saddr =&amp;gt; $local_ip,
                      daddr =&amp;gt; $target_ip,
                    },
                    tcp =&amp;gt; {
                      source =&amp;gt; $local_port,
                      dest   =&amp;gt; $target_port,
                      syn =&amp;gt; 1,
                    },
                  })-&amp;gt;send;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code uses the much under-appreciated &lt;a href=&#34;https://metacpan.org/pod/Net::RawIP&#34;&gt;Net::RawIP&lt;/a&gt; module to craft TCP packets and send them to our target destination. We set the SYN flag to 1 to trigger the beginning of a three-way TCP connection which we will never complete. This is a stealthy way to discover ports - by not completing the handshake our requests will not be logged unless the target has been configured to capture this data.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;read_packet&lt;/code&gt; subroutine is a bit more involved:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use NetPacket::Ethernet;
use NetPacket::IP;
use NetPacket::TCP;

sub read_packet
{
  my ($raw_data) = @_;
  my $ip_data = NetPacket::Ethernet::strip($raw_data);
  my $ip_packet = NetPacket::IP-&amp;gt;decode($ip_data);

  # is it TCP
  if ($ip_packet-&amp;gt;{proto} == 6)
  {
    my $tcp = NetPacket::TCP-&amp;gt;decode(NetPacket::IP::strip($ip_data));
    my $port = $tcp-&amp;gt;{src_port};
    my $port_name = exists $port_directory{&amp;quot;$port/tcp&amp;quot;}
      ? $port_directory{&amp;quot;$port/tcp&amp;quot;}-&amp;gt;{name}
      : &#39;&#39;;

    if ($tcp-&amp;gt;{flags} &amp;amp; SYN)
    {
      printf &amp;quot; %5d %-20s %-20s\n&amp;quot;, $port, &#39;open&#39;, $port_name;
      $total_ports{$port} = &#39;open&#39;;
    }
    elsif ($tcp-&amp;gt;{flags} &amp;amp; RST)
    {
      printf &amp;quot; %5d %-20s %-20s\n&amp;quot;, $port, &#39;closed&#39;, $port_name;
      $total_ports{$port} = &#39;closed&#39;;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I use the &lt;a href=&#34;https://metacpan.org/pod/NetPacket&#34;&gt;NetPacket&lt;/a&gt; distribution to parse the incoming packets. The first check &lt;code&gt;if ($ip_packet-&amp;gt;{proto} == 6)&lt;/code&gt; is to check that we&amp;rsquo;re processing a TCP packet (each protocol has a number - see &lt;a href=&#34;https://en.wikipedia.org/wiki/List_of_IP_protocol_numbers&#34;&gt;list&lt;/a&gt;). The code then parses the TCP packet and looks up the port name in our &lt;code&gt;%port_directory&lt;/code&gt; created earlier. &lt;code&gt;SYN&lt;/code&gt; and &lt;code&gt;RST&lt;/code&gt; are constants exported by &lt;a href=&#34;https://metacpan.org/pod/NetPacket::TCP&#34;&gt;NetPacket::TCP&lt;/a&gt;, which are ANDed against the flags value of the TCP header to identify the type of TCP packet. If we&amp;rsquo;ve received a SYN packet, it looks like the port is open, a RST packet indicates the port is closed.&lt;/p&gt;

&lt;h4 id=&#34;summarizing-the-results:0226148b78d51ab3b712e314ee5a8000&#34;&gt;Summarizing the results&lt;/h4&gt;

&lt;p&gt;Once the port scan has finished, all closed and open ports should have been printed out. But there are also the filtered ports to think about - by definition we&amp;rsquo;ll never receive a response for those. I&amp;rsquo;ve used the &lt;code&gt;%total_ports&lt;/code&gt; hash to track the status of ports. Every port starts as &amp;ldquo;filtered&amp;rdquo;, and is set to &amp;ldquo;open&amp;rdquo; or &amp;ldquo;closed&amp;rdquo; as responses are received. We can then use this data to summarize the results:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;printf &amp;quot;\n %d ports scanned, %d filtered, %d closed, %d open\n&amp;quot;,
  scalar(keys %total_ports),
  scalar(grep { $total_ports{$_} eq &#39;filtered&#39; } keys %total_ports),
  scalar(grep { $total_ports{$_} eq &#39;closed&#39;   } keys %total_ports),
  scalar(grep { $total_ports{$_} eq &#39;open&#39;     } keys %total_ports);

END { pcap_close($pcap) if $pcap }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;END&lt;/code&gt; block executes in the final stage of a Perl program, and closes the packet capture object. This won&amp;rsquo;t execute if the program receives a INT or TERM signal during execution, so I can add signal handlers to ensure Perl shuts down in an orderly way, should a signal be received:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;BEGIN { $SIG{INT} = $SIG{TERM} = sub { exit 0 } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I can add this code near the beginning of the program, but the &lt;code&gt;BEGIN&lt;/code&gt; block ensures it will execute early in the program&amp;rsquo;s startup phase, before the main code is executed.&lt;/p&gt;

&lt;h3 id=&#34;putting-it-together:0226148b78d51ab3b712e314ee5a8000&#34;&gt;Putting it together&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve saved the code into a &lt;a href=&#34;https://gist.github.com/dnmfarrell/3db321fc11b0d85f729d&#34;&gt;program&lt;/a&gt;. Now I can run it on the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ sudo $(which perl) port_scanner --ip 10.0.1.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I need to use &lt;code&gt;sudo&lt;/code&gt; because the libpcap requires root privileges to run. The program emits a lot of output, here&amp;rsquo;s a snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
   264 closed               bgmp                
    48 closed               auditd              
  9100 open                 jetdirect 
  2456 closed               altav-remmgt        
  3914 closed               listcrt-port-2      
    42 closed               nameserver          
  1051 closed               optima-vnet         
  1328 closed               ewall               
  4200 closed               vrml-multi-use      
    65 closed               tacacs-ds           
  8400 closed               cvd                 
  8042 closed               fs-agent            
  1516 closed               vpad                
   702 closed               iris-beep           
  1034 closed               zincite-a           
   598 closed               sco-websrvrmg3      

 2258 ports scanned, 25 filtered, 2229 closed, 4 open
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how the order is randomized, and we&amp;rsquo;ve found 4 open ports. If I run the program with &lt;code&gt;--help&lt;/code&gt; it prints out some useful instructions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Usage:
    port_scanner [options]

     Options:
      --ip,     -i   ip address to scan e.g. 10.30.1.52
      --help,   -h   display this help text
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wrap-up:0226148b78d51ab3b712e314ee5a8000&#34;&gt;Wrap-up&lt;/h3&gt;

&lt;p&gt;Our basic port scanner could be improved. For one thing we only scan named ports - it would be nice to accept a range of ports to scan. The supported protocols and TCP flags could also be expanded to yield better results against different machines. The user should also be able to control the number of child processes and the packet frequency to tune the scan to the sensitivities of the target. In part two I&amp;rsquo;ll show how to incorporate these changes and more into a fully-featured port scanner.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Host discovery with broadcast and echo</title>
      <link>http://perltricks.com/article/180/2015/7/6/Host-discovery-with-broadcast-and-echo/</link>
      <pubDate>Mon, 06 Jul 2015 12:27:10 +0000</pubDate>
      
      <guid>http://perltricks.com/article/180/2015/7/6/Host-discovery-with-broadcast-and-echo/</guid>
      <description>

&lt;p&gt;Network host discovery is the attempt to elicit the addresses of the hosts connected to a network. Last week I &lt;a href=&#34;http://perltricks.com/article/179/2015/7/1/Basic-network-hacking-with-Perl&#34;&gt;wrote&lt;/a&gt; about a unicast approach with Perl that enumerated through every address in the network subnet, messaging each address in turn to see if any hosts respond. This week I&amp;rsquo;ve been working on an alternative approach using broadcast and echo.&lt;/p&gt;

&lt;h3 id=&#34;icmp-and-echo:1ce3cb0a78c3ebf18e0e797ceac88b1e&#34;&gt;ICMP and echo&lt;/h3&gt;

&lt;p&gt;Internet Control Message Protocol (ICMP) is a networking protocol used by networking devices to coordinate with each other. ICMP messages contain a type and a code which have predefined &lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#Control_messages&#34;&gt;meanings&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;An ICMP message of type 8 means echo request and hosts are expected to respond with an ICMP message of type 0 (echo reply). To discover hosts on a network, I can send an echo request to the network and capture the IP address of any echo replies received. Instead of cycling through every possible IP address in the subnet, I can send the echo request to the broadcast IP: &lt;code&gt;255.255.255.255&lt;/code&gt; and the message will automatically be sent to every host on the network.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re running a modern Linux, you can test this out at the command line using &lt;code&gt;ping&lt;/code&gt; (other versions may work without the &amp;ldquo;-b&amp;rdquo; switch):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ ping -b 255.255.255.255
WARNING: pinging broadcast address
PING 255.255.255.255 (255.255.255.255) 56(84) bytes of data.
64 bytes from 192.168.1.4: icmp_seq=1 ttl=64 time=92.9 ms
64 bytes from 192.168.1.4: icmp_seq=2 ttl=64 time=2.04 ms
64 bytes from 192.168.1.4: icmp_seq=3 ttl=64 time=136 ms
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here you see one other host on my network is responding at the address &lt;code&gt;192.168.1.4&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;implementing-echo-in-perl:1ce3cb0a78c3ebf18e0e797ceac88b1e&#34;&gt;Implementing echo in Perl&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s possible to implement ping using nothing but core Perl modules. That is, if Perl is installed, this &lt;a href=&#34;https://github.com/dnmfarrell/Penetration-Testing-With-Perl/blob/master/livehost_echo&#34;&gt;script&lt;/a&gt; should work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;#!/usr/bin/perl
use strict;
use warnings;
use Socket;
use Net::Ping;

# the checksum must be correct else hosts will ignore the request
my $msg_checksum = Net::Ping-&amp;gt;checksum(pack(&amp;quot;C2 n3&amp;quot;,8,0,0,0,1));
my $msg = pack(&amp;quot;C2 n3&amp;quot;, 8, 0, $msg_checksum, 0, 1);

socket(my $socket, AF_INET, SOCK_RAW, getprotobyname(&#39;icmp&#39;));
setsockopt($socket, SOL_SOCKET, SO_BROADCAST, 1);
send($socket, $msg, 0, sockaddr_in(0, inet_aton(&#39;255.255.255.255&#39;)));
bind($socket,sockaddr_in(0,inet_aton(0)));

while (1)
{
  my $addr = recv($socket, my $data, 1024, 0);
  my ($tmp, $tos, $len, $id, $offset, $tt, $proto, $checksum,
    $src_ip, $dest_ip, $options) = unpack(&#39;CCnnnCCnNNa*&#39;, $data);

  if ($dest_ip != 4294967295) # destination != 255.255.255.255
  {
    my ($port, $peer) = sockaddr_in($addr);
    printf &amp;quot;%s bytes from %s\n&amp;quot;, length($data), inet_ntoa($peer);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script starts by importing the &lt;code&gt;Socket&lt;/code&gt; and &lt;code&gt;Net::Ping&lt;/code&gt; modules - both part of the Perl core distribution. It uses the &lt;code&gt;checksum&lt;/code&gt; function from &lt;code&gt;Net::Ping&lt;/code&gt; to calculate the message checksum. The checksum is important because if it is incorrect, hosts will not reply. The script packs the code, the type, checksum and offset into &lt;code&gt;$msg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The script then creates a broadcast socket, and sends the message to the broadcast address (&lt;code&gt;255.255.255.255&lt;/code&gt;). The socket is then bound to the network address, and the script enters a while loop attempting to read data from the socket using &lt;code&gt;recv&lt;/code&gt;. Any received data is unpacked and the packet address saved in &lt;code&gt;$addr&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The source and destination IP fields in the unpacked message are stored as 32 bit integers, so the script ignores packets whose destination matches the integer of the broadcast address, as this message was sent by the script. After that the script decodes the packet address and prints the results.&lt;/p&gt;

&lt;p&gt;Running this script on my network, I can see the same host as was returned by &lt;code&gt;ping&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ sudo ./livehost_echo                                 
28 bytes from 192.168.1.4
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fingerprinting-hosts:1ce3cb0a78c3ebf18e0e797ceac88b1e&#34;&gt;Fingerprinting hosts&lt;/h3&gt;

&lt;p&gt;The primary issue with this technique is it can only discover hosts that respond to broadcast requests, and many do not. For example Chromebooks, smart phones and Linux machines usually don&amp;rsquo;t reply (OSX machines and many versions of Windows do though). This can be an advantage though: because the response rate to broadcast is different to unicast, the echo script can be used in conjunction with unicast to fingerprint hosts. If a machine responds to a unicast message but not a broadcast, we learn something about the identity of that host. For example if I use the &lt;a href=&#34;https://github.com/dnmfarrell/Penetration-Testing-With-Perl/blob/master/livehost_scanner&#34;&gt;livehost_scanner&lt;/a&gt; script on my home network:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sudo $(which perl) livehost_scanner                                                                                                                  
Gateway IP: 192.168.1.1
Starting scan
192.168.1.1 10:0d:7f:81:31:c2
192.168.1.2 5c:c5:d4:47:0a:13 (this machine)
192.168.1.7 38:e7:d8:00:9a:d5
192.168.1.4 e0:ac:cb:5e:d5:da
192.168.1.10 cc:3d:82:60:4b:95
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I can see that there 2 other livehosts (excluding the router) which show up, but didn&amp;rsquo;t respond to an echo request. The echo script could be adapted to send other types of ICMP messages such as timestamp and subnet mask which can be used to further &lt;a href=&#34;http://www.sans.org/security-resources/idfaq/icmp_misuse.php&#34;&gt;identify&lt;/a&gt; a host.&lt;/p&gt;

&lt;h3 id=&#34;further-thoughts:1ce3cb0a78c3ebf18e0e797ceac88b1e&#34;&gt;Further thoughts&lt;/h3&gt;

&lt;p&gt;The echo script uses the broadcast technique which only works on IPv4 networks. IPv6 networks support multicast instead, but that would require changes to the script. Interestingly the number of potential addresses in a single IPv6 subnet, (I think) renders the unicast technique redundant.&lt;/p&gt;

&lt;p&gt;Another other problem with the echo script is that because it opens a raw socket, it requires root privileges to run. The &lt;code&gt;ping&lt;/code&gt; utility on the other hand is installed with setuserid permissions and runs as root regardless of the user&amp;rsquo;s own privileges.&lt;/p&gt;

&lt;h3 id=&#34;useful-resources:1ce3cb0a78c3ebf18e0e797ceac88b1e&#34;&gt;Useful resources&lt;/h3&gt;

&lt;p&gt;In preparing this script I learned a lot about sockets and network programming. Lincoln Stein&amp;rsquo;s &lt;a href=&#34;http://www.amazon.com/Network-Programming-Perl-Lincoln-Stein/dp/0201615711/ref=la_B000APT5P6_1_1&#34;&gt;Network Programming with Perl&lt;/a&gt; was an invaluable resource for understanding sockets and the arcane invocations to use with them. If you&amp;rsquo;re considering working with sockets, the &lt;a href=&#34;https://metacpan.org/pod/IO::Socket&#34;&gt;IO::Socket&lt;/a&gt; module has a cleaner interface than the &lt;a href=&#34;https://metacpan.org/pod/Socket&#34;&gt;Socket&lt;/a&gt; module (and is also part of core). The source code for the excellent &lt;a href=&#34;https://metacpan.org/pod/NetPacket&#34;&gt;NetPacket&lt;/a&gt; distribution was useful in understanding how to parse packets.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Basic network hacking with Perl</title>
      <link>http://perltricks.com/article/179/2015/7/1/Basic-network-hacking-with-Perl/</link>
      <pubDate>Wed, 01 Jul 2015 12:51:31 +0000</pubDate>
      
      <guid>http://perltricks.com/article/179/2015/7/1/Basic-network-hacking-with-Perl/</guid>
      <description>

&lt;p&gt;Recently I&amp;rsquo;ve been reading &lt;a href=&#34;https://www.packtpub.com/networking-and-servers/penetration-testing-perl-raw&#34;&gt;Penetration Testing With Perl&lt;/a&gt; by Douglas Berdeaux. The book was released late last year, and whilst Dave Cross gave it a fairly scathing &lt;a href=&#34;http://perlhacks.com/2015/02/penetration-testing-perl/&#34;&gt;review&lt;/a&gt; I&amp;rsquo;ve found it interesting so far. I&amp;rsquo;ve been coding and refactoring the scripts presented in the book in a GitHub &lt;a href=&#34;https://github.com/dnmfarrell/Penetration-Testing-With-Perl&#34;&gt;repo&lt;/a&gt; as I go. Here is some of the stuff I&amp;rsquo;ve learned so far.&lt;/p&gt;

&lt;h3 id=&#34;livehost-detection:f1808d343c8e37bf4bcdf4923d18881f&#34;&gt;Livehost Detection&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;re connected to a network, it&amp;rsquo;s helpful to know the IP addresses of all of the other hosts on the same network. This &lt;a href=&#34;https://github.com/dnmfarrell/Penetration-Testing-With-Perl/blob/master/livehost_scanner&#34;&gt;script&lt;/a&gt; starts by detecting the network device name (or accepting it as an argument) and initializing a packet capture object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use feature &#39;say&#39;;
use Net::ARP;
use Net::Address::IP::Local;
use Net::Frame::Device;
use Net::Frame::Dump::Online;
use Net::Frame::Simple;
use Net::Netmask;
use Net::Pcap ();

my $network_device_name = $ARGV[0] if @ARGV;

unless ($network_device_name)
{
  $network_device_name = Net::Pcap::pcap_lookupdev(\my $error_msg);
  die &amp;quot;pcap device lookup failed &amp;quot; . ($error_msg || &#39;&#39;)
    if $error_msg || not defined $network_device_name;
}

my $device = Net::Frame::Device-&amp;gt;new(dev =&amp;gt; $network_device_name);

my $pcap = Net::Frame::Dump::Online-&amp;gt;new(
  dev =&amp;gt; $network_device_name,
  filter =&amp;gt; &#39;arp and dst host &#39; . $device-&amp;gt;ip,
  promisc =&amp;gt; 0,
  unlinkOnStop =&amp;gt; 1,
  timeoutOnNext =&amp;gt; 10
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It then detects the gateway IP (the Ip address of the network controller) and sends a broadcast packet to every IP address in the subnet. The packet capture object &lt;code&gt;$pcap&lt;/code&gt; will detect any responses. It then prints out the respondent&amp;rsquo;s IP and MAC address.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;printf &amp;quot;Gateway IP: %s\nStarting scan\n&amp;quot;, $device-&amp;gt;gatewayIp;

$pcap-&amp;gt;start;

for my $ip_address (Net::Netmask-&amp;gt;new($device-&amp;gt;subnet)-&amp;gt;enumerate)
{
  Net::ARP::send_packet(
    $network_device_name,
    $device-&amp;gt;ip,
    $ip_address,
    $device-&amp;gt;mac,
    &amp;quot;ff:ff:ff:ff:ff:ff&amp;quot;, # broadcast
    &amp;quot;request&amp;quot;,
  );
}

until ($pcap-&amp;gt;timeout)
{
  if (my $next = $pcap-&amp;gt;next)
  {
    my $frame = Net::Frame::Simple-&amp;gt;newFromDump($next);
    my $local_ip = Net::Address::IP::Local-&amp;gt;public;
    my $frame_ip = $frame-&amp;gt;ref-&amp;gt;{ARP}-&amp;gt;srcIp;
    my $frame_mac = $frame-&amp;gt;ref-&amp;gt;{ARP}-&amp;gt;src;
    say &amp;quot;$frame_ip $frame_mac&amp;quot;. ($local_ip eq $frame_ip ? &#39; (this machine)&#39; : &#39;&#39;);
  }
}
END { say &amp;quot;Exiting.&amp;quot;; $pcap-&amp;gt;stop }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I run this script on my home network, I get the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ sudo $(which perl) livehost_scanner
Gateway IP: 192.168.1.1
Starting scan
Gateway IP: 192.168.1.1
Starting scan
192.168.1.1 10:0d:7f:81:31:c2
192.168.1.2 5c:c5:d4:47:0a:13 (this machine)
192.168.1.3 68:09:27:03:d0:35
Exiting.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this I can deduce that there is one other machine connected to the network at &lt;code&gt;192.168.1.4&lt;/code&gt;, in addition to the router at &lt;code&gt;192.168.1.1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;fingerprinting:f1808d343c8e37bf4bcdf4923d18881f&#34;&gt;Fingerprinting&lt;/h3&gt;

&lt;p&gt;Now I&amp;rsquo;ve identified the addresses of two hosts on my network, if I was an attacker I would want to try and identify the types of hosts they are, in order to determine which types of attacks to use against them.&lt;/p&gt;

&lt;p&gt;One way to fingerprint a host is using their &lt;a href=&#34;https://en.wikipedia.org/wiki/MAC_address&#34;&gt;MAC address&lt;/a&gt;. The first half of the address is the Organisationally Unique Identifier (OUI). The IEEE provide a &lt;a href=&#34;http://standards-oui.ieee.org/oui.txt&#34;&gt;file&lt;/a&gt; that lists all authorized OUIs and their manufacturer. So to identify the Manufacturer of the network device of the host, all we have to do is lookup their OUI in the file. This &lt;a href=&#34;https://github.com/dnmfarrell/Penetration-Testing-With-Perl/blob/master/id_target&#34;&gt;script&lt;/a&gt; does that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;

my $target_mac = shift or die &amp;quot;Usage\n\t./id_target \n&amp;quot;;

printf &amp;quot;Address: %s, MAC Manufacturer: %s\n&amp;quot;,
  $target_mac, oui_lookup($target_mac);

sub oui_lookup
{
  my $mac_address = shift;
  $mac_address =~ s/:/-/g;
  my $oui = substr $mac_address, 0, 8;

  open (my $oui_file, &#39;&amp;lt;&#39;, &#39;data/oui.txt&#39;) or die $!;
  while (my $line = &amp;lt;$oui_file&amp;gt;)
  {
    if($line =~ /$oui/i)
    {
      my ($address, $manufacturer_name) = split /\t+/, $line;
      return &amp;quot;$manufacturer_name&amp;quot;;
      last;
    }
  }
  return &amp;quot;Unknown&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I run this script on the Gateway MAC address, I can identify the access point manufacturer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ ./id_target 10:0d:7f:81:31:c2
Address: 10:0d:7f:81:31:c2, MAC Manufacturer: NETGEAR INC.,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aha! so the access point is made by Netgear. There was another host detected on my network at address &lt;code&gt;192.168.1.3&lt;/code&gt;. I can try and fingerprint them too:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ ./id_target 68:09:27:03:d0:35
Address: 68:09:27:03:d0:35, MAC Manufacturer: Apple
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s an Apple machine. With this data I can either try to fingerprint the hosts further, or I can start testing them for weaknesses, using a port scan or a known vulnerability. A good source of vulnerabilities is &lt;a href=&#34;http://www.exploit-db.com&#34;&gt;exploit-db.com&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Neutralize Shellshock by patching Bash with Perl</title>
      <link>http://perltricks.com/article/118/2014/10/5/Neutralize-Shellshock-by-patching-Bash-with-Perl/</link>
      <pubDate>Sun, 05 Oct 2014 18:13:45 +0000</pubDate>
      
      <guid>http://perltricks.com/article/118/2014/10/5/Neutralize-Shellshock-by-patching-Bash-with-Perl/</guid>
      <description>

&lt;p&gt;The safest way to protect a system from Shellshock is to upgrade to a patched version of Bash. However if you&amp;rsquo;re like me, you may find that a hectic Linux distro release &lt;a href=&#34;https://fedoraproject.org/wiki/Fedora_Release_Life_Cycle&#34;&gt;schedule&lt;/a&gt; has left your current distribution unsupported. Rather than run the risk of attack, you can patch Bash yourself. Unfortunately some versions of Bash have as many as 52 different &lt;a href=&#34;http://ftp.gnu.org/gnu/bash/bash-4.2-patches/&#34;&gt;patches&lt;/a&gt; that must be downloaded and applied. So I wrote a Perl called &lt;a href=&#34;https://github.com/sillymoose/bashfix&#34;&gt;bashfix&lt;/a&gt; to automate it.&lt;/p&gt;

&lt;h3 id=&#34;requirements:ed436a09d47927d2158a5380875afa81&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;Bashfix has a minimal set of requirements, so you should be able to run it on any Linux platform out of the box:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Perl 5.8 or higher and no extra modules required&lt;/li&gt;
&lt;li&gt;Linux with Bash version 3.* or 4.*&lt;/li&gt;
&lt;li&gt;The following C binaries: wget, curl, bison, byacc, gettext, patch, autoconf&lt;/li&gt;
&lt;li&gt;An internet connection to download Bash and associated patches from GNU&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;synopsis:ed436a09d47927d2158a5380875afa81&#34;&gt;Synopsis&lt;/h3&gt;

&lt;p&gt;Using bashfix is fairly straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ git clone https://github.com/sillymoose/bashfix.git
$ cd bashfix
$ chmod +x bashfix.pl
$ ./bashfix.pl
Bash version 4.2.13 detected
Created working directory /tmp/PIRKRioxmM
Downloading Bash
Downloading Patches
Bash patched to level 52
Bash fully patched!
Configuring Bash ...
Building and testing Bash ...
Success. New Bash binary built!
Making backup copy of /usr/bin/bash at /usr/bin/bash.bak
Making backup copy of /bin/bash at /bin/bash.bak
Bash version 4.2.52 is now installed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bashfix checks that you have Bash installed, and the necessary prerequisites. It then downloads the Bash source for the same Bash version that is already installed on the system (you can patch an old Bash version to be Shellshock-proof). Note that different versions of Bash have different numbers of patches: 4.2 has 52 patches, whilst 4.1 has only 16. After that, bashfix configures, builds and tests Bash, making a backup of your existing Bash binary, before installing the newly patched version.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:ed436a09d47927d2158a5380875afa81&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve tested &lt;a href=&#34;https://github.com/sillymoose/bashfix&#34;&gt;bashfix&lt;/a&gt; on different versions of Fedora and CentOS, and expect that it works with any RHEL flavoured distro. With other Linux distros or Unix systems, your mileage may vary. If you encounter any issues - get in touch and let me know! Check out our recent &lt;a href=&#34;http://perltricks.com/article/115/2014/9/26/Shellshock-and-Perl&#34;&gt;article&lt;/a&gt; on Shellshock and Perl if you&amp;rsquo;d like to know more about the exploit.&lt;/p&gt;

&lt;p&gt;Thanks to Steve Jenkins whose detailed blog &lt;a href=&#34;http://stevejenkins.com/blog/2014/09/how-to-manually-update-bash-to-patch-shellshock-bug-on-older-fedora-based-systems/&#34;&gt;post&lt;/a&gt; on patching Fedora Bash was the inspiration for this script.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Shellshock and Perl</title>
      <link>http://perltricks.com/article/115/2014/9/26/Shellshock-and-Perl/</link>
      <pubDate>Fri, 26 Sep 2014 13:28:54 +0000</pubDate>
      
      <guid>http://perltricks.com/article/115/2014/9/26/Shellshock-and-Perl/</guid>
      <description>

&lt;p&gt;Recently the tech media have been foaming at the mouth over a serious Bash &lt;a href=&#34;https://securityblog.redhat.com/2014/09/24/bash-specially-crafted-environment-variables-code-injection-attack/&#34;&gt;bug&lt;/a&gt; called Shellshock. The media &lt;a href=&#34;http://www.wired.com/2014/09/internet-braces-crazy-shellshock-worm/&#34;&gt;hype machine&lt;/a&gt; was in full-swing, replete with the absurd doomsday-like predictions that are rolled out every time a significant security vulnerability is found (remember heartbleed the &amp;ldquo;&lt;a href=&#34;http://mashable.com/2014/04/09/heartbleed-nightmare/&#34;&gt;ultimate web nightmare&lt;/a&gt;&amp;rdquo;?). Whilst it&amp;rsquo;s wise to ignore the hype, don&amp;rsquo;t ignore the issue; Shellshock is a serious risk that allows remote code injection and execution using Bash environment variables. This is also important for Perl as Perl has several touchpoints with the system shell, from the built-in functions &lt;a href=&#34;http://perldoc.perl.org/functions/exec.html&#34;&gt;exec&lt;/a&gt; and &lt;a href=&#34;http://perldoc.perl.org/functions/system.html&#34;&gt;system&lt;/a&gt; to the &lt;code&gt;%ENV&lt;/code&gt; global variable.&lt;/p&gt;

&lt;h3 id=&#34;is-system-x-affected:cbf69df2f76f739d1dc6efa240f30cc7&#34;&gt;Is system &amp;ldquo;x&amp;rdquo; affected?&lt;/h3&gt;

&lt;p&gt;If the platform is a Unix-based operating system and Bash is the default terminal, it might be at risk. Redhat Linux, CentOS and Fedora, openSUSE, arch Linux as well as Mac OSX are vulnerable out of the box. A surprising number of platforms are not; freeBSD uses &lt;a href=&#34;https://www.freebsd.org/doc/en/articles/linux-users/shells.html&#34;&gt;tsch&lt;/a&gt;, and modern versions of Debian and Ubuntu use &lt;a href=&#34;https://wiki.ubuntu.com/DashAsBinSh&#34;&gt;dash&lt;/a&gt; by default.&lt;/p&gt;

&lt;p&gt;Every version of Bash through 4.3 is vulnerable to Shellshock. To find out your Bash version, fire up the terminal and enter this command to print the version:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ echo $BASH_VERSION
4.2.47(1)-release
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Seeing as my version of Bash is below 4.3, my system is possible vulnerable to Shellshock.&lt;/p&gt;

&lt;h3 id=&#34;how-does-shellshock-work:cbf69df2f76f739d1dc6efa240f30cc7&#34;&gt;How does Shellshock work?&lt;/h3&gt;

&lt;p&gt;Shellshock exploits a flaw in how Bash parses environment variables; Bash allows functions to be stored in environment variables, but the issue is Bash will execute any code placed after the function in the environment variable value. Let&amp;rsquo;s craft an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ export SHELLSHOCK=&amp;quot;() { ignore; };echo danger&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code creates a new environment variable called &lt;code&gt;SHELLSHOCK&lt;/code&gt; (it&amp;rsquo;s customary to have environment variable names in uppercase). The value of the new variable is an anonymous function which does nothing: &lt;code&gt;() { ignore; };&lt;/code&gt; followed by: &lt;code&gt;echo danger&lt;/code&gt; and it&amp;rsquo;s the latter portion of this code which is the risk. Every time Bash processes its environment variables, that code will be executed. For example if I run that statement and then type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ bash -c &amp;quot;echo Hello, World&amp;quot;
danger
Hello, World
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that the word danger was printed, indicating my code embedded in the &lt;code&gt;SHELLSHOCK&lt;/code&gt; variable was executed automatically by Bash. In the case of &lt;code&gt;echo danger&lt;/code&gt; it&amp;rsquo;s harmless, but an attacker could craft a malicious payload that caused irreparable harm, such as identity theft, data destruction or hardware damage.&lt;/p&gt;

&lt;p&gt;In order for the Shellshock exploit to work, the attacker would need to achieve two things. First deliver an environment variable containing malicious code to the target host. Second, get the target host to start a new Bash process. The obvious target candidate for this are web servers hosting CGI scripts. CGI works by passing the request parameters as environment variables (such as the user agent name), if the target CGI script starts a new Bash process, the attack will work. You might be wondering why a script would start a new Bash process, which leads me on to how all of this relates to Perl in the first place.&lt;/p&gt;

&lt;h3 id=&#34;perl-shock:cbf69df2f76f739d1dc6efa240f30cc7&#34;&gt;Perl shock&lt;/h3&gt;

&lt;p&gt;The first thing to say is that Perl has nothing to do with Shellshock, but there are a number of places where Perl may invoke the system shell, and it&amp;rsquo;s these cases to be wary of. On Unix based systems Perl uses the shell binary located at &lt;code&gt;/bin/sh&lt;/code&gt;, which is usually a symlink to the default shell binary (such as Bash). This means if Bash is the default shell on your system, when Perl calls out to &lt;code&gt;/bin/sh&lt;/code&gt; a new Bash process will start, and the environment variables will be processed, thus Perl could be a trigger for invoking a Shellshock attack.&lt;/p&gt;

&lt;p&gt;The Perl built-in functions &lt;code&gt;exec&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt; will invoke a new shell process when used. You can also use backticks to invoke a system command. Other Perl functions &lt;em&gt;may&lt;/em&gt; invoke the shell, for example &lt;code&gt;open&lt;/code&gt; can be used to run system commands.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see an example of Perl triggering Shellshock by invoking the shell via Perl:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl -e &#39;system &amp;quot;echo test&amp;quot;&#39;
test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmm what happened here? The command ran fine but &amp;ldquo;danger&amp;rdquo; was not printed - Shellshock failed. It turns out that Perl doesn&amp;rsquo;t &lt;em&gt;always&lt;/em&gt; invoke the shell using: &lt;code&gt;/bin/sh -c&lt;/code&gt;. Instead to be more efficient, Perl will usually call &lt;a href=&#34;http://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/fork/exec.html&#34;&gt;execvp&lt;/a&gt;. According to &lt;a href=&#34;http://perldoc.perl.org/functions/system.html&#34;&gt;perldoc&lt;/a&gt;, only when the system command contains &lt;a href=&#34;http://www.sal.ksu.edu/faculty/tim/unix_sg/shell/metachar.html&#34;&gt;metacharacters&lt;/a&gt;, will Perl invoke the shell directly. Let&amp;rsquo;s test that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl -e &#39;system &amp;quot;echo test &amp;gt;&amp;gt; test.log&amp;quot;&#39;
danger
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aha, this worked! We used the metacharacters &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; to redirect the output of &lt;code&gt;echo&lt;/code&gt; into a log file, and Perl invoked the shell directly.&lt;/p&gt;

&lt;h3 id=&#34;the-best-defense-is-a-great-offense:cbf69df2f76f739d1dc6efa240f30cc7&#34;&gt;The best defense is a great offense&lt;/h3&gt;

&lt;p&gt;Instead of worrying about whether our system calls contain metacharacters, we can go one better and delete the &lt;code&gt;SHELLSHOCK&lt;/code&gt; environment variable before executing any system command. Perl stores the environment variables in &lt;code&gt;%ENV&lt;/code&gt;, so I&amp;rsquo;ll start by delete the variable from there:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl -e &#39;delete $ENV{SHELLSHOCK};system &amp;quot;echo test &amp;gt;&amp;gt; shellshock.log&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this one liner, I&amp;rsquo;m front-running the risky &lt;code&gt;system&lt;/code&gt;command with a &lt;code&gt;delete&lt;/code&gt; of the &lt;code&gt;SHELLSHOCK&lt;/code&gt; environment variable. I can see this thwarted Shellshock as &amp;ldquo;danger&amp;rdquo; was not printed out. Of course in this test environment I know the name of the dangerous environment variable, but usually I won&amp;rsquo;t, so to find it, you&amp;rsquo;d have to iterate through the &lt;code&gt;%ENV&lt;/code&gt; hash and delete (or substitute) any suspicious variable. This one liner prints risky environment variables by using a regex to identify any environment variable that contains code after a function declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl -E &#39;for (keys %ENV) { say if $ENV{$_} =~ /};.+/ }&#39;
SHELLSHOCK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, it correctly identified the &lt;code&gt;SHELLSHOCK&lt;/code&gt; environment variable and printed it to command line. From here it&amp;rsquo;s a trivial step to delete the variable instead of printing it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl -e &#39;for (keys %ENV) { delete $ENV{$_} if $ENV{$_} =~ /};./ }&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is just a proof-of-concept and may not handle all maliciously crafted Shell environment variables, but with more research, a robust regex could be deployed that completely nullified Shellshock.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:cbf69df2f76f739d1dc6efa240f30cc7&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;To recap, a successful Shellshock attack would need to pass an environment variable containing malicious code to a CGI script on a web server (like Apache), hosted on a vulnerable system, and the CGI script would have to invoke the Shell. For Perl CGI scripts, the system invocation would need to include metacharacters. This seems like a tall order, not yet understood by everyone; like the security &lt;a href=&#34;http://blog.erratasec.com/2014/09/bash-shellshock-bug-is-wormable.html#.VCVkj_ldVqU&#34;&gt;blogger&lt;/a&gt; who mistakenly labelled a cPanel CGI script as vulnerable. Although CGI was popular back in the day, all the modern Perl web frameworks use &lt;a href=&#34;http://www.fastcgi.com/drupal/node/6?q=node/15&#34;&gt;FastCGI&lt;/a&gt; and are immune to Shellshock. Modern web servers do not enable CGI by default and some like nginx do not even ship with CGI capability.&lt;/p&gt;

&lt;p&gt;The safest way to handle Shellshock on a vulnerable system is to patch Bash to the latest version. Although I&amp;rsquo;ve shown it&amp;rsquo;s possible to thwart the attack using Perl, there may be other unanticipated attack vectors that remain open.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Correction:&lt;/strong&gt; &lt;em&gt;removed erroneous description of $SHELL as it is the current user&amp;rsquo;s default login shell, not the default shell. Removed reference to .bashrc as Bash will only process .bashrc during interactive shell startup. 2014-09-27&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Cover image Ebola virus particles &lt;a href=&#34;http://creativecommons.org/licenses/by/4.0/&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.flickr.com/photos/niaid/8425030684/in/photolist-dQuu6J-o15Y5n-oq5wzY-oD1uxC-oq68Cn-8r1Hp8-oDe3A2-oDe3za-dPiDp3-ossh3B-2j1bum-jQvxq9-oq59Z4-oq5muj-omJEd1-omJzrD-4JZtfw-aronSf-8GSyC4-68Zxqv-9y7vkf-dPzNiw-5WLSVq-6hZDW8-nds12g-5Wtkeh-6hNQv2-6irCWw-6iQKwC-bS1gap-Jx5bZ-bjfWK2-bjfWiv-dQSzhC-6iUKSo-6ik4Ki-6i3YrM-cXXqXy-64vTm8-cCwK63-8LVkQh-sxxGP-dTpMUd-Dj4uW-6mhvwX-6iGBED-9rwqiP-8R5WMy-9yXaMc-6isfVm&#34;&gt;NIAID&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Is your login page secure?</title>
      <link>http://perltricks.com/article/84/2014/4/28/Is-your-login-page-secure-/</link>
      <pubDate>Mon, 28 Apr 2014 03:14:13 +0000</pubDate>
      
      <guid>http://perltricks.com/article/84/2014/4/28/Is-your-login-page-secure-/</guid>
      <description>

&lt;p&gt;How many criteria do you think there are for a web application to securely login its users? &lt;a href=&#34;http://www.amazon.com/gp/product/1118026470/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=1118026470&amp;amp;linkCode=as2&amp;amp;tag=perltrickscom-20&#34;&gt;The Web Application Hacker&amp;rsquo;s Handbook&lt;/a&gt; (affiliate link) lists 5:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Prevent information leaks&lt;/li&gt;
&lt;li&gt;Handle credentials secretively&lt;/li&gt;
&lt;li&gt;Validate credentials properly&lt;/li&gt;
&lt;li&gt;Prevent brute-force attacks&lt;/li&gt;
&lt;li&gt;Log, monitor and notify&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So there are 5 criteria, but how you do implement them? I&amp;rsquo;ve created a &lt;a href=&#34;https://github.com/dnmfarrell/SecApp_login&#34;&gt;new web application&lt;/a&gt; called &amp;ldquo;SecApp&amp;rdquo; using Perl&amp;rsquo;s Catalyst web framework that attempts to satisfy these criteria - we&amp;rsquo;ll step through each one and you can judge for yourself if it does.&lt;/p&gt;

&lt;h3 id=&#34;how-to-setup-the-app:ba4c9275de3995b673588b08da4e28c2&#34;&gt;How to setup the app&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;d like to download the app and follow along you can, but this step is optional. You&amp;rsquo;re going to need at least Perl 5.14.4 and a git installed. To download the app from our github page, just open up the command line and enter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ git clone https://github.com/dnmfarrell/SecApp_login
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s no way around it; this app has a lot of dependencies. To ease the burden, start by installing &lt;a href=&#34;https://metacpan.org/pod/App::cpanminus&#34;&gt;cpanminus&lt;/a&gt; at the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpan App::cpanminus
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I prefer to use cpanminus when installing lots of modules: it&amp;rsquo;s less of a memory hog than cpan, outputs less line noise by default, and has the useful &amp;ldquo;&amp;ndash;notest&amp;rdquo; option if you want to install modules without testing them (and save a lot of time). Now change into the newly cloned app directory, and use cpanminus to install the app&amp;rsquo;s dependencies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cd SecApp_login
$ cpanm --installdeps .
--&amp;gt; Working on .
Configuring SecApp-0.01 ... OK
&amp;lt;== Installed dependencies for .. Finishing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;&amp;ndash;installdeps&amp;rdquo; switch instructs cpanminus to search the current directory for dependencies. All of of the app&amp;rsquo;s dependencies are listed in Makefile.PL, so cpanminus finds those and begins installing all of the Perl modules that the app requires but your system does not have installed. If you&amp;rsquo;re working with a fresh install of Perl, this can take up to an hour or so, so go make a cup of coffee or something else whilst the installs happen.&lt;/p&gt;

&lt;p&gt;Once all the modules are installed, test run the application with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ TESTING=1 script/secapp_server.pl 
HTTP::Server::PSGI: Accepting connections at http://0:3000/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Open your browsers and navigate to &lt;a href=&#34;http://localhost:3000&#34;&gt;http://localhost:3000&lt;/a&gt;. You see this simple welcome message:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/84/secapp_welcome.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you visit &lt;a href=&#34;http://localhost/login&#34;&gt;http://localhost/login&lt;/a&gt;, it should load the login page:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/84/secapp_login.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Using the username &amp;ldquo;test_user_01&amp;rdquo; and &amp;ldquo;Hfa *-(&amp;amp;&amp;amp;%HBbWqpV%&amp;rdquo;_=asd&amp;rdquo; you should be able to login.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/84/secapp_login_credentials.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A successful login will display a simple message and logout link:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/84/secapp_landing.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-prevent-information-leaks:ba4c9275de3995b673588b08da4e28c2&#34;&gt;1. Prevent information leaks&lt;/h3&gt;

&lt;p&gt;Information leaks give would-be attackers clues that undermine the login security. One way they do this is by giving information about the software running the web application (which may have known weaknesses).&lt;/p&gt;

&lt;p&gt;In SecApp I&amp;rsquo;ve turned off the typical Catalyst information leaks. In the root application file &lt;a href=&#34;https://github.com/dnmfarrell/SecApp_login/blob/master/lib/SecApp.pm&#34;&gt;SecApp.pm&lt;/a&gt; the &amp;ldquo;-Debug&amp;rdquo; plugin has been removed, which prints a full stack trace in the case of an error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Catalyst qw/
    Static::Simple
    Authentication
    Session
    Session::Store::File
    Session::State::Cookie
/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Further down the same file, the &amp;ldquo;X-Catalyst&amp;rdquo; HTTP header has been disabled by modifying the package configuration. This stops the header from being inserted to every response:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# Disable X-Catalyst header
enable_catalyst_header =&amp;gt; 0,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These two changes stop the application from informing users the underlying application framework and language. Now they won&amp;rsquo;t know if they&amp;rsquo;re dealing with a Ruby, Python or Perl application!&lt;/p&gt;

&lt;p&gt;The other type of information leak we need to prevent is indicating logical vulnerabilities by responding differently to similar requests. For example, by responding to login attempts with incorrect usernames with the error message &amp;ldquo;incorrect username&amp;rdquo;, attackers can brute-force attack the username until they receive the message &amp;ldquo;incorrect password&amp;rdquo;, at which point they know they have guessed a correct username.&lt;/p&gt;

&lt;p&gt;In SecApp, we want to respond with a generic message every time the login attempt fails, and not indicate which field was incorrect. The login function is implemented in our &lt;a href=&#34;https://github.com/dnmfarrell/SecApp_login/blob/master/lib/SecApp/Controller/Root.pm#L42&#34;&gt;Root.pm&lt;/a&gt; controller - we&amp;rsquo;ll look at the code later, but for now you can see that there is only one error message returned.&lt;/p&gt;

&lt;h3 id=&#34;2-handle-credentials-secretively:ba4c9275de3995b673588b08da4e28c2&#34;&gt;2. Handle credentials secretively&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;http://www.amazon.com/gp/product/1118026470/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=1118026470&amp;amp;linkCode=as2&amp;amp;tag=perltrickscom-20&#34;&gt;The Web Application Hacker&amp;rsquo;s Handbook&lt;/a&gt; summarizes this as:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;All credentials should be created, stored, and transmitted in a manner that does not lead to unauthorized disclosure.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In SecApp &lt;a href=&#34;https://github.com/dnmfarrell/SecApp_login/blob/master/lib/SecApp/Controller/Root.pm#L11&#34;&gt;Root.pm&lt;/a&gt;, we use Catalyst&amp;rsquo;s auto Controller function to check that every request is over SSL:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# this method will be called everytime
sub auto :Private {
    my ($self, $c) = @_;

    # 404 unless https/testing &amp;amp; request method is GET/HEAD/POST
    unless( ( $c-&amp;gt;req-&amp;gt;secure or $c-&amp;gt;config-&amp;gt;{testing} == 1 )
            &amp;amp;&amp;amp; grep /^(?:GET|HEAD|POST)$/, $c-&amp;gt;req-&amp;gt;method )
        {
            $c-&amp;gt;detach(&#39;default&#39;);
        }
    ...
    return 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method &amp;ldquo;$c-&amp;gt;req-&amp;gt;secure&amp;rdquo; will return true if the connection is via SSL. If it isn&amp;rsquo;t we detach the request to the &amp;ldquo;default&amp;rdquo; method, which returns a 404 request error. The clause &amp;ldquo;or $c-&amp;gt;config-&amp;gt;{testing} == 1&amp;rdquo; is so that when testing the application we can try out the functions without needing SSL, as Catalyst&amp;rsquo;s test server does not support it.&lt;/p&gt;

&lt;p&gt;Now it could be irritating for users who try to load the login page and get a 404 error. So using Catalyst&amp;rsquo;s end method, we also set the Strict-Transport-Security HTTP header which instructs browsers to load all pages via https. This is the code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub end : ActionClass(&#39;RenderView&#39;) {
  my ($self, $c) = @_;

  # don&#39;t require TLS for testing
  unless ($c-&amp;gt;config-&amp;gt;{testing} == 1) {
    $c-&amp;gt;response-&amp;gt;header(&#39;Strict-Transport-Security&#39; =&amp;gt; &#39;max-age=3600&#39;);
  }
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SecApp sets several other security headers in the &lt;a href=&#34;https://github.com/dnmfarrell/SecApp_login/blob/master/lib/SecApp/Controller/Root.pm#L90&#34;&gt;end method&lt;/a&gt;, you can read about what they do &lt;a href=&#34;http://perltricks.com/article/81/2014/3/31/Perl-web-application-security-HTTP-headers&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;SecApp only authenticates login requests received via POST. We achieve this by using Catalyst&amp;rsquo;s chained dispatching and HTTP method matching:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub login :Chained(&#39;/&#39;) PathPart(&#39;login&#39;) CaptureArgs(0) {}

sub login_auth :Chained(&#39;login&#39;) PathPart(&#39;&#39;) Args(0) POST {
    # authentication code
    ...

    # authentication failed, load the login form
    $c-&amp;gt;forward(&#39;login_form&#39;);
}

sub login_form :Chained(&#39;login&#39;) PathPart(&#39;&#39;) Args(0) GET {
    my ($self, $c) = @_;

    # load the login template
    $c-&amp;gt;stash(template =&amp;gt; &#39;login.tt&#39;);
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/dnmfarrell/SecApp_login/blob/master/lib/SecApp/Controller/Root.pm#L42&#34;&gt;code&lt;/a&gt; has been abbreviated here for clarity. But effectively the &amp;ldquo;login_auth&amp;rdquo; subroutine will only fire if the request to &amp;ldquo;/login&amp;rdquo; was made via POST, else just load the login page with the &amp;ldquo;login_form&amp;rdquo; sub. Cool right? Catalyst project manager John Napiorkowski mused on these features in an illustrative &lt;a href=&#34;http://jjnapiorkowski.typepad.com/modern-perl/2013/08/thoughts-on-catalyst-soa-and-web-services.html#.U11rEjnXvqg&#34;&gt;blog post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Finally, SecApp stores the passwords in an hashed format, using a relatively strong algorithm (bcrypt). The following code in &lt;a href=&#34;https://github.com/dnmfarrell/SecApp_login/blob/master/lib/SecApp/Schema/Result/User.pm#L130&#34;&gt;User.pm&lt;/a&gt; adds the functionality:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;__PACKAGE__-&amp;gt;add_columns(
            &#39;password&#39; =&amp;gt; {
                passphrase =&amp;gt; &#39;rfc2307&#39;,
                passphrase_class =&amp;gt; &#39;BlowfishCrypt&#39;,
                passphrase_args =&amp;gt; {
                    cost =&amp;gt; 14,
                    salt_random =&amp;gt; 20,
                },
                passphrase_check_method =&amp;gt; &#39;check_password&#39;,
            });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So even if attackers obtained the application password file, the passwords are salted and hashed and not easily broken. SecApp comes with a sample SQLite3 test database with one test user account already created.&lt;/p&gt;

&lt;h3 id=&#34;3-validate-credentials-properly:ba4c9275de3995b673588b08da4e28c2&#34;&gt;3. Validate credentials properly&lt;/h3&gt;

&lt;p&gt;The code that validates credentials can also contain weaknesses. Passwords should be validated in full, without modification or truncation and in a case-sensitive comparison. Multi-stage login processes are particularly susceptible to attacks. The login code should be peer-reviewed and substantially tested for errors.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://metacpan.org/pod/Catalyst::Plugin::Authentication&#34;&gt;Catalyst::Plugin::Authentication&lt;/a&gt; module makes authentication easy. SecApp keeps the login process simple: just a username and password form, with an optional CAPTCHA. Here is the full login code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub login_auth :Chained(&#39;login&#39;) PathPart(&#39;&#39;) Args(0) POST {
  my ($self, $c) = @_;
  my $captcha_response 
    = $c-&amp;gt;request-&amp;gt;params-&amp;gt;{recaptcha_response_field};
  my $captcha_challenge 
    = $c-&amp;gt;request-&amp;gt;params-&amp;gt;{recaptcha_challenge_field};

  # proceed if config has switched off CAPTCHA, or if the submission is valid, proceed
  if ($c-&amp;gt;config-&amp;gt;{Captcha}-&amp;gt;{enabled} == 0
      || Captcha::reCAPTCHA-&amp;gt;new-&amp;gt;check_answer(
                   $c-&amp;gt;config-&amp;gt;{Captcha}-&amp;gt;{private_key},
                   $c-&amp;gt;request-&amp;gt;address,
                   $captcha_challenge,
                   $captcha_response)-&amp;gt;{is_valid})
  {
    $username = $c-&amp;gt;req-&amp;gt;params-&amp;gt;{username};
    my $password = $c-&amp;gt;req-&amp;gt;params-&amp;gt;{password};

    # if username and passwords were supplied, authenticate
    if ($username &amp;amp;&amp;amp; $password) {
      if ($c-&amp;gt;authenticate({ username =&amp;gt; $username,
                             password =&amp;gt; $password } ))
      {
      # authentication success, check user active and redirect to the secure landing page
        if ($c-&amp;gt;user-&amp;gt;get_object-&amp;gt;active) {
          $c-&amp;gt;response-&amp;gt;redirect($c-&amp;gt;uri_for($c-&amp;gt;controller(&#39;Admin&#39;)-&amp;gt;action_for(&#39;landing&#39;)));
          return;
        }
      }
      else {
        $c-&amp;gt;stash(error_msg =&amp;gt; &amp;quot;Bad username or password.&amp;quot;);
      }
    }
  }
  $c-&amp;gt;forward(&#39;login_form&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s walk through the code. If the CAPTCHA functionality is enabled, the login function will attempt to validate the CAPTCHA. If successful, the code then retrieves the username and password, and if they exist, attempts to validate them using the authenticate method. The authenticate method checks both username and password in full against the database. If the username and password are validated, then the user will be re-directed to the landing page which is in the secure Admin.pm controller. Else an error message will set indicating a bad username or password. In all failing cases, the login form will be reloaded and displayed.&lt;/p&gt;

&lt;p&gt;So the code looks good, but how do we know if it will do the right thing in all cases? Fortunately &lt;a href=&#34;https://metacpan.org/pod/Catalyst::Test&#34;&gt;Catalyst::Test&lt;/a&gt; can make unit testing an application&amp;rsquo;s methods easy. SecApp has the test file &lt;a href=&#34;https://github.com/dnmfarrell/SecApp_login/blob/master/t/Root.t&#34;&gt;Root.t&lt;/a&gt; which tests the login function with many different combinations of credentials, such as null, zero-length string, correct username incorrect password etc. Running these tests makes it easy to confirm that the login function does the right thing. Want to check for yourself? At the command line run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ TESTING=1 perl -Ilib t/Root.t
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-prevent-brute-force-attacks:ba4c9275de3995b673588b08da4e28c2&#34;&gt;4. Prevent brute-force attacks&lt;/h3&gt;

&lt;p&gt;Brute force attacks are attempts to crack the username and password of an account by repeatedly trying different combinations until one succeeds. SecApp uses &lt;a href=&#34;https://metacpan.org/pod/Captcha::reCAPTCHA&#34;&gt;Captcha::reCAPTCHA&lt;/a&gt; to prevent automated brute force attacks. You&amp;rsquo;ll need a Google account and web domain to sign up for it (it&amp;rsquo;s free). The difficulty of the captcha puzzles presented are very difficult to reliably pass with automation. If you do have a Google &lt;a href=&#34;https://www.google.com/recaptcha/intro/index.html&#34;&gt;reCAPtCHA account&lt;/a&gt;, you can try it out with SecApp by updating &lt;a href=&#34;https://github.com/dnmfarrell/SecApp_login/blob/master/lib/SecApp.pm#L54&#34;&gt;SecApp.pm&lt;/a&gt; with your account credentials.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/84/secapp_login_catpcha.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Seeing as brute-force attacks can only succeed if they can try millions of attempts, why not just add a time-delay like &amp;ldquo;sleep(2)&amp;rdquo; to the login function? The problem with that defence is that it opens the web application up to another attack-vector: denial of service. If an attacker can issue several requests every 2 seconds to the login function, it may tie up all of the application&amp;rsquo;s processes and stop it from responding to regular web requests. Not good!&lt;/p&gt;

&lt;p&gt;Using CAPTCHA combined with front-end proxy web server request and connection limiting methods that can largely eliminate the brute-force risk.&lt;/p&gt;

&lt;h3 id=&#34;5-log-monitor-and-notify:ba4c9275de3995b673588b08da4e28c2&#34;&gt;5. Log, monitor and notify&lt;/h3&gt;

&lt;p&gt;Catalyst comes with built-in logging capabilities. If you&amp;rsquo;re using Catalyst::Plugin::Authentication, any failed login attempt automatically logs a critical error. So the good news is if you&amp;rsquo;re using a web server like nginx, Catalyst will write the critical error to the server error log (this is a simplification). SecApp does not implement any monitoring or notification services, but I think this is more the domain of the server and not the web application. It&amp;rsquo;s trivial to configure &lt;a href=&#34;http://www.fail2ban.org/wiki/index.php/Main_Page&#34;&gt;fail2ban&lt;/a&gt; to monitor the error.log and jail any suspicious repeat login attempts.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:ba4c9275de3995b673588b08da4e28c2&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Is the SecApp login function secure? One thing to consider is that although it utilizes many good practices, user registration and password reset is not implemented. These features must be secure too, else they can undermine the login security altogether, for example by allowing weak passwords to be set. We&amp;rsquo;ll consider these areas of authentication in a future article. In the meantime, SecApp is released under the Artistic 2.0 license, feel free to use it.&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F84%2F2014%2F4%2F28%2FIs-your-login-page-secure-&amp;amp;text=Is+your+login+page+secure%3F&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F84%2F2014%2F4%2F28%2FIs-your-login-page-secure-&amp;amp;via=perltricks&#34;&gt;tweet&lt;/a&gt; about it!&lt;/p&gt;

&lt;p&gt;*&lt;strong&gt;Updated:&lt;/strong&gt; corrected hashing algorithm name and description 04/28/2014*&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Cover image &lt;a href=&#34;https://creativecommons.org/licenses/by/2.0/&#34;&gt;&lt;/a&gt; &lt;a href=&#34;https://www.flickr.com/photos/motograf/1269439152/in/photolist-2Wbd2W-9VxeqP-8v6WhC-8v3ToK-8v6W4h-fcDhWQ-6boP72-LNv8s-4pkUnM-aj6wD3-4rL1UA-9Ziy7V-jP5Sc-51f4ck-4ppX9S-dWGQed-dWGuMs-dQRyD-b9SUT-9cBRYL-5UB8BE-8BFgnW-6boNpR-6bsWUQ-6bsX9C-FXJTL-8AuQei-8AuRVc-8AuSzH-6gA6Lx-8v5M9x-91rH7R-dWsFmy-ZQRR-jP6a9-4HKkvg-4HPzk1-5eWG8T-8v8Q6d-8v8Q7N-4HKmZ6-kJrvqx-fcp9cZ-4rsdJ3-aFebHa-4HPALy-7HrEuY-6Pk9RC-hX3MVF-7xoEF6&#34;&gt;motograf&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl web application security - HTTP headers</title>
      <link>http://perltricks.com/article/81/2014/3/31/Perl-web-application-security---HTTP-headers/</link>
      <pubDate>Mon, 31 Mar 2014 12:27:39 +0000</pubDate>
      
      <guid>http://perltricks.com/article/81/2014/3/31/Perl-web-application-security---HTTP-headers/</guid>
      <description>

&lt;p&gt;&lt;em&gt;HTTP headers are included in every HTTP response from a web server. Setting the appropriate HTTP headers can reduce the risk of man-in-the-middle and cross-site-scripting attacks on a web application. You can also reduce information leaks about the web application configuration - vital data that gives a would-be attacker clues about potential vulnerabilities. Read on to find out how to set the appropriate headers in your Perl web application.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;application:87bd3c5b42cb426b55681d8c1ff3ca2c&#34;&gt;Application&lt;/h3&gt;

&lt;p&gt;All three of major Perl web frameworks provide some kind of identifying header. Dancer and Mojolicious use &amp;ldquo;X-Powered-By&amp;rdquo; and Catalyst uses &amp;ldquo;X-Catalyst&amp;rdquo;. The problem with this header is it informs the requester the language of the application (Perl) and the web framework being used. In some cases it also reveals the version number. With this information a would-be attacker can focus on exploits that are specific to Perl or the web framework. Here&amp;rsquo;s how you can disable it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;By default Catalyst does not turn on its application header. The header is controlled by the &amp;ldquo;enable_catalyst_header&amp;rdquo; config option, normally located in the root application class (e.g. lib/MyApp.pm) or the application config file.&lt;/li&gt;
&lt;li&gt;Mojolicious does not set this header since &lt;a href=&#34;https://github.com/kraih/mojo/blob/b5da0c7afcdd793c85e8e2a67eb29f7f36bdb601/Changes#L538&#34;&gt;version 4.00&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Dancer (and Dancer2) use the &lt;a href=&#34;http://search.cpan.org/~xsawyerx/Dancer2-0.11/lib/Dancer2/Config.pod#server_tokens_%28boolean%29&#34;&gt;server tokens&lt;/a&gt; directive.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;server:87bd3c5b42cb426b55681d8c1ff3ca2c&#34;&gt;Server&lt;/h3&gt;

&lt;p&gt;Web servers often broadcast information about themselves by default. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;Server: nginx/1.4.6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is risky for the same reason that revealing information about the underlying Perl web application is. To disable the server header in nginx, just add this line to your nginx.conf or virtual host file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;server_tokens off;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For Apache 1.3x add these lines to your virtual host file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;ServerTokens Prod
ServerSignature Off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For Apache 2.x, these lines will load the mod_headers module, and remove the server header:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;LoadModule headers_module /usr/lib/apache/modules/mod_headers.so
Header unset Server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of the major Perl web frameworks ship with web servers that set the server header:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# Catalyst
Server: HTTP::Server::PSGI

# mojolicious
Server: Mojolicious (Perl)

# Dancer
Server: Perl Dancer 1.3121
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These headers can be overwritten within the application code. For instance, if we wanted to change the server to appear to be nginx:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# Catalyst
$c-&amp;gt;response-&amp;gt;header(&#39;Server&#39; =&amp;gt; &#39;nginx&#39;);

# Mojolicious
$self-&amp;gt;res-&amp;gt;headers-&amp;gt;header(&#39;Server&#39; =&amp;gt; &#39;nginx&#39;);

# Dancer / Dancer2
header &#39;Server&#39; =&amp;gt; &#39;nginx&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;x-frame-options:87bd3c5b42cb426b55681d8c1ff3ca2c&#34;&gt;X-Frame-Options&lt;/h3&gt;

&lt;p&gt;This header can prevent your application responses from being loaded within frame or iframe HTML elements (see the &lt;a href=&#34;http://tools.ietf.org/html/rfc7034&#34;&gt;spec&lt;/a&gt;). This is to prevent clickjacking requests where your application response is displayed on another website, within an invisible iframe, which then hijacks the user&amp;rsquo;s request when they click a link on your website. Here&amp;rsquo;s how to disable it in the respective web frameworks:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# Catalyst
$c-&amp;gt;response-&amp;gt;header(&#39;X-Frame-Options&#39; =&amp;gt; &#39;DENY&#39;);

# Mojolicious
$self-&amp;gt;res-&amp;gt;headers-&amp;gt;header(&#39;X-Frame-Options&#39; =&amp;gt; &#39;DENY&#39;);

# Dancer / Dancer2
header &#39;X-Frame-Options&#39; =&amp;gt; &#39;DENY&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;strict-transport-security:87bd3c5b42cb426b55681d8c1ff3ca2c&#34;&gt;Strict-Transport-Security&lt;/h3&gt;

&lt;p&gt;This header instructs the requester to load all content from the domain via HTTPS and not load any content unless there is a valid ssl certificate. This header can help prevent man-in-middle attacks as it ensures that all HTTP requests and responses are encrypted. The Strict-Transport-Security header has a max-age parameter that defines how long in seconds to enforce the policy for. Here&amp;rsquo;s how to add it to your Perl web application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# Catalyst
$c-&amp;gt;response-&amp;gt;header(&#39;Strict-Transport-Security&#39; =&amp;gt; &#39;max-age=3600&#39;);

# Mojolicious
$self-&amp;gt;res-&amp;gt;headers-&amp;gt;header(&#39;Strict-Transport-Security&#39; =&amp;gt; &#39;max-age=3600&#39;);

# Dancer / Dancer2
header &#39;Strict-Transport-Security&#39; =&amp;gt; &#39;max-age=3600&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;content-security-policy:87bd3c5b42cb426b55681d8c1ff3ca2c&#34;&gt;Content-Security-Policy&lt;/h3&gt;

&lt;p&gt;The CSP header sets a whitelist of domains from which content can be safely loaded. This prevents most types of XSS attack, assuming the malicious content is not hosted by a whitelisted domain. For example this line specifies that all content should only be loaded from the responding domain:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;X-Content-Security-Policy: default-src &#39;self&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is &lt;a href=&#34;http://www.html5rocks.com/en/tutorials/security/content-security-policy%0A&#34;&gt;a lot to CSP&lt;/a&gt; (&lt;a href=&#34;http://www.w3.org/TR/CSP/&#34;&gt;spec&lt;/a&gt;) and browser support is &lt;a href=&#34;http://caniuse.com/#feat=contentsecuritypolicy&#34;&gt;fairly good&lt;/a&gt;. One downside to the whitelist approach is it&amp;rsquo;s not compatible with ad services like Google&amp;rsquo;s adsense as you won&amp;rsquo;t know the domains in advance in order to whitelist them. To set the header in your facourite Perl web application, use on of these lines:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# Catalyst
$c-&amp;gt;response-&amp;gt;header(&#39;X-Content-Security-Policy&#39; =&amp;gt; &amp;quot;default-src &#39;self&#39;&amp;quot;);

# Mojolicious
$self-&amp;gt;res-&amp;gt;headers-&amp;gt;header(&#39;X-Content-Security-Policy&#39; =&amp;gt; &amp;quot;default-src &#39;self&#39;&amp;quot;);

# Dancer / Dancer2
header &#39;X-Content-Security-Policy&#39; =&amp;gt; &amp;quot;default-src &#39;self&#39;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;x-content-type-options:87bd3c5b42cb426b55681d8c1ff3ca2c&#34;&gt;X-Content-Type-Options&lt;/h3&gt;

&lt;p&gt;This is an IE only header that is used to disable mime sniffing. The vulnerability is that IE will auto-execute any script code contained in a file when IE attempts to detect the file type. This is disabled by default in IE anyway, but to enforce it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# Catalyst
$c-&amp;gt;response-&amp;gt;header(&#39;X-Content-Type-Options&#39; =&amp;gt; &#39;nosniff&#39;);

# Mojolicious
$self-&amp;gt;res-&amp;gt;headers-&amp;gt;header(&#39;X-Content-Type-Options&#39; =&amp;gt; &#39;nosniff&#39;);

# Dancer / Dancer2
header &#39;X-Content-Type-Options&#39; =&amp;gt; &#39;nosniff&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;x-download-options:87bd3c5b42cb426b55681d8c1ff3ca2c&#34;&gt;X-Download-Options&lt;/h3&gt;

&lt;p&gt;This is another IE-only header that prevents IE from opening an HTML file directly on download from a website. The security issue here is, if a browser opens the file directly, it can run as if it were part of the site. To add this header, use one of these lines:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# Catalyst
$c-&amp;gt;response-&amp;gt;header(&#39;X-Download-Options&#39; =&amp;gt; &#39;noopen&#39;);

# Mojolicious
$self-&amp;gt;res-&amp;gt;headers-&amp;gt;header(&#39;X-Download-Options&#39; =&amp;gt; &#39;noopen&#39;);

# Dancer / Dancer2
header &#39;X-Download-Options&#39; =&amp;gt; &#39;noopen&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;x-xss-protection:87bd3c5b42cb426b55681d8c1ff3ca2c&#34;&gt;X-XSS-Protection&lt;/h3&gt;

&lt;p&gt;This is the final IE-only header. It was introduced in IE8 as part of the cross-site-scripting (XSS) filter functionality (more &lt;a href=&#34;http://blogs.msdn.com/b/ieinternals/archive/2011/01/31/controlling-the-internet-explorer-xss-filter-with-the-x-xss-protection-http-header.aspx&#34;&gt;here&lt;/a&gt;). The header can force IE to turn on its XSS filter. Additionally it has an optional setting called &amp;ldquo;mode&amp;rdquo; that can force IE to block the entire page if an XSS attempt is detected. Here&amp;rsquo;s how to add it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# Catalyst
$c-&amp;gt;response-&amp;gt;header(&#39;X-XSS-Protection&#39; =&amp;gt; &amp;quot;1; &#39;mode=block&#39;&amp;quot;);

# Mojolicious
$self-&amp;gt;res-&amp;gt;headers-&amp;gt;header(&#39;X-XSS-Protection&#39; =&amp;gt; &amp;quot;1; &#39;mode=block&#39;&amp;quot;);

# Dancer / Dancer2
header &#39;X-XSS-Protection&#39; =&amp;gt; &amp;quot;1; &#39;mode=block&#39;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adding-headers-in-the-web-server:87bd3c5b42cb426b55681d8c1ff3ca2c&#34;&gt;Adding headers in the web server&lt;/h3&gt;

&lt;p&gt;You may prefer to add these headers in the web server configuration, rather than at the application level. For nginx, use the &amp;ldquo;add_header&amp;rdquo; directive - see &lt;a href=&#34;https://gist.github.com/plentz/6737338&#34;&gt;here&lt;/a&gt; for a good example. For Apache use the &amp;ldquo;Header set&amp;rdquo; directive in mod_headers (&lt;a href=&#34;http://moko.ru/doc/apache/mod/mod_headers.html&#34;&gt;1.3&lt;/a&gt;, &lt;a href=&#34;http://httpd.apache.org/docs/2.0/de/mod/mod_headers.html&#34;&gt;2.x&lt;/a&gt;).&lt;/p&gt;

&lt;h3 id=&#34;testing-the-headers:87bd3c5b42cb426b55681d8c1ff3ca2c&#34;&gt;Testing the headers&lt;/h3&gt;

&lt;p&gt;tThere are a number of ways to check which headers your application is returning. Firstly you can use curl (replace perltricks.com with the URL to check):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;curl -I perltricks.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will return the HTTP headers only:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;HTTP/1.1 200 OK
Server: nginx
Date: Mon, 31 Mar 2014 01:54:59 GMT
Content-Type: text/html; charset=utf-8
Connection: keep-alive
Cache-Control: max-age=3600
X-Frame-Options: DENY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use &lt;a href=&#34;https://securityheaders.com/&#34;&gt;SecurityHeaders.com&amp;rsquo;s&lt;/a&gt; excellent checking tool. Or you can inspect the headers yourself by using your browser&amp;rsquo;s developer mode.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:87bd3c5b42cb426b55681d8c1ff3ca2c&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;These HTTP headers are easy to add and can make a reduce your application&amp;rsquo;s vulnerability to XSS and man-in-the-middle attacks, particularly for applications that allow users to upload content.&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F81%2F2014%2F3%2F31%2FPerl-web-application-security-HTTP-headers&amp;amp;text=Perl+web+application+security+-+HTTP+headers&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F81%2F2014%2F3%2F31%2FPerl-web-application-security-HTTP-headers&amp;amp;via=perltricks&#34;&gt;retweet&lt;/a&gt; it!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Cover photo  &lt;a href=&#34;http://www.flickr.com/photos/rightee/259084010/in/photostream/&#34;&gt;Andy Wright&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Updates: Mojolicious application header corrected. Web frameworks server header added. (31/3/2014)&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wear the cloak of invisibility with OpenVPN and Perl</title>
      <link>http://perltricks.com/article/50/2013/12/2/Wear-the-cloak-of-invisibility-with-OpenVPN-and-Perl/</link>
      <pubDate>Mon, 02 Dec 2013 04:38:11 +0000</pubDate>
      
      <guid>http://perltricks.com/article/50/2013/12/2/Wear-the-cloak-of-invisibility-with-OpenVPN-and-Perl/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Screen-scraping useragents can be identified by several characteristics including their IP address and useragent string. This article shows how with the VPN service of &lt;a href=&#34;http://hidemyass.com/vpn/r14824/&#34;&gt;HideMyAss.com&lt;/a&gt; and the Perl module &lt;a href=&#34;https://metacpan.org/pod/Net::OpenVPN::Agent&#34;&gt;Net::OpenVPN::Agent&lt;/a&gt; you can obfuscate these data points and make your useragent harder to detect and monitor.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;pre-requisites:a4365f9dfaa93e2157234fd965542a9e&#34;&gt;Pre-requisites&lt;/h3&gt;

&lt;p&gt;The following solution has been tested on Linux and may work on other UNIX-based platforms but is unlikely to work on Windows. Before getting started you&amp;rsquo;ll need to install &lt;a href=&#34;http://openvpn.net/index.php/open-source.html&#34;&gt;OpenVPN&lt;/a&gt; (open source networking software) - this is used to connect to the VPN networks of &lt;a href=&#34;http://hidemyass.com/vpn/r14824/&#34;&gt;HideMyAss.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You will also need to install Net::OpenVPN::Agent via CPAN:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cpan Net::OpenVPN::Agent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally you will need a &amp;ldquo;VPN Pro&amp;rdquo; account with &lt;a href=&#34;http://hidemyass.com/vpn/r14824/&#34;&gt;HideMyAss.com&lt;/a&gt;. They provide 49,000 IP addresses Worldwide. I can recommend their service and have been using them successfully for months. If you have an account with a different VPN provider that uses OpenVPN, you should be able to hack Net::OpenVPN::Agent to use that service instead (contact me if you&amp;rsquo;d like help with this - I&amp;rsquo;m the module author).&lt;/p&gt;

&lt;h3 id=&#34;overview:a4365f9dfaa93e2157234fd965542a9e&#34;&gt;Overview&lt;/h3&gt;

&lt;p&gt;The Net::OpenVPN::Agent provides a configurable useragent that will automatically connect to a random &lt;a href=&#34;http://hidemyass.com/vpn/r14824/&#34;&gt;HideMyAss.com&lt;/a&gt; server before fetching the target URL. After a configurable number of requests, the useragent will automatically disconnect and re-connect to another random server. When connecting to a new server, the useragent will also select a new useragent string from a configurable list of useragent strings. This way both the IP address and the useragent string will change at the same time to adopt a new identity. The useragent is designed to be resilient: server connections and failed page requests will be attempted multiple times (configurable), new IP addresses are confirmed using a remote service and full logging capability is provided via &lt;a href=&#34;https://metacpan.org/pod/Log::Log4perl&#34;&gt;Log::log4perl&lt;/a&gt; (also configurable).&lt;/p&gt;

&lt;h3 id=&#34;configuration:a4365f9dfaa93e2157234fd965542a9e&#34;&gt;Configuration&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/Net::OpenVPN::Agent&#34;&gt;Net::OpenVPN::Agent&lt;/a&gt; requires a YAML file called agent.conf to be present in the root application directory. This is explained in the &lt;a href=&#34;https://metacpan.org/pod/Net::OpenVPN::Agent#new&#34;&gt;module documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;writing-a-covert-scraper:a4365f9dfaa93e2157234fd965542a9e&#34;&gt;Writing a covert scraper&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s pull together a simple scraper to demonstrate the concept. The code below initializes uses &lt;a href=&#34;https://metacpan.org/pod/Net::OpenVPN::Agent&#34;&gt;Net::OpenVPN::Agent&lt;/a&gt; to get the main page of the New York times website. It then extracts and requests every URL it finds, with the aim of doing something with that content.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Net::OpenVPN::Agent;
use strict;
use warnings;
use 5.10.3;
use utf8;

my $ua = Net::OpenVPN::Agent-&amp;gt;new;
my $base_url = &#39;http://www.nytimes.com&#39;;
my $html = $ua-&amp;gt;get_page($base_url) =~ s/\n//gr;
foreach ($html =~ /href=&amp;quot;($base_url.*?)&amp;quot;/g) {
    my $story = $ua-&amp;gt;get_page($_)
    # do something
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this code at the terminal with full logging gives the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sudo $(which perl) times.pl
DEBUG - setting ip address
DEBUG - GET: http://geoip.hidemyass.com/ip/
DEBUG - Request successful
DEBUG - Request limit is zero, resetting the request limit.
DEBUG - GET: http://securenetconnection.com/vpnconfig/servers-cli.php
DEBUG - Request successful
DEBUG - GET: http://securenetconnection.com/vpnconfig/openvpn-template.ovpn
DEBUG - Request successful
DEBUG - Connecting to 72.11.140.130, USA, California, Los Angeles (LOC1 S4), us
WARN - Ip address not changed, re-requesting ip
DEBUG - GET: http://geoip.hidemyass.com/ip/
DEBUG - Request successful
DEBUG - Ip address changed to 72.11.140.138 from 172.254.124.113
DEBUG - GET: http://www.nytimes.com
DEBUG - Request successful
DEBUG - GET: http://www.nytimes.com/weather
DEBUG - Request successful
DEBUG - GET: http://www.nytimes.com/pages/sports/index.html
DEBUG - Request successful
DEBUG - GET: http://www.nytimes.com/pages/science/index.html
DEBUG - Request successful
DEBUG - GET: http://www.nytimes.com/pages/health/index.html
DEBUG - Request successful
DEBUG - GET: http://www.nytimes.com/pages/arts/index.html
DEBUG - Request successful
DEBUG - Request limit is zero, resetting the request limit.
DEBUG - Disconnecting from server.
DEBUG - Connecting to 173.234.233.226, USA, New York, Manhattan (LOC1 S3), us
WARN - Ip address not changed, re-requesting ip
DEBUG - GET: http://geoip.hidemyass.com/ip/
DEBUG - Request successful
DEBUG - Ip address changed to 108.62.48.75 from 72.11.140.138
DEBUG - GET: http://www.nytimes.com/pages/style/index.html
DEBUG - Request successful
DEBUG - GET: http://www.nytimes.com/pages/opinion/index.html
DEBUG - Request successful
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output demonstrates how the useragent first establishes a secure, encrypted connection to a Los Angeles-based VPN before proceeding to request pages from the New York Times website. Once the configured page request limit is reached the useragent automatically disconnects and connects to a new VPN in New York, establishing a new IP and adopting a new useragent string. From the New York Times web server perspective, it received a series of requests from two different users with different IP addresses, one in Los Angeles and the other in New York. And neither of these is the user&amp;rsquo;s actual IP address.&lt;/p&gt;

&lt;h3 id=&#34;warning:a4365f9dfaa93e2157234fd965542a9e&#34;&gt;Warning&lt;/h3&gt;

&lt;p&gt;The ability to anonymously scrape websites is a powerful but potentially harmful activity - you should never screen-scrape for unethical or illegal purposes. Adhere to robots.txt. This approach does not guarantee anonymity: the VPN provider may disclose all connections logs if required to by a law enforcement agency.&lt;/p&gt;

&lt;h3 id=&#34;disclosure:a4365f9dfaa93e2157234fd965542a9e&#34;&gt;Disclosure&lt;/h3&gt;

&lt;p&gt;As a customer of &lt;a href=&#34;http://hidemyass.com/vpn/r14824/&#34;&gt;HideMyAss.com&lt;/a&gt; I receive an affiliate payment for the successful referrals from the links on this page.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

