<!DOCTYPE html>
<html>
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>How to Split Quoted Strings in Bash</title>
  <meta name="description" content="Sometimes you really just have to code it" />
  <link rel="stylesheet" href="/assets/css/style.css" type="text/css">
  <meta property="twitter:card" content="summary">
  <meta property="twitter:site" content="@perltricks">
  <meta property="og:url" content="https://blog.dnmfarrell.com/post/how-to-split-strings-in-bash/" />
  <meta property="og:title" content="How to Split Quoted Strings in Bash" />
  <meta property="og:description" content="Sometimes you really just have to code it">
  <meta property="og:site_name" content="blog.dnmfarrell.com" />
  <meta property="og:type" content="article" />
  <meta property="og:article:published_time" content="2021-12-28T44:47:21Z" />
  <meta property="og:article:tag" content="bash" />
  <meta property="og:article:tag" content="wordsplit" />
</head>

  <body>
    <a href="/">
  <h1>Code</h1>
</a>

    <main>
      

<h2>How to Split Quoted Strings in Bash</h2>

<em class="date">December 28, 2021</em>

<p>A few weeks ago I was writing a macro loader for my <a href="https://github.com/dnmfarrell/jp">JSON Processor</a>, and I ran into an odd case where code I entered in the terminal was splitting differently to code I loaded from a file. It turns out that Bash&rsquo;s word splitting behaves differently for arguments than it does for variables.</p>
<p>When processing args, Bash will not split quoted words that contain a delimiter:</p>
<pre><code>printf &quot;%s\n&quot; foo 'bar baz'
foo
bar baz
</code></pre>
<p>But if those args are in a string:</p>
<pre><code>input='foo &quot;bar baz&quot;'
printf &quot;%s\n&quot; &quot;$input&quot;
foo &quot;bar baz&quot;
</code></pre>
<p>Or unquoted:</p>
<pre><code>printf &quot;%s\n&quot; $input
foo
&quot;bar
baz&quot;
</code></pre>
<p>What I really want is to split the variable into an array of words. Then printf works as I want it to:</p>
<pre><code>input=(foo &quot;bar baz&quot;)
printf &quot;%s\n&quot; &quot;${input[@]}&quot;
foo
bar baz
</code></pre>
<p>I can&rsquo;t use <code>read -a</code> because that will split input ignoring quotes. In fact, the only built in way to accomplish this is via eval:</p>
<pre><code>input='foo &quot;bar baz&quot;'
eval &quot;printf \&quot;%s\n\&quot; $input&quot;
foo
bar baz
</code></pre>
<p>But using eval invites a whole set of complications I&rsquo;d rather avoid. And launching a subshell to another program (awk, xargs) is too slow for my use case. What to do?</p>
<p>After much Googling, I decided to <a href="https://github.com/dnmfarrell/bash-wordsplit">roll my own</a>. It respects unquoted, single or double-quoted string escapes (but not ANSI-C escape sequences).</p>
<pre><code>wordsplit 'foo &quot;bar baz&quot;';printf &quot;%s\n&quot; &quot;${WORDS[@]}&quot;
foo
bar baz
</code></pre>
<p>Shell quoting is a treacherous business. If you find any bugs, please let me know!</p>


<p>


<em>Tags: 



  
  
  

  <a href=https://blog.dnmfarrell.com/tags/bash/>bash</a>



  
  
  

  <a href=https://blog.dnmfarrell.com/tags/wordsplit/>wordsplit</a>



</em>



</p>


    </main>
    <footer>
    <p>Follow me on Twitter <a href="https://twitter.com/PerlTricks">@perltricks</a></p>
 </footer>

  </body>
</html>
