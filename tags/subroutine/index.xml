<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Subroutine on Perl programming news, code and culture</title>
    <link>https://dnmfarrell.github.io/tags/subroutine/</link>
    <description>Recent content in Subroutine on Perl programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 12 May 2014 13:19:16 +0000</lastBuildDate>
    <atom:link href="https://dnmfarrell.github.io/tags/subroutine/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Benchmarking subroutine signatures</title>
      <link>https://dnmfarrell.github.io/article/88/2014/5/12/Benchmarking-subroutine-signatures/</link>
      <pubDate>Mon, 12 May 2014 13:19:16 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/88/2014/5/12/Benchmarking-subroutine-signatures/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Subroutine signatures will be released to the Perl core in just a few days. But how do they performance compared with traditional methods like direct variable assignment and the &lt;a href=&#34;https://metacpan.org/pod/Method::Signatures&#34;&gt;Method::Signatures&lt;/a&gt; module? I benchmarked all three with interesting results.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;background:93413df609358a1a5a975a341330277a&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;I &lt;a href=&#34;http://perltricks.com/article/72/2014/2/24/Perl-levels-up-with-native-subroutine-signatures&#34;&gt;covered&lt;/a&gt; the new subroutine signatures features when they first appeared in the Perl development release 5.19.9. For these benchmarks I used the latest Perl development release (5.19.11).&lt;/p&gt;

&lt;h3 id=&#34;method:93413df609358a1a5a975a341330277a&#34;&gt;Method&lt;/h3&gt;

&lt;p&gt;All of the benchmarks came from variations of this code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use Benchmark::Forking &#39;cmpthese&#39;;
use feature &#39;signatures&#39;;
no warnings &#39;experimental::signatures&#39;;
use Method::Signatures;

sub native_assignment { 
    die &amp;quot;Too few arguments for subroutine $!&amp;quot; unless @_ == 1; 
    my ($var) = @_;
}

sub native_signature ($var) {}

func method_signature ($var) {}

cmpthese(-5, {
    native_assignment=&amp;gt; sub { native_assignment(1)},
    native_signature =&amp;gt; sub { native_signature(1) },
    method_signature =&amp;gt; sub { method_signature(1) },
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code begins by importing the necessary libraries. The line &amp;ldquo;no warnings &amp;lsquo;experimental::signatures&amp;rsquo; stops Perl from warning about the use of subroutine signatures. The code then declares the three subroutines we want to test: one is the normal variable assignment, one native subroutine signature and one for Method::Signatures (&amp;ldquo;func&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Because the benchmark module executes tests in alphabetical order, every benchmark was run three times with the tests renamed each time to change the test order (every test was run first, second and third across the three benchmarks).&lt;/p&gt;

&lt;h3 id=&#34;results:93413df609358a1a5a975a341330277a&#34;&gt;Results&lt;/h3&gt;

&lt;p&gt;Running this benchmark returned the following results:&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;native_signature&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;method_signature&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;native_assignment&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;native_signature&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;--&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-10%&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-27%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;method_signature&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;12%&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;--&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-19%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;native_assignment&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;38%&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;23%&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;--&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The results showed native subroutine signatures to be about 12% slower than the Method::Signatures function and 38% slower than the native assignment subroutine. So is this the price of the cleaner syntax? Actually it&amp;rsquo;s not the whole story.&lt;/p&gt;

&lt;h3 id=&#34;changing-the-number-of-variables:93413df609358a1a5a975a341330277a&#34;&gt;Changing the number of variables&lt;/h3&gt;

&lt;p&gt;Would changing the number of variables assigned in the subroutine affect the relative performance of the three subroutine types? I re-ran the benchmarks, only this time incrementing the number of variables being assigned and plotted the results:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dnmfarrell.github.io/static/images/88/signatures%20comparison.png&#34; title=&#34;Comparison of signatures speed with varying number of variables&#34;&gt;&lt;img src=&#34;https://dnmfarrell.github.io/static/images/88/signatures%20comparison_small.png&#34; alt=&#34;Comparison of signatures speed with increasing number of variables&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The results showed that increasing the number of variables improved the relative speed of native subroutine signatures against Method::Signatures. With two variable assignments their speed is about par. With three or more variables, native subroutine signatures outperforms, up to 18% faster. When I discussed these results with Ricardo Signes, he confirmed that the native subroutine signatures code had been optimized for multiple variable assignments, which correlates with the results shown above.&lt;/p&gt;

&lt;h3 id=&#34;faster-subroutine-signatures:93413df609358a1a5a975a341330277a&#34;&gt;Faster subroutine signatures&lt;/h3&gt;

&lt;p&gt;It could be argued that the native subroutine signatures are plenty fast as they are and offer several benefits over both variable assignments and Method::Signatures. However, Ricardo did share a trick with me to make subroutine signatures run even faster, which I can&amp;rsquo;t resist sharing.&lt;/p&gt;

&lt;p&gt;Adding a nameless slurpy parameter (&amp;ldquo;@&amp;rdquo;) to the subroutine signature removes the upper limit on how many arguments can be passed to the subroutine. Let&amp;rsquo;s add the slurpy parameter to the subroutine signature in our benchmark code. I&amp;rsquo;ve also updated the code to take two parameters - the level where previously Method::Signatures and subroutine signatures exhibited similar performance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use Benchmark::Forking &#39;cmpthese&#39;;
use feature &#39;signatures&#39;;
no warnings &#39;experimental::signatures&#39;;
use Method::Signatures;

sub native_assignment { 
    die &amp;quot;Too few arguments for subroutine $!&amp;quot; unless @_ == 2; 
    my ($var1, $var2) = @_;
}

sub native_signature ($var1, $var2, @) {}

func method_signature ($var1, $var2) {}

cmpthese(-5, {
    native_assignment=&amp;gt; sub { native_assignment(1, 2)},
    native_signature =&amp;gt; sub { native_signature(1, 2) },
    method_signature =&amp;gt; sub { method_signature(1, 2) },
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here are the results:&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;col width=&#34;25%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;method_signature&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;native_signature&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;native_assignment&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;method_signature&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;--&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-23%&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-37%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;native_signature&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;30%&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;--&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-18%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;native_assignment&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;60%&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;23%&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;--&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;By adding the slurpy parameter, native subroutine signatures performance improved by 30%! This is because the subroutine no longer has to run a variable count check against the upper limit of variables accepted by the signature. It&amp;rsquo;s up to you if you want to remove this check for the performance gain or not - I can&amp;rsquo;t think of a use case where this would be worth it, but you never know.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:93413df609358a1a5a975a341330277a&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Subroutine variable assignment is a relatively inexpensive operation and unlikely to be a bottleneck in your code running time. However the speed benchmarks show that by switching to subroutine signatures is unlikely to regress and in some cases will improve run time speed. So use them with confidence!&lt;/p&gt;

&lt;h3 id=&#34;thanks:93413df609358a1a5a975a341330277a&#34;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;Thanks to Perl pumpking Ricardo Signes for providing detail on the subroutine signatures implementation and slury parameter optimization.&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F88%2F2014%2F5%2F12%2FBenchmarking-subroutine-signatures&amp;amp;text=Benchmarking+subroutine+signatures&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F88%2F2014%2F5%2F12%2FBenchmarking-subroutine-signatures&amp;amp;via=perltricks&#34;&gt;tweet&lt;/a&gt; about it!&lt;/p&gt;

&lt;p&gt;*&lt;strong&gt;Edit:&lt;/strong&gt; article code and benchmarks corrected for single variable assignment on 2014/05/12*&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl levels up with native subroutine signatures</title>
      <link>https://dnmfarrell.github.io/article/72/2014/2/24/Perl-levels-up-with-native-subroutine-signatures/</link>
      <pubDate>Mon, 24 Feb 2014 03:55:52 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/72/2014/2/24/Perl-levels-up-with-native-subroutine-signatures/</guid>
      <description>

&lt;p&gt;&lt;em&gt;It&amp;rsquo;s been a long time coming, but subroutine signatures have just been added to Perl. Although Perl version 5.20 is not due until the Spring, you can use subroutine signatures with the latest Perl development release now.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;requirements:76bdd2424109ffd28684aebfa664547d&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ll need to install a copy of the latest Perl development release (v5.19.9). You can get this with Perlbrew:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perlbrew install perl-5.19.9
$ perlbrew switch perl-5.19.9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or you can download and build Perl v5.19.9 from &lt;a href=&#34;http://www.cpan.org/src/README.html&#34;&gt;cpan.org&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once 5.19.9 is installed, you&amp;rsquo;ll need the &lt;a href=&#34;https://metacpan.org/pod/experimental&#34;&gt;experimental&lt;/a&gt; distribution. Install it via cpan at the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpan experimental
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;subroutine-signatures-explained:76bdd2424109ffd28684aebfa664547d&#34;&gt;Subroutine signatures explained&lt;/h3&gt;

&lt;p&gt;A subroutine signature is a formal list of parameters for a subroutine. You can declare a subroutine signature like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use experimental &#39;signatures&#39;;

sub echo ($message) {
    print &amp;quot;$message\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example &amp;ldquo;($message)&amp;rdquo; is the subroutine signature. That indicates that all calls to the echo subroutine must pass one parameter. When the subroutine is called, the parameter is assigned to $message and available for use within the scope of the subroutine.&lt;/p&gt;

&lt;h3 id=&#34;default-values:76bdd2424109ffd28684aebfa664547d&#34;&gt;Default values&lt;/h3&gt;

&lt;p&gt;A signature can also declare default values for its parameters. Let&amp;rsquo;s add a default message to the echo subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use experimental &#39;signatures&#39;;

sub echo ($message = &#39;Hello World!&#39;) {
    print &amp;quot;$message\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the value of $message will default to &amp;ldquo;Hello World!&amp;rdquo; when the subroutine is called without arguments.&lt;/p&gt;

&lt;p&gt;Subroutine signatures can also declare optional and slurpy parameters. If you&amp;rsquo;d like to see examples, check out the new subroutine signatures entry in Perl&amp;rsquo;s &lt;a href=&#34;http://search.cpan.org/~tonyc/perl-5.19.9/pod/perlsub.pod#Signatures&#34;&gt;official documentation.&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;argument-checking:76bdd2424109ffd28684aebfa664547d&#34;&gt;Argument checking&lt;/h3&gt;

&lt;p&gt;Adding a signature to a subroutine enables argument checking for all calls to that subroutine. For example this code generates an error when run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use experimental &#39;signatures&#39;;

sub echo ($message) {
    print &amp;quot;$message\n&amp;quot;;
}

echo(); # missing argument
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl echo.pl
Too few arguments for subroutine at echo.pl line 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl will also raise an error if too many arguments are passed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use experimental &#39;signatures&#39;;

sub echo ($message) {
    print &amp;quot;$message\n&amp;quot;;
}

echo(&#39;hello&#39;, &#39;world&#39;); # too many arguments
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl echo.pl
Too many arguments for subroutine at echo.pl line 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is helpful- it avoids the need to write boilerplate argument checking code inside subroutines. Beware though; as there is no value check, the following will not raise an arguments error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use experimental &#39;signatures&#39;;

sub echo ($message) {
    print &amp;quot;$message\n&amp;quot;;
}

echo(undef); #undef is an argument
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;less-ugly-code:76bdd2424109ffd28684aebfa664547d&#34;&gt;Less ugly code&lt;/h3&gt;

&lt;p&gt;You can banish those unsightly variable assignments from your subroutines. Say goodbye (and good riddance) to this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub ugly_code {
    my ($arg1, $arg2, arg3) = @_;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And say hello to this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub fine_code ($arg1, $arg2, arg3){
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;further-enhancements-are-coming:76bdd2424109ffd28684aebfa664547d&#34;&gt;Further enhancements are coming&lt;/h3&gt;

&lt;p&gt;The native subroutine signatures implementation is a minimalist one compared to the feature-full &lt;a href=&#34;https://metacpan.org/pod/Method::Signatures&#34;&gt;Method::Signatures&lt;/a&gt; module. Peter Martini the main sponsor of Perl&amp;rsquo;s native subroutine signatures, has confirmed plans to add type checking, aliases, read-only copies, and named parameters in the future. He expects each of these features to bring speed improvements too.&lt;/p&gt;

&lt;h3 id=&#34;revisiting-an-old-python-and-perl-comparison:76bdd2424109ffd28684aebfa664547d&#34;&gt;Revisiting an old Python and Perl comparison&lt;/h3&gt;

&lt;p&gt;On page 5 of &lt;a href=&#34;http://www.amazon.com/gp/product/193518220X/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=193518220X&amp;amp;linkCode=as2&amp;amp;tag=perltrickscom-20&#34;&gt;The Quick Python Book, Second Edition&lt;/a&gt; (affiliate link), the author compares equivalent Perl and Python functions for readability. In the author&amp;rsquo;s view, the Python code is more readable than the Perl code. It&amp;rsquo;s a straw man argument as the Perl example is written in &amp;ldquo;baby Perl&amp;rdquo;, but let&amp;rsquo;s revisit the example using Perl&amp;rsquo;s native subroutine signatures feature. This is the Python example, unmodified:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;def pairwise_sum(list1, list2):
    result = []
    for i in range(len(list1)):
        result.append(list1[i] + list2[i])
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is the original Perl code example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub pairwise_sum {
    my($arg1, $arg2) = @_;
    my(@result) = ();
    @list1 = @$arg1;
    @list2 = @$arg2;
    for($i=0; $i &amp;lt; length(@list1); $i++) {
        push(@result, $list1[$i] + $list2[$i]);
    }
    return(\@result);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is a refactored Perl version:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub pairwise_sum {
    my ($arg1, $arg2) = @_;
    return map { $arg1-&amp;gt;[$_] + $arg2-&amp;gt;[$_] } 0 .. $#$arg1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code is cleaner and shorter than the original Perl code. It&amp;rsquo;s also shorter than the Python example. But is it cleaner? Using subroutine signatures, we can do better:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub pairwise_sum ($arg1, $arg2) {
    return map { $arg1-&amp;gt;[$_] + $arg2-&amp;gt;[$_] } 0 .. $#$arg1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that using subroutine signatures has saved us a line of code for parameter assignment. Now there can be no argument: the Perl code is shorter and cleaner than the Python example. Nice!&lt;/p&gt;

&lt;h3 id=&#34;conclusion:76bdd2424109ffd28684aebfa664547d&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Subroutine signatures is a leap-forward for Perl technically and a boost for the Perl community. It&amp;rsquo;s motivating to see significant language advancements and there are more on the way. With &lt;a href=&#34;http://perltricks.com/article/68/2014/2/13/Cool-new-Perl-feature-postfix-dereferencing&#34;&gt;postfix dereferencing&lt;/a&gt;, new &lt;a href=&#34;http://blogs.perl.org/users/matthew_horsfall/2014/02/perl-519x-performance-improvements.html&#34;&gt;performance enhancements&lt;/a&gt; and now subroutine signatures, Perl version 5.20 is going to be the most significant release since 5.10. Roll on Spring 2014!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2014-02-24: article updated to correct the error checking implementation, Perl code example and clarify Peter Martini&amp;rsquo;s role in the Perl core signatures development.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F72%2F2014%2F2%2F24%2FPerl-levels-up-with-native-subroutine-signatures&amp;amp;text=Perl+levels+up+with+native+subroutine+signatures&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F72%2F2014%2F2%2F24%2FPerl-levels-up-with-native-subroutine-signatures&amp;amp;via=perltricks&#34;&gt;retweet&lt;/a&gt; it!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Banish unsightly variable assignments with Method::Signatures</title>
      <link>https://dnmfarrell.github.io/article/39/2013/9/8/Banish-unsightly-variable-assignments-with-Method--Signatures/</link>
      <pubDate>Sun, 08 Sep 2013 22:59:38 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/39/2013/9/8/Banish-unsightly-variable-assignments-with-Method--Signatures/</guid>
      <description>

&lt;p&gt;One drawback of Perl is that its subroutines and methods do not have signatures (ignoring &lt;a href=&#34;http://perldoc.perl.org/perlsub.html#Prototypes&#34;&gt;prototypes&lt;/a&gt;). This means that Perl developers have to write their own code for variable assignment and type checking which leads to repetitive and verbose code. This article shows how by using the &lt;a href=&#34;https://metacpan.org/module/Method::Signatures&#34;&gt;Method::Signatures&lt;/a&gt; module developers can banish this boilerplate forever.&lt;/p&gt;

&lt;h3 id=&#34;the-func-subroutine:d44a2fcf4a84b486b8683659b04d7a8c&#34;&gt;The func subroutine&lt;/h3&gt;

&lt;p&gt;Method::Signatures exports a subroutine called &amp;ldquo;func&amp;rdquo; which can replace the &amp;ldquo;sub&amp;rdquo; built-in function. Let&amp;rsquo;s look at a typical Perl subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Carp qw/croak/;
sub extract_domain {
    my $url = @_;
    croak &amp;quot;Error missing argument URL $!&amp;quot; unless $url;
    # code continues ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can refactor this subroutines using &amp;ldquo;func&amp;rdquo; which accepts a signature (list of variables):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Method::Signatures;
func extract_domain ($url) {
    # code continues ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Replacing &amp;ldquo;sub&amp;rdquo; with &amp;ldquo;func&amp;rdquo; means that it will declare $url, croak if $_[0] doesn&amp;rsquo;t exist, else assign it to $url. This removes the need to include the boilerplate assignment and check code which in the example reduce the code length by 33% (2 lines of code).&lt;/p&gt;

&lt;h3 id=&#34;the-method-subroutine:d44a2fcf4a84b486b8683659b04d7a8c&#34;&gt;The method subroutine&lt;/h3&gt;

&lt;p&gt;Method::Signatures also exports a subroutine called &amp;ldquo;method&amp;rdquo; that can replace &amp;ldquo;sub&amp;rdquo; in object-oriented code. In addition to accepting a signature argument like &amp;ldquo;func&amp;rdquo;, &amp;ldquo;method&amp;rdquo; automatically declares and assigns $self. Consider the difference between this code extract (taken from &lt;a href=&#34;https://metacpan.org/module/Nginx::Log::Entry&#34;&gt;Nginx::Log::Entry&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Entry;
use Time::Piece;
use Nginx::ParseLog;
use HTTP::BrowserDetect;

sub new {
    my ( $class, $log_line ) = @_;
    die &amp;quot;Error: no log string was passed to new&amp;quot; unless $log_line;
    my $self = Nginx::ParseLog::parse($log_line); 
    $self-&amp;gt;{detector} = HTTP::BrowserDetect-&amp;gt;new( $self-&amp;gt;{user_agent} );
    return bless $self, $class;
}

sub get_ip {
    my $self = shift;
    return $self-&amp;gt;{ip};
}
    
sub get_timezone {
    my $self = shift;
    return substr( $self-&amp;gt;{time}, -5 );
}   

sub was_robot {
    my $self = shift;
    return $self-&amp;gt;{detector}-&amp;gt;robot;
}

sub get_status {
    my $self = shift;
    return $self-&amp;gt;{status};
}

sub get_request {
    my $self = shift;
    return $self-&amp;gt;{request};
}

1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and a refactored version using &amp;ldquo;method&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Entry_New;
use Time::Piece;
use Nginx::ParseLog;
use HTTP::BrowserDetect;
use Method::Signatures;

func new ($class, $log_line) {
    my $self = Nginx::ParseLog::parse($log_line);
    $self-&amp;gt;{detector} = HTTP::BrowserDetect-&amp;gt;new( $self-&amp;gt;{user_agent} );
    return bless $self, $class;
}   

method get_ip {
    return $self-&amp;gt;{ip};
}   
    
method get_timezone {
    return substr( $self-&amp;gt;{time}, -5 );
}
    
method was_robot { 
    return $self-&amp;gt;{detector}-&amp;gt;robot;
}

method get_status {
    return $self-&amp;gt;{status};
}

method get_request {
    return $self-&amp;gt;{request};
}   

1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By using &amp;ldquo;method&amp;rdquo; we were able to remove all the boilerplate declarations and checks from the code, reducing the code length by almost 20% and improving its readability.&lt;/p&gt;

&lt;h3 id=&#34;benchmarking-method-signatures:d44a2fcf4a84b486b8683659b04d7a8c&#34;&gt;Benchmarking Method::Signatures&lt;/h3&gt;

&lt;p&gt;Does using Method::Signatures come with a significant performance hit? We can test the performance impact by comparing the vanilla and refactored Entry classes from earlier in this article. We&amp;rsquo;ll use the &lt;a href=&#34;https://metacpan.org/module/Benchmark::Forking&#34;&gt;Benchmark::Forking&lt;/a&gt; module to improve the benchmark accuracy. This is the benchmark script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Benchmark::Forking qw/cmpthese/;
use Entry;
use Entry_New;

open (my $LOG, &#39;&amp;lt;&#39;, &#39;access.log&#39;);
my @log = &amp;lt;$LOG&amp;gt;;

cmpthese (100, {
        Entry       =&amp;gt; sub { foreach (@log) {
                                my $entry = Entry-&amp;gt;new($_);
                                $entry-&amp;gt;get_ip;
                                $entry-&amp;gt;get_timezone;
                                $entry-&amp;gt;was_robot;
                                $entry-&amp;gt;get_status;
                                $entry-&amp;gt;get_request;
                              }
                       },
        Entry_New   =&amp;gt; sub { foreach (@log) {
                                my $entry = Entry_New-&amp;gt;new($_);
                                $entry-&amp;gt;get_ip;
                                $entry-&amp;gt;get_timezone;
                                $entry-&amp;gt;was_robot;
                                $entry-&amp;gt;get_status;
                                $entry-&amp;gt;get_request;
                             }
                       },      
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This script reads an Nginx access log of 10000 entries into @log. For both Entry and Entry_New, it will test 100 times the performance of initializing an Entry object and calling the accessor methods of the object. It does this for every entry in @log. Running the benchmark script returned the following result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;            s/iter   Entry_New   Entry
Entry_New   1.65        --        -1%
Entry       1.63        1%        --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These results suggest that using Method::Signatures comes with only a 1% performance hit, which seems like excellent value given the functionality it provides.&lt;/p&gt;

&lt;h3 id=&#34;additional-features:d44a2fcf4a84b486b8683659b04d7a8c&#34;&gt;Additional features&lt;/h3&gt;

&lt;p&gt;There is a lot more to Method::Signatures such as named and optional parameters, type checking, default values and aliases. Check out the excellent module &lt;a href=&#34;https://metacpan.org/module/Method::Signatures&#34;&gt;documentation&lt;/a&gt; for more details.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to track new CPAN releases</title>
      <link>https://dnmfarrell.github.io/article/33/2013/7/29/How-to-track-new-CPAN-releases/</link>
      <pubDate>Mon, 29 Jul 2013 01:11:31 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/33/2013/7/29/How-to-track-new-CPAN-releases/</guid>
      <description>

&lt;p&gt;CPAN is a fantastic Perl resource with thousands of modules and new ones being added all the time. But how do you keep track of what&amp;rsquo;s being released? This article describes three techniques for keeping tabs on the latest CPAN releases.&lt;/p&gt;

&lt;h3 id=&#34;cpan-org:1bfc29f171e882ce9b1eb00fa28d0101&#34;&gt;CPAN.org&lt;/h3&gt;

&lt;p&gt;The CPAN website&amp;rsquo;s &lt;a href=&#34;http://search.cpan.org/recent&#34;&gt;recent uploads&lt;/a&gt; page maintains a list of the latest CPAN releases, with links to the module documentation. Additionally it&amp;rsquo;s possible to search the release history using the navigating arrow links at the top of the page.&lt;/p&gt;

&lt;h3 id=&#34;cpan-recent-uploads:1bfc29f171e882ce9b1eb00fa28d0101&#34;&gt;CPAN::Recent::Uploads&lt;/h3&gt;

&lt;p&gt;Chris Williams&amp;rsquo; &lt;a href=&#34;https://metacpan.org/module/CPAN::Recent::Uploads&#34;&gt;CPAN::Recent::Uploads&lt;/a&gt; module offers a programmatic interface to track recent CPAN uploads. It provides a &amp;ldquo;recent&amp;rdquo; function that accepts two optional arguments: the time from which to view uploads since and the URL of the CPAN mirror to use. By default it will return a list of modules released in the past week on the CPAN mirror &amp;ldquo;&lt;a href=&#34;ftp://ftp.funet.fi/pub/CPAN/&amp;quot;&#34;&gt;ftp://ftp.funet.fi/pub/CPAN/&amp;quot;&lt;/a&gt;. The module&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/module/CPAN::Recent::Uploads&#34;&gt;documentation&lt;/a&gt; also has an example Perl one liner. To see CPAN::Recent::Uploads in action, enter this at the command-line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# print a list of this week&#39;s CPAN releases
perl -MCPAN::Recent::Uploads -le &amp;quot;print for CPAN::Recent::Uploads-&amp;gt;recent;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;twitter:1bfc29f171e882ce9b1eb00fa28d0101&#34;&gt;Twitter&lt;/h3&gt;

&lt;p&gt;The Twitter account &lt;a href=&#34;https://twitter.com/cpan_new&#34;&gt;CPAN New Modules&lt;/a&gt; tweets every new CPAN release. The author Punytan has also released the source code on &lt;a href=&#34;https://t.co/K7KnELaYzk&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can subscribe to the stream by clicking this button: &lt;a href=&#34;https://twitter.com/cpan_new&#34;&gt;Follow @cpan_new&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Re-use code with Perl&#39;s anonymous functions</title>
      <link>https://dnmfarrell.github.io/article/34/2013/7/17/Re-use-code-with-Perl-s-anonymous-functions/</link>
      <pubDate>Wed, 17 Jul 2013 03:10:55 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/34/2013/7/17/Re-use-code-with-Perl-s-anonymous-functions/</guid>
      <description>&lt;p&gt;An anonymous function in Perl is an unnamed subroutine. But what are they good for? This article shows how through using anonymous functions it&amp;rsquo;s possible to write more generic, re-usable Perl code.&lt;/p&gt;

&lt;p&gt;Imagine that you&amp;rsquo;ve developed the following script. The script receives a directory path as a parameter and recursively searches the child directories of the path, printing any file name it finds:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use feature qw/say/;

die &amp;quot;Error: you must supply a directory path argument $!&amp;quot; unless @ARGV;

sub listFiles {
    my $dir = shift;
    opendir(my $DH, $dir) or die &amp;quot;Error: failed to open $dir $!&amp;quot;;

    while (readdir $DH) {
        my $path = $dir . $_;
        if(-d $path ){
            # recurse but ignore Linux symlinks . and ..
            listFiles($path .&#39;/&#39;) if $_ !~ /^\.{1,2}$/;
        }
        elsif(-f $path){
            say $path;
        }
    }
}

listFiles($ARGV[0]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The most re-usable aspect of this script is the recursive directory searching logic. If you wanted to develop a file name searching script (similar to the find program in Linux), you could start by copying and pasting the script above, and then updating the code to provide the required behavior. An alternative way would be to change the core subroutine to accept an anonymous function as an argument, and then execute that function on every file it finds. Such a subroutine would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use feature qw/say/;

die &amp;quot;Error: you must supply a directory path argument $!&amp;quot; unless @ARGV;

sub walkDir {
    my ($dir, $function) = @_;

    # validate args
    opendir(my $DH, $dir) or die &amp;quot;Error: failed to open $dir $!&amp;quot;;
    ref($function) eq &#39;CODE&#39; or 
        die &amp;quot;Error: second argument to walkDir must be an anonymous function $!&amp;quot;;

    while (readdir $DH) {
        my $path = $dir . $_;
        if(-d $path ){ 
            # recurse but ignore Linux symlinks . and ..
            walkDir($path . &#39;/&#39;, $function) if $_ !~ /^\.{1,2}$/;
        }
        elsif(-f $path){
            $function-&amp;gt;($path);
        }
    }
}

walkDir($ARGV[0], sub { say shift });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;walkDir&amp;rdquo; subroutine in the code above accepts two arguments: the directory path and a function. It recursively searches the directories as before, however when it encounters a file, it de-references and executes the function, passing the file path to the function as an argument. The final line of code provides the file name printing behaviour by calling &amp;ldquo;walkDir&amp;rdquo; and passing the target directory path, and an anonymous function to print (say) the default argument.&lt;/p&gt;

&lt;p&gt;We can re-use the same walkDir subroutine for our file-searching script and all we have to do is update the anonymous function behavior:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;walkDir($ARGV[0], 
        sub { 
            my $filename = shift;
            say $filename if $filename =~ /$ARGV[1]/i;
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create a grep-like tool, we would replace the previous code with this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use File::Slurp;
walkDir($ARGV[0],
        sub {
            my $filename = shift;
            say $filename if read_file($filename) =~ qr/$ARGV[1]/i;
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact we could quickly create a whole library of useful sysadmin scripts with this approach. We could even put the &amp;ldquo;walkDir&amp;rdquo; subroutine code into a module to augment further re-use. Hopefully these examples show how by using anonymous functions, Perl let&amp;rsquo;s you re-use useful code.&lt;/p&gt;

&lt;p&gt;This article was inspired by &lt;a href=&#34;http://hop.perl.plover.com/&#34;&gt;Higher Order Perl&lt;/a&gt; by Mark Jason Dominus. Higher Order Perl explores anonymous functions and other functional programming techniques like recursion, currying and laziness. It&amp;rsquo;s free to read online and in ebook format.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Use the logical-or and defined-or operators to provide default subroutine variable behaviour</title>
      <link>https://dnmfarrell.github.io/article/32/2013/7/6/Use-the-logical-or-and-defined-or-operators-to-provide-default-subroutine-variable-behaviour/</link>
      <pubDate>Sat, 06 Jul 2013 20:42:40 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/32/2013/7/6/Use-the-logical-or-and-defined-or-operators-to-provide-default-subroutine-variable-behaviour/</guid>
      <description>

&lt;p&gt;Perl subroutines do not have signatures so variables must be initialized and arguments assigned to them inside the subroutine code. This article describes two useful shortcuts that can simplify this process.&lt;/p&gt;

&lt;h3 id=&#34;logical-or:90d24dc771efc5929901275b1ff1d295&#34;&gt;Logical-or&lt;/h3&gt;

&lt;p&gt;One trick that Perl programmers use is the logical-or operator (&amp;lsquo;||&amp;rsquo;) to provide default behaviour for subroutine arguments. The default behaviour will only occur if the argument is provided is false (undefined, zero or a zero-length string). Imagine that we&amp;rsquo;re developing a subroutine that processes data for car insurance quotes - we&amp;rsquo;ll need to collect some basic data such as the applicant&amp;rsquo;s date of birth, sex and number of years driving. All of the arguments are mandatory - we can use the logical-or operator to return early if these arguments are false.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;

sub process_quote_data {
    my $args = shift;
    my $dob = $args-&amp;gt;{dob} || return 0;
    my $sex = $args-&amp;gt;{sex} || return 0;
    my $years_driving = 
        defined($args-&amp;gt;{years_driving}) ? $args-&amp;gt;{years_driving} : return 0;

    # do stuff
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What this subroutine code does is assign the first element of the default array (@_) to $args using shift. By default shift will operate on @_, so there is no need to include it as an argument. Next the subroutine initializes and assigns the $dob and $sex variables. In both cases we use the logical-or (&amp;lsquo;||&amp;rsquo;) operator to return early from the subroutine if these variables are false. This is a more concise code pattern than using an if statement block. We cannot use this trick to return early from the $years_driving variable as it may be provided as zero, which Perl treats as logical false but we want to keep. So in this case we have to first check if the argument was defined (which would include zero) and then use a ternary operator to either assign the value or return early.&lt;/p&gt;

&lt;h3 id=&#34;defined-or:90d24dc771efc5929901275b1ff1d295&#34;&gt;Defined-or&lt;/h3&gt;

&lt;p&gt;Since version 5.10.0 Perl has has had the defined-or operator (&amp;lsquo;//&amp;rsquo;). This will check if the variable is defined, and if it is not, Perl will execute the code on the right-side of the operator. We can use it to simplify our subroutine code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use 5.10.0;

sub process_quote_data {
    my $args = shift;
    my $dob = $args-&amp;gt;{dob} || return 0;
    my $sex = $args-&amp;gt;{sex} || return 0;
    my $years_driving = $args-&amp;gt;{years_driving} // return 0;

    # do stuff
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the modified code above, first we have included a line to use Perl 5.10.0 or greater - this will ensure that the version of Perl executing the code has the defined-or operator. Next we&amp;rsquo;ve simplified the code for $years_driving to use the logical-or operator. This will now accept zero as an argument, but return when $years_driving is undefined.&lt;/p&gt;

&lt;h3 id=&#34;default-values:90d24dc771efc5929901275b1ff1d295&#34;&gt;Default values&lt;/h3&gt;

&lt;p&gt;We can also use defined-or to provide default values for subroutine arguments. For example if we assumed that all users of our subroutine are male, we can change the $sex variable to default to &amp;rsquo;M&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use 5.10.0;

sub process_quote_data {
    my $args = shift;
    my $dob = $args-&amp;gt;{dob} || return 0;
    my $sex = $args-&amp;gt;{sex} // &#39;M&#39;;
    my $years_driving = $args-&amp;gt;{years_driving} // return 0;

    # do stuff
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if the $sex variable is undef, the process_quote_data subroutine will assign &amp;rsquo;M&amp;rsquo; as it&amp;rsquo;s value.&lt;/p&gt;

&lt;p&gt;You can read more about these operators and in the &lt;a href=&#34;http://perldoc.perl.org/perlop.html#Logical-Defined-Or&#34;&gt;perlop section&lt;/a&gt; of the official Perl documentation.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

