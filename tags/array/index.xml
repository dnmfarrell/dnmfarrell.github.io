<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Array on Perl programming news, code and culture</title>
    <link>https://dnmfarrell.github.io/tags/array/</link>
    <description>Recent content in Array on Perl programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Oct 2014 12:42:52 +0000</lastBuildDate>
    <atom:link href="https://dnmfarrell.github.io/tags/array/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Perl&#39;s versatile split function</title>
      <link>https://dnmfarrell.github.io/article/121/2014/10/24/Perl-s-versatile-split-function/</link>
      <pubDate>Fri, 24 Oct 2014 12:42:52 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/121/2014/10/24/Perl-s-versatile-split-function/</guid>
      <description>

&lt;p&gt;I love Perl&amp;rsquo;s &lt;a href=&#34;http://perldoc.perl.org/functions/split.html&#34;&gt;split&lt;/a&gt; function. Far more powerful than its feeble cousin &lt;a href=&#34;http://perldoc.perl.org/functions/join.html&#34;&gt;join&lt;/a&gt;, split has some wonderful features that should make it a regular feature of any Perl programmer&amp;rsquo;s toolbox. Let&amp;rsquo;s look at some examples.&lt;/p&gt;

&lt;h3 id=&#34;split-a-sentence-into-words:98ca83694834614d84748d8e2ca4ac0f&#34;&gt;Split a sentence into words&lt;/h3&gt;

&lt;p&gt;To split a sentence into words, you might think about using a whitespace regex pattern like &lt;code&gt;/\s+/&lt;/code&gt; which splits on contiguous whitespace. Split will ignore trailing whitespace, but what if the input string has &lt;em&gt;leading&lt;/em&gt; whitespace? A better option is to use a single space string: &lt;code&gt;&#39; &#39;&lt;/code&gt;. This is a special case where Perl emulates awk and will split on all contiguous whitespace, trimming any leading or trailing whitespace as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @words = split &#39; &#39;, $sentence;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or loop through each word and do something:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use 5.010;
say for (split &#39; &#39;, &#39; 12 Angry Men &#39;);
# 12
# Angry
# Men
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The single-space pattern is also the default pattern for &lt;code&gt;split&lt;/code&gt;, which by default operates on &lt;code&gt;$_&lt;/code&gt;. This can lead to some seriously minimalist code. For example if I needed to split every name in a list of full names and do something with them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;for (@full_names)
{
    for (split)
    {
        # do something
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And who says Perl looks like line noise?&lt;/p&gt;

&lt;h3 id=&#34;create-a-char-array:98ca83694834614d84748d8e2ca4ac0f&#34;&gt;Create a char array&lt;/h3&gt;

&lt;p&gt;To split a word into separate letters, just pass an empty regex &lt;code&gt;//&lt;/code&gt; to split:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @letters = split //, $word;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parse-a-url-or-filepath:98ca83694834614d84748d8e2ca4ac0f&#34;&gt;Parse a URL or filepath&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s tempting to reach for a regex when parsing strings, but for URLs or filepaths &lt;code&gt;split&lt;/code&gt; usually works better. For example if you wanted to get the parent directory from a filepath:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @directories = split &#39;/&#39;, &#39;/home/user/documents/business_plan.ods&#39;;
my $parent_directory = $directories[-2];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here I split the filepath on slash and use the negative index &lt;code&gt;-2&lt;/code&gt; to get the parent directory. The challenge with filepaths is that they can have n depth, but the parent directory of a file will always be the last but one element of a filepath, so &lt;code&gt;split&lt;/code&gt; works well.&lt;/p&gt;

&lt;h3 id=&#34;extract-only-the-first-few-columns-from-a-separated-file:98ca83694834614d84748d8e2ca4ac0f&#34;&gt;Extract only the first few columns from a separated file&lt;/h3&gt;

&lt;p&gt;How many times have you parsed a comma separated file, but didn&amp;rsquo;t want all of the columns in the file? Let&amp;rsquo;s say you wanted the first 3 columns from a file, you might do it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;while &amp;lt;$read_file&amp;gt;
{
    my @columns = split /,/;
    my $name    = $columns[0];
    my $email   = $columns[1];
    my $account = $columns[2];
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is all well and good, but &lt;code&gt;split&lt;/code&gt; can return a limited number of results if you want:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;while &amp;lt;$read_file&amp;gt;
{
    my ($name, $email, $account) = split /,/;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or to revisit an earlier example, splitting on whitespace:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;for (@full_names)
{
    my ($firstname, $lastname) = split;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion:98ca83694834614d84748d8e2ca4ac0f&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;These are just a few examples of Perl&amp;rsquo;s versatile &lt;code&gt;split&lt;/code&gt; function. Check out the official documentation &lt;a href=&#34;http://perldoc.perl.org/functions/split.html&#34;&gt;online&lt;/a&gt; or via the terminal with &lt;code&gt;$ perldoc -f split&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl references: create, dereference and debug with confidence</title>
      <link>https://dnmfarrell.github.io/article/80/2014/3/27/Perl-references--create--dereference-and-debug-with-confidence/</link>
      <pubDate>Thu, 27 Mar 2014 18:03:49 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/80/2014/3/27/Perl-references--create--dereference-and-debug-with-confidence/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Learning Perl&amp;rsquo;s references is a rite-of-passage for Perl programmers. Until you &amp;ldquo;get&amp;rdquo; references, large parts of the language will remain alien to you. References have their own special syntax and rules, which can make them seem strange and hard to understand. The good news is that the core features of references are easy to learn and use. This article describes the main ways to use references and some handy tools to get you out of trouble if you run into it. So even if you&amp;rsquo;re not completely comfortable with references, you&amp;rsquo;ll be able to write code that works.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;what-are-references:6a29add5aea08a862cc77cb68480c39b&#34;&gt;What are references?&lt;/h3&gt;

&lt;p&gt;A reference is a scalar variable whose value is a pointer to another Perl variable. If you were to print out a reference, you would see something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;SCALAR(0x509ea0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The value looks like a memory address, bu it&amp;rsquo;s actually an internal key for Perl, which points to another variable. A reference can refer to any of Perl&amp;rsquo;s variable types: scalars, arrays, hashes, filehandles, subroutines and globs. References are useful because they:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;save memory - why create two copies of the same variable when you only need one?&lt;/li&gt;
&lt;li&gt;enable subroutines to return values that are not in a scalar or list format. (the reference is a scalar pointer to values that can be in any kind of format).&lt;/li&gt;
&lt;li&gt;can encapsulate complex data structures comprising of nested arrays, hashes, scalars and more.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Accessing the value that a reference points to is called &amp;ldquo;dereferencing&amp;rdquo;. When you dereference a reference, instead of returning the value of it&amp;rsquo;s pointer, Perl will fetch the actual variable that the reference is pointing to. The need to dereference a reference variable in order to use it&amp;rsquo;s underlying value is the main disadvantage of references; direct variable access will always be faster.&lt;/p&gt;

&lt;h3 id=&#34;declaring-and-accessing-references:6a29add5aea08a862cc77cb68480c39b&#34;&gt;Declaring and accessing references&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re going to focus on array and hash references as those are the most commonly encountered reference types. Working them is easy. For arrays, use square brackets instead of parentheses to declare, and the arrow operator (&amp;ldquo;-&amp;gt;&amp;rdquo;) to dereference:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @array       = (&#39;apple&#39;, &#39;banana&#39;, &#39;pear&#39;);
my $array_ref   = [&#39;apple&#39;, &#39;banana&#39;, &#39;pear&#39;];

print $array[1];       #banana
print $array_ref-&amp;gt;[1]; #banana
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For hashes, use curly braces instead of parentheses to declare, and the same arrow operator to dereference:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my %hash        = (one =&amp;gt; 1, two =&amp;gt; 2, three =&amp;gt; 3);
my $hash_ref    = {one =&amp;gt; 1, two =&amp;gt; 2, three =&amp;gt; 3};

print $hash{three};       #3
print $hash_ref-&amp;gt;{three}; #3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One of the coolest things about references is the ability to create complex data structures to hold any kind of data you need. Let&amp;rsquo;s look at a more realistic data structure for a fictional customer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $customer = { name   =&amp;gt; &#39;Mr Smith&#39;,
                 dob    =&amp;gt; &#39;01/18/1987&#39;,
                 phones =&amp;gt; { home   =&amp;gt; &#39;212-608-5787&#39;,
                             work   =&amp;gt; &#39;347-558-0352&#39;},
                 last_3_purchase_values =&amp;gt; [ 78.92, 98.36, 131.00 ],
                 addresses =&amp;gt; [ {   street =&amp;gt; &#39;37 Allright Ave&#39;,
                                    zip    =&amp;gt; &#39;11025&#39;,
                                    city   =&amp;gt; &#39;New York&#39;,
                                    state  =&amp;gt; &#39;NY&#39;,
                                }, 
                                {   street =&amp;gt; &#39;23 Broadway&#39;,
                                    zip    =&amp;gt; &#39;10125&#39;,
                                    city   =&amp;gt; &#39;New York&#39;,
                                    state  =&amp;gt; &#39;NY&#39;,
                                },
                               ],
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$customer is a hash ref with 5 keys. Two of the keys (&amp;ldquo;name&amp;rdquo; and &amp;ldquo;dob&amp;rdquo;) have the usual scalar values. The other key values though are nested references: &amp;ldquo;phones&amp;rdquo; is a nested hashref, and &amp;ldquo;last_3_purchase_values&amp;rdquo; and &amp;ldquo;addresses&amp;rdquo; are arrayrefs. So how would you access any of the values in $customer data structure? Check this out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;print $customer-&amp;gt;{name}; # Mr Smith
print $customer-&amp;gt;{phones}{home}; # 212-608-5787
print $customer-&amp;gt;{last_3_purchase_values}[0]; # 78.92
print $customer-&amp;gt;{addresses}[1]{street}; # 23 Broadway
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To dereference a value in $customer, we start by using the arrow operator. From there, we add the required key or index to access the next level of data. The main challenge when working with references is to understand the datatype you are dereferencing: if it is an array, you&amp;rsquo;ll need to use the array accessor syntax &amp;ldquo;[#]&amp;ldquo;, whereas if it&amp;rsquo;s a hash, you need to pass the key in curly braces &amp;ldquo;{key_value}&amp;ldquo;.&lt;/p&gt;

&lt;h3 id=&#34;working-with-arrayrefs:6a29add5aea08a862cc77cb68480c39b&#34;&gt;Working with arrayrefs&lt;/h3&gt;

&lt;p&gt;Sometimes you&amp;rsquo;ll need to loop through an arrayref. The syntax for this is the same as an ordinary array, except that you need to dereference the entire array, rather than a single element of it. This is done by enclosing the arrayref in with a dereferencing array block: &amp;ldquo;@{ $array_ref }&amp;ldquo;. Let look at some examples using $customer&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature &#39;say&#39;;

#iterate through a nested array
foreach my $purchase_value (@{ $customer-&amp;gt;{last_3_purchase_values} }) {
    say $purchase_value;
}

#iterate through a nested array and dereference and print the street
foreach my $address (@{ $customer-&amp;gt;{addresses} }) {
    say $address-&amp;gt;{street};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arrays support other operations like push and shift. In these cases you will need a dereferencing array block too:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;push @{$customer-&amp;gt;{addresses}}, { street =&amp;gt; &#39;157 Van Cordant Street&#39;,
                                  zip    =&amp;gt; &#39;10008&#39;,
                                  city   =&amp;gt; &#39;New York&#39;,
                          state  =&amp;gt; &#39;NY&#39;,
                                 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have pushed a new address on to the &amp;ldquo;addresses&amp;rdquo; arrayref. We used a dereferencing array block to dereference &amp;ldquo;addresses&amp;rdquo; so that we could perform a push on it.&lt;/p&gt;

&lt;h3 id=&#34;working-with-hashrefs:6a29add5aea08a862cc77cb68480c39b&#34;&gt;Working with hashrefs&lt;/h3&gt;

&lt;p&gt;Dereferencing blocks can be used for hash operations too. Probably the most common operation is looping through the keys of the hash, using the &amp;ldquo;keys&amp;rdquo; function. In this case, you&amp;rsquo;ll need to use a dereferencing hash block &amp;ldquo;%{ $hash_ref }&amp;ldquo;. Let&amp;rsquo;s look at an example using $customer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature &#39;say&#39;;

# iterate through a nested hash
foreach my $key (keys %{ $customer-&amp;gt;{phones} }) {
    say $customer-&amp;gt;{phones}{$key};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;troubleshooting-references:6a29add5aea08a862cc77cb68480c39b&#34;&gt;Troubleshooting References&lt;/h3&gt;

&lt;p&gt;References can be harder to debug than normal variables as you need to dereference the reference in order to see what variable it is pointing to. Imagine you wanted to print out the contents of $customer. This doesn&amp;rsquo;t work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;print $customer; # HASH(0x2683b30)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fortunately you can use Data::Dumper&amp;rsquo;s &amp;ldquo;Dumper&amp;rdquo; function to dereference and pretty-print a reference for you:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Data::Dumper;

print Dumper($customer);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Would print:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$VAR1 = {
          &#39;last_3_purchase_values&#39; =&amp;gt; [
                                        &#39;78.92&#39;,
                                        &#39;98.36&#39;,
                                        &#39;131&#39;
                                      ],
          &#39;dob&#39; =&amp;gt; &#39;01/18/1987&#39;,
          &#39;addresses&#39; =&amp;gt; [
                           {
                             &#39;city&#39; =&amp;gt; &#39;New York&#39;,
                             &#39;zip&#39; =&amp;gt; &#39;11025&#39;,
                             &#39;street&#39; =&amp;gt; &#39;37 Allright Ave&#39;,
                             &#39;state&#39; =&amp;gt; &#39;NY&#39;
                           },
                           {
                             &#39;city&#39; =&amp;gt; &#39;New York&#39;,
                             &#39;zip&#39; =&amp;gt; &#39;10125&#39;,
                             &#39;street&#39; =&amp;gt; &#39;23 Broadway&#39;,
                             &#39;state&#39; =&amp;gt; &#39;NY&#39;
                           },
                           {
                             &#39;city&#39; =&amp;gt; &#39;New York&#39;,
                             &#39;zip&#39; =&amp;gt; &#39;10008&#39;,
                             &#39;street&#39; =&amp;gt; &#39;157 Van Cordant Street&#39;,
                             &#39;state&#39; =&amp;gt; &#39;NY&#39;
                           }
                         ],
          &#39;name&#39; =&amp;gt; &#39;Mr Smith&#39;,
          &#39;phones&#39; =&amp;gt; {
                        &#39;work&#39; =&amp;gt; &#39;347-558-0352&#39;,
                        &#39;home&#39; =&amp;gt; &#39;212-608-5787&#39;
                      }
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another useful tool is the Perl&amp;rsquo;s &lt;a href=&#34;http://perldoc.perl.org/functions/ref.html&#34;&gt;ref&lt;/a&gt; function. Just pass the reference variable into ref, and it will return which variable type the reference points to.&lt;/p&gt;

&lt;h3 id=&#34;creating-references-from-variables:6a29add5aea08a862cc77cb68480c39b&#34;&gt;Creating references from variables&lt;/h3&gt;

&lt;p&gt;To create a reference to an existing variable, use the backslash operator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $array_ref   = \@array;
my $hash_ref    = \%hash;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The backslash operator often comes into play when working within a subroutine. For instance consider these three subs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# example 1 - processor &amp;amp; memory inefficient
sub return_array {
    my @array = (1, 2, 3);
    foreach my $element (@array) {
        calculate($element);
    }
    return @array;
}

# example 2 - processor inefficient
sub return_array {
    my $array = [1, 2, 3];
    foreach my $element (@$array) {
        calculate($element);
    }
    return $array;
}

# example 3 - best option
sub return_array {
    my @array = (1, 2, 3);
    foreach my $element (@array) {
        calculate($element);
    }
    return \@array;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of these subs are trying to do the same thing - declare an array, loop through it and then return it. Example 1 will return a list of the the array&amp;rsquo;s elements. This is inefficient as the list comprises of scalar copies of the original array&amp;rsquo;s elements, which means: Perl makes the copies, returns them and then throws away the original array when it goes out of scope.&lt;/p&gt;

&lt;p&gt;Example 2&amp;rsquo;s main drawback is that by starting with a reference, Perl has to dereference the array in order to loop though it, which is a waste of processing. Example 3 has none of these disadvantages, as it begins with an array, loops through it and then returns a reference to the array. This is a popular Perl programming pattern.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:6a29add5aea08a862cc77cb68480c39b&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;If references were a mystery to you before, hopefully this article helps to kickstart you into using them with confidence. Are you thirsty for more references? There&amp;rsquo;s a lot more to them than described here. Check out Perl&amp;rsquo;s official documentation, perldoc which has a &lt;a href=&#34;http://perldoc.perl.org/perlreftut.html&#34;&gt;tutorial&lt;/a&gt; and more &lt;a href=&#34;http://perldoc.perl.org/perlref.html&#34;&gt;detailed guide&lt;/a&gt;. &lt;a href=&#34;http://www.amazon.com/gp/product/1449393098/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=1449393098&amp;amp;linkCode=as2&amp;amp;tag=perltrickscom-20&#34;&gt;Intermediate Perl&lt;/a&gt; is fantastic book that has over 100 pages on references (affiliate link).&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F80%2F2014%2F3%2F27%2FPerl-references-create-dereference-and-debug-with-confidence&amp;amp;text=Perl+references%3A+create%2C+dereference+and+debug+with+confidence&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F80%2F2014%2F3%2F27%2FPerl-references-create-dereference-and-debug-with-confidence&amp;amp;via=perltricks&#34;&gt;retweet&lt;/a&gt; it!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to read a string into an array of characters using split</title>
      <link>https://dnmfarrell.github.io/article/42/2013/10/3/How-to-read-a-string-into-an-array-of-characters-using-split/</link>
      <pubDate>Thu, 03 Oct 2013 00:42:18 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/42/2013/10/3/How-to-read-a-string-into-an-array-of-characters-using-split/</guid>
      <description>&lt;p&gt;Perl&amp;rsquo;s split function has a useful feature that will split a string into characters. This works by supplying an empty regex pattern (&amp;ldquo;//&amp;rdquo;) to the split function. This can be used to easily split a word into an array of letters, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $word = &#39;camel&#39;;
my @letters = split(//, $word);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl&amp;rsquo;s official documentation has more on the split function. You can read it &lt;a href=&#34;http://perldoc.perl.org/functions/split.html&#34;&gt;online&lt;/a&gt; or by running the following command at the terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;perldoc -f split
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Perl for loops</title>
      <link>https://dnmfarrell.github.io/article/17/2013/4/12/Perl-for-loops/</link>
      <pubDate>Fri, 12 Apr 2013 10:03:44 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/17/2013/4/12/Perl-for-loops/</guid>
      <description>

&lt;p&gt;Perl&amp;rsquo;s for loops are a powerful feature that, like the rest of Perl can be as concise, flexible and versatile required. This article covers the core features for Perl&amp;rsquo;s for loops.&lt;/p&gt;

&lt;h3 id=&#34;c-style-for-loops:cec02722abe304de2cce1d85500b5003&#34;&gt;C-style for loops&lt;/h3&gt;

&lt;p&gt;The C-style for loop follows programming tradition and requires three parameters (count; logical test; count modifier). It looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
# print numbers 0 to 9
for (my $i = 0; $i &amp;lt; 10; $i++) {
    say $i;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s review the code above. First of all we import the feature &amp;lsquo;say&amp;rsquo; which works like the print command except that it appends a newline to the printed string. Before the loop begins, Perl initialises the scalar variable $i as zero. Perl will then check the logical condition ($i &amp;lt; 10). If the condition is true, Perl will execute all the code between the braces { } once. Perl will also increment $i by 1 because the count modifier condition is set to $i++. Having finished one iteration, Perl will then check the logical condition again. After one iteration, $i is equal to 1, so Perl will loop through the code again. This will continue until $i is equal to 10 and the logical condition returns false, at which point Perl will then move on to process any code below the loop. The loop above used an increment modifier ($i++), however it can decrement as well:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
# print numbers 10 to 1
for (my $i = 10; $i &amp;gt; 0; $i--) {
    say $i;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact we can use any modifier we choose, for example to print only odd numbers, we can use Perl&amp;rsquo;s add-to operator $i += 2 which is a shortcut for ($i = $i + 2).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
# print only odd numbers 1 - 9
for (my $i = 1; $i &amp;lt; 10; $i += 2) {
    say $i;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The C-style for loop can be used to access elements of an array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
my @weather_elements = (&#39;wind&#39;, &#39;rain&#39;, &#39;snow&#39;, &#39;cloud&#39;, &#39;sunshine&#39;);
for (my $i = 0; $i &amp;lt; @weather_elements; $i++) {
    say $weather_elements[$i];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the count is started at zero because Perl array indexes are zero-based, and the array is used as one-side of the logical condition ($i &amp;lt; @weather_elements) because in this context Perl will helpfully return the length of the array (5).&lt;/p&gt;

&lt;h3 id=&#34;for-loops-with-arrays:cec02722abe304de2cce1d85500b5003&#34;&gt;for loops with arrays&lt;/h3&gt;

&lt;p&gt;There are simpler ways than using the C-style for loop to iterate through every element of an array in Perl. If an array is passed to a for loop, it will iterate through every element of the array until it reaches the end. For example this is the same loop as above, written using the array technique:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
my @weather_elements = (&#39;wind&#39;, &#39;rain&#39;, &#39;snow&#39;, &#39;cloud&#39;, &#39;sunshine&#39;);
for my $weather_element (@weather_elements) {
    say $weather_element;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above Perl iterates through the array, assigning the value of the current element to $weather_element. Once the loop finishes $weather_element goes out of scope and will be garbage collected.&lt;/p&gt;

&lt;p&gt;We can simplify this code further. If no scalar variable is included in the argument, Perl will use $_ as the temporary variable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
my @weather_elements = (&#39;wind&#39;, &#39;rain&#39;, &#39;snow&#39;, &#39;cloud&#39;, &#39;sunshine&#39;);
for (@weather_elements) {
    say $_;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of using &amp;lsquo;for&amp;rsquo;, some Perl programmers use a &amp;lsquo;foreach&amp;rsquo; loop, although in Perl &amp;lsquo;for&amp;rsquo; and &amp;lsquo;foreach&amp;rsquo; are synonyms and can be used interchangeably. I like &amp;lsquo;foreach&amp;rsquo; because it clarifies the programmer&amp;rsquo;s intentions. For example this code will do the same thing as the previous code example above:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
my @weather_elements = (&#39;wind&#39;, &#39;rain&#39;, &#39;snow&#39;, &#39;cloud&#39;, &#39;sunshine&#39;);
foreach (@weather_elements) {
    say $_;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The for / foreach loop also accepts a list instead of an array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
foreach (&#39;wind&#39;, &#39;rain&#39;, &#39;snow&#39;, &#39;cloud&#39;, &#39;sunshine&#39;) {
    say $_;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;for-loops-with-ranges:cec02722abe304de2cce1d85500b5003&#34;&gt;for loops with ranges&lt;/h3&gt;

&lt;p&gt;Sometimes you just need Perl to &amp;lsquo;do something n number of times&amp;rsquo;. A quick way to do this is using a range i..n. For example, if we wanted to print 6 random lottery numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
for (1..6) {
    say int(rand(58)) + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;for-loop-functions-redo-next-and-last:cec02722abe304de2cce1d85500b5003&#34;&gt;for loop functions: redo, next and last&lt;/h3&gt;

&lt;p&gt;Perl provides several functions which can be used to control the for loop iterations. &lt;strong&gt;redo&lt;/strong&gt; instructs Perl to re-run the current iteration. Let&amp;rsquo;s modify the lottery numbers example above to redo the loop if we generate an unlucky number 13.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;for (1..6) {
    my $number = int(rand(58)) + 1;
    redo if $number == 13;
    say $number;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above, if a number 13 is generated, the redo function will restart the iteration and the code will never reach the say $number statement.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;next&lt;/strong&gt; function stops the current iteration and moves to the next iteration. This can be useful when we have additional processing that we want to be done only for certain elements. For example if we were surveying a group of people about their education, it only makes sense to ask what school the person attended, if they have a degree:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
for (1..5){
        print &amp;quot;Please type your name and press enter: &amp;quot;;
        my $name = &amp;lt;&amp;gt;;
        say $name;
        print &amp;quot;Do you have a bachelors degree? (y/n) &amp;quot;;
        my $degree_flag = &amp;lt;&amp;gt;;
        say $degree_flag;
        chomp $degree_flag;
        next if $degree_flag eq &#39;n&#39;;
        print &amp;quot;Which school did you get the degree from?&amp;quot;;
        my $school = &amp;lt;&amp;gt;;
        say $school;
        # continues ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;strong&gt;last&lt;/strong&gt; function allows the current iteration to finish and then exits loop entirely. This is often used when doing pattern matching as once a match has been found, there is no need to check other possibilities:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $variable_type = &#39;$scalar&#39;;
my @perlvariable_regexes = (&#39;^\$&#39;, &#39;^@&#39;, &#39;^%&#39;);
foreach (@perlvariable_regexes ){
    if ($variable_type =~ m/$_/) {
        say &amp;quot;match found with $_&amp;quot;;
        last;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For further detail on Perl&amp;rsquo;s for loops, check out the &lt;a href=&#34;http://perldoc.perl.org/perlsyn.html#For-Loops&#34;&gt;official Perl documentation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>List shortcuts: qw the quote whitespace operator</title>
      <link>https://dnmfarrell.github.io/article/15/2013/4/9/List-shortcuts--qw-the-quote-whitespace-operator/</link>
      <pubDate>Tue, 09 Apr 2013 00:02:11 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/15/2013/4/9/List-shortcuts--qw-the-quote-whitespace-operator/</guid>
      <description>&lt;p&gt;A popular way to build a list of literal quotes in Perl is to use the quote whitespace operator (qw). It&amp;rsquo;s terse, versatile and elegant. To see why, let&amp;rsquo;s look at a typical statement using a list of strings:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# import the Encode module and three subroutines
use Encode (&#39;decode&#39;, &#39;encode&#39;, &#39;find_encoding&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To define the list of strings in Perl we had to encase every string with apostrophes, separated by commas and surrounded by parentheses. That&amp;rsquo;s a lot of fluff, and opens the door to easy mistakes such as using speechmarks (&amp;ldquo;) when you needed an apostrophe. Instead of doing that, we could have used the quote whitespace operator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Encode qw/decode encode find_encoding/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The quote whitespace operator takes a list delimiter followed by a list of plain strings separated by whitespace and returns list of literal quoted strings. The delimiter can be an ASCII symbol (slash / is a popular choice), brackets or parentheses. Let&amp;rsquo;s review some more examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# assign a list of an array
my @ny_boroughs = qw{Bronx Brooklyn Manhattan Queens Staten_Island};

# Quote some tricky symbols using tilde as the list delimiter
my @ascii_symbols = qw~! @ $ % ^ &amp;amp; * ( ) - _ = + { } [ ] \ | / ? ~;

# Use qw an input to a loop
foreach my $firm (qw/Deloitte ErnstAndYoung KPMG PWC/){
    print $firm; 
}

# It will ignore spaces, even double or triple spaces
my @colours = qw(red  blue   yellow    pink   green   ); 
foreach (@colours) {
    print $_;
}
# red
# blue
# yellow
# pink
# green
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the quote whitespace operator often results in a cleaner, simpler syntax that reduces the risk of error when working with lists.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl arrays 101 - create, loop and manipulate</title>
      <link>https://dnmfarrell.github.io/article/11/2013/4/4/Perl-arrays-101---create--loop-and-manipulate/</link>
      <pubDate>Thu, 04 Apr 2013 20:22:51 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/11/2013/4/4/Perl-arrays-101---create--loop-and-manipulate/</guid>
      <description>

&lt;p&gt;Arrays in Perl contain an ordered list of values that can be accessed using built-in functions. They are one of the most useful data structures and frequently used in Perl programming.&lt;/p&gt;

&lt;h3 id=&#34;creating-an-array:0fc1cff51f8e8b6779283bd677e343f0&#34;&gt;Creating an array&lt;/h3&gt;

&lt;p&gt;In Perl variables are identified using sigils. Arrays use @ (as in &amp;lsquo;a&amp;rsquo; for array), so the format is: @any_name_you_choose_here. Arrays are initialised by assigning a list of values (comma separated values between parentheses). Unlike more formal languages, Perl arrays can contain a mix of numbers, strings, objects and references.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @empty_array;

my @another_empty_array = ();

my @numbers = (1, 2, 3, 4, 5);

my @names_start_with_j = (&#39;John&#39;, &#39;Judy&#39;, &#39;Julia&#39;, &#39;James&#39;, &#39;Jennifer&#39;);

my @random_collection = (2013, &#39;keyboard&#39;, &#39;perltricks.com&#39;, 30);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;finding-the-array-length-size:0fc1cff51f8e8b6779283bd677e343f0&#34;&gt;Finding the array length / size&lt;/h3&gt;

&lt;p&gt;The length of an array (aka the &amp;lsquo;size&amp;rsquo;) is the count of the number of elements in the array. To find the array length, use the array in a scalar context:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @numbers = (1, 2, 3, 4, 5);
my $array_length = @numbers; 
print $array_length;
# 5
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;accessing-array-elements-directly:0fc1cff51f8e8b6779283bd677e343f0&#34;&gt;Accessing array elements directly&lt;/h3&gt;

&lt;p&gt;Arrays can be accessed in a variety of ways: by directly accessing an element, slicing a group of elements or looping through the entire array, accessing one element at a time.&lt;/p&gt;

&lt;p&gt;When directly accessing an array element, use the array name prefaced with the scalar sigil ($) instead of (@) and the index number of the element enclosed in square brackets. Arrays are zero-based, which means that the first element&amp;rsquo;s index number is 0 (not 1!).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @names_start_with_j = (&#39;John&#39;, &#39;Judy&#39;, &#39;Julia&#39;, &#39;James&#39;, &#39;Jennifer&#39;);
$names_start_with_j[0]; # John
$names_start_with_j[4]; # Jennifer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The implication of zero-based indexing is that the index number of the last element in an array is equal to the length of the array minus one.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @numbers = (11, 64, 29, 22, 100);
my $numbers_array_length = @numbers;
my $last_element_index = numbers_array_length - 1;
# therefore ...
print $numbers[$last_element_index]; 
# 100
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For simpler ways to access the last element of an array - see our &lt;a href=&#34;http://perltricks.com/article/6/2013/3/28/Find-the-index-of-the-last-element-in-an-array&#34;&gt;recent article&lt;/a&gt; for examples.&lt;/p&gt;

&lt;h3 id=&#34;loop-through-an-array-with-foreach:0fc1cff51f8e8b6779283bd677e343f0&#34;&gt;Loop through an array with foreach&lt;/h3&gt;

&lt;p&gt;Arrays elements can be accessed sequentially using a foreach loop to iterate through the array one element at a time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @names_start_with_j = (&#39;John&#39;, &#39;Judy&#39;, &#39;Julia&#39;, &#39;James&#39;, &#39;Jennifer&#39;);
foreach my $element (@names_start_with_j) {
    print &amp;quot;$element\n&amp;quot;;
}
# John
# Judy
# Julia
# James
# Jennifer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other common functions for looping through arrays are &lt;a href=&#34;http://perldoc.perl.org/functions/grep.html&#34;&gt;grep&lt;/a&gt; and &lt;a href=&#34;http://perldoc.perl.org/functions/map.html&#34;&gt;map&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;shift-unshift-push-and-pop:0fc1cff51f8e8b6779283bd677e343f0&#34;&gt;shift, unshift, push and pop&lt;/h3&gt;

&lt;p&gt;Perl arrays are dynamic in length, which means that elements can be added to and removed from the array as required. Perl provides four functions for this: shift, unshift, push and pop.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;shift&lt;/strong&gt; removes and returns the first element from the array, reducing the array length by 1.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @compass_points = (&#39;north&#39;, &#39;east&#39;, &#39;south&#39;, &#39;west&#39;);
my $direction = shift @compass_points;
print $direction; 
# north
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If no array is passed to shift, it will operate on @_. This makes it useful in subroutines and methods where by default @_ contains the arguments from the subroutine / method call. E.G.:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;print_caller(&amp;quot;perltricks&amp;quot;);
sub print_caller {
    my $caller_name = shift;
    print $caller_name;
}
# perltricks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other three array functions work similarly to shift. &lt;strong&gt;unshift&lt;/strong&gt; receives and inserts a new element into the front of the array increasing the array length by 1.&lt;strong&gt;push&lt;/strong&gt; receives and inserts a new element to the end of the array, increasing the array length by 1. &lt;strong&gt;pop&lt;/strong&gt; removes and returns the last element in the array, reducing the array length by 1.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @compass_points = (&#39;north&#39;, &#39;east&#39;, &#39;south&#39;, &#39;west&#39;);
my $direction = &#39;north-east&#39;;
unshift @compass_points, $direction;
# @compass_points contains: north-east, north, east, south and west

my $west = pop @compass; 
push @compass, $new_direction; # put $west back
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;check-an-array-is-null-or-undefined:0fc1cff51f8e8b6779283bd677e343f0&#34;&gt;Check an array is null or undefined&lt;/h3&gt;

&lt;p&gt;A simple way to check if an array is null or defined is to examine it in a scalar context to obtain the number of elements in the array. If the array is empty, it will return 0, which Perl will also evaluate as boolean false. Bear in mind that this is not quite the same thing as undefined, as it is possible to have an empty array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @empty_array;
if (@empty_array) {
    # do something - will not be reached if the array has 0 elements
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Upgrade your list printing using field separator variables</title>
      <link>https://dnmfarrell.github.io/article/12/2013/4/3/Upgrade-your-list-printing-using-field-separator-variables/</link>
      <pubDate>Wed, 03 Apr 2013 22:24:28 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/12/2013/4/3/Upgrade-your-list-printing-using-field-separator-variables/</guid>
      <description>&lt;p&gt;A typical way to print every element of an array in Perl is using a foreach loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @sportscar_brands = qw/Ferrari Aston_Martin Lambourgini/;
foreach my $brand (@sportscar_brands){
    print &amp;quot;$brand\n&amp;quot;;
}
# Ferrari
# Aston_Martin
# Lambourgini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An alternative method is to set value of the the output field separator variable ($,). When printing a list or array Perl injects this variable between elements. Hence, if you set the output field separator to a newline (\n) you will achieve the same affect as the previous example, without the foreach loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$, = &amp;quot;\n&amp;quot;; # set the output field separator to newline
my @sportscar_brands = qw/Ferrari Aston_Martin Lambourgini/;
print @sportscar_brands;
# Ferrari
# Aston_Martin
# Lambourgini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output field separator also works on lists:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$, = &amp;quot;\n&amp;quot;;
print qw/Ferrari Aston_Martin Lambourgini/;
# Ferrari
# Aston_Martin
# Lambourgini
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is another variable called the list separator ($&amp;ldquo;). Perl injects the value of $&amp;rdquo; between the elements of an array in an interpolated string. The subtle difference here is that the output field separator will apply when using print, however the list separator applies to all arrays in an interpolated string context. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$&amp;quot; = &amp;quot;\n&amp;quot;; # set the list separator to newline
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my @normalcar_brands = qw/Ford Honda Toyota Fiat/;
print @normalcar_brands; # not inside an interpolated string
# FordHondaToyotaFiat

print &amp;quot;@normalcar_brands&amp;quot; # works in interpolated string
# Ford
# Honda
# Toyota
# Fiat

my $separated_list_string = &amp;quot;@normalcar_brands&amp;quot;; # injects the separator
print $separated_list_string;
# Ford
# Honda
# Toyota
# Fiat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One additional difference: despite its name, the list separator variable ($&amp;ldquo;) does not work on lists whilst the output field separator ($,) does (in Perl 5.16.3).&lt;/p&gt;

&lt;p&gt;Finally if you have set both $, and $&amp;rdquo; and print an interpolated array, $&amp;rdquo; will be injected and $, will be ignored.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Find the index of the last element in an array</title>
      <link>https://dnmfarrell.github.io/article/6/2013/3/28/Find-the-index-of-the-last-element-in-an-array/</link>
      <pubDate>Thu, 28 Mar 2013 23:30:33 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/6/2013/3/28/Find-the-index-of-the-last-element-in-an-array/</guid>
      <description>

&lt;p&gt;Most Perl programmers know that to find the size of an array, the array must called in a scalar context like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# Declare the array
my @numbers_array = (41,67,13,9,62); 
# Get the array size
my $size_of_array = @numbers_array;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This understanding can lead to programmers applying a scalar context to an array to access its last element (subtracting 1 because arrays are zero-based).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;print $numbers_array[@numbers_array - 1];
# 62
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-last-index-variable:65383929869db9a593a341e187dc3897&#34;&gt;The last-index variable&lt;/h3&gt;

&lt;p&gt;Perl has a &amp;lsquo;last-index&amp;rsquo; variable for arrays ($#array_name).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;print $#numbers_array; 
# 5
print $numbers_array[$#numbers_array]; 
# 62
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last index operator ($#array_name) also works on arrayrefs if you insert an extra dollar sigil:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $arrayref = [41, 67, 13, 9, 62];
print $#$arrayref;
# 5
print $$arrayref[$#$arrayref]; 
# 62 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;negative-indexing:65383929869db9a593a341e187dc3897&#34;&gt;Negative indexing&lt;/h3&gt;

&lt;p&gt;Perl provides a shorter syntax for accessing the last element of an array: negative indexing. Negative indices track the array from the end, so -1 refers to the last element, -2 the second to last element and so on.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# Declare the array
my @cakes = qw(victoria_sponge chocolate_gateau carrot);
print $cakes[-1]; # carrot
print $cakes[-2]; # chocolate_gateau
print $cakes[-3]; # victoria_sponge
print $cakes[0];  # victoria_sponge
print $cakes[1];  # chocolate_gateau
print $cakes[2];  # carrot
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>

