<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Perl6 on Perl programming news, code and culture</title>
    <link>https://dnmfarrell.github.io/tags/perl6/</link>
    <description>Recent content in Perl6 on Perl programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Sep 2015 22:16:48 +0000</lastBuildDate>
    <atom:link href="https://dnmfarrell.github.io/tags/perl6/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Activating Perl 6 syntax highlighting in Vim</title>
      <link>https://dnmfarrell.github.io/article/194/2015/9/22/Activating-Perl-6-syntax-highlighting-in-Vim/</link>
      <pubDate>Tue, 22 Sep 2015 22:16:48 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/194/2015/9/22/Activating-Perl-6-syntax-highlighting-in-Vim/</guid>
      <description>

&lt;p&gt;Modern versions of the Vim text editor ship with Perl 6 syntax highlighting, but automatically activating it is tricky because Perl 6 files can have ambiguous file extensions. It can get tiresome to correct the file type every time you open a Perl 6 file, so I&amp;rsquo;m going to show you a few tricks that I use to make Vim detect Perl 6 files automatically.&lt;/p&gt;

&lt;h3 id=&#34;showing-and-setting-the-filetype-in-vim:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Showing and setting the filetype in Vim&lt;/h3&gt;

&lt;p&gt;First of all I want to make sure that syntax highlighting is turned on by default, so I add this option to my &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;syntax on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To edit your &lt;code&gt;.vimrc&lt;/code&gt; just start Vim and enter this command &lt;code&gt;:e $MYVIMRC&lt;/code&gt;. Save your changes with &lt;code&gt;:w&lt;/code&gt;, and then reload your &lt;code&gt;.vimrc&lt;/code&gt; with &lt;code&gt;:so %&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now that I have syntax highlighting turned on, I need to know how set Vim&amp;rsquo;s file type to Perl 6 when I&amp;rsquo;m working with Perl 6 files. I can see the current file type by typing this command &lt;code&gt;:set filetype?&lt;/code&gt;. To set the file type to Perl 6, I use this command &lt;code&gt;:set filetype=perl6&lt;/code&gt;. The &lt;code&gt;filetype&lt;/code&gt; keyword can be shortened to &lt;code&gt;ft&lt;/code&gt;. In which case the last command becomes &lt;code&gt;:set ft=perl6&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;detecting-perl-6-files:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Detecting Perl 6 files&lt;/h3&gt;

&lt;p&gt;Now the challenge becomes correctly detecting when I&amp;rsquo;m working with Perl 6 files in Vim. Perl 6 scripts shouldn&amp;rsquo;t be a problem: Vim (not Vi) automatically parses the &lt;a href=&#34;https://en.wikipedia.org/wiki/Shebang_line&#34;&gt;shebang&lt;/a&gt; line to determine the file type. However this fails when the script has an extension like &lt;code&gt;.pl&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;use-the-pm6-file-extension:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Use the .pm6 file extension&lt;/h4&gt;

&lt;p&gt;Vim will automatically use Perl 6 syntax highlighting if the file extension is &lt;code&gt;.pm6&lt;/code&gt;. So when working with Perl 6 module files, it&amp;rsquo;s better to use this extension. This doesn&amp;rsquo;t help when I&amp;rsquo;m working on other people&amp;rsquo;s Perl 6 projects however. It also doesn&amp;rsquo;t help for test files, which do not have an equivalent Perl 6 file extension (&lt;code&gt;.t6&lt;/code&gt; test files are ignored when installing Perl 6 modules).&lt;/p&gt;

&lt;h4 id=&#34;use-a-modeline:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Use a modeline&lt;/h4&gt;

&lt;p&gt;A modeline is a line of code in the text of the file which Vim reads and executes. So to activate Perl 6 syntax highlighting I just need to add this modeline to every Perl 6 file I work with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# vim: filetype=perl6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Take a look at the &lt;a href=&#34;https://github.com/Mouq/json5/blob/master/lib/JSON5/Tiny.pm6#L54&#34;&gt;source code&lt;/a&gt; of JSON5::Tiny for a real-World example. To Perl 6 this code looks just like an ordinary comment, but Vim will use it to turn on Perl 6 syntax highlighting. The modeline can appear anywhere in the code, but it&amp;rsquo;s better to place it at the start or end of the file.&lt;/p&gt;

&lt;p&gt;Older versions of Vim (pre 7.3) and when Vim is run under root privileges, disable modelines as a security risk. Don&amp;rsquo;t run Vim as root! But if you have an older Vim, you can turn on modelines with &lt;code&gt;:set modeline&lt;/code&gt;. As with &lt;code&gt;filetype&lt;/code&gt;, modeline can be abbreviated to &lt;code&gt;ml&lt;/code&gt;, so &lt;code&gt;set ml&lt;/code&gt; works too. To activate modelines automatically, add this line to your &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set ml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The downside of using modelines? First there is aforementioned security risk for older Vims. Also it feels impure to add editor directives to the code I&amp;rsquo;m working with, as not everyone uses Vim. These seem like minor issues though.&lt;/p&gt;

&lt;h4 id=&#34;use-a-local-vimrc:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Use a local vimrc&lt;/h4&gt;

&lt;p&gt;Often different Open Source projects will have different coding conventions that I need to follow, so it can be helpful to use a local vimrc file to store these project-specific settings. This works for syntax highlighting too. In order to use local vimrc files, I add the following code to my &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if filereadable(&amp;quot;.vimrc.local&amp;quot;)
  so .vimrc.local
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will check the current working directory for &lt;code&gt;.vimrc.local&lt;/code&gt; file, and automatically execute it if it finds it. &lt;strong&gt;Warning&lt;/strong&gt; this is a security risk - Vim will execute ANY instruction in a local vimrc, so I am very careful when working with projects that are not my own. Next I create a &lt;code&gt;.vimrc.local&lt;/code&gt; file in the root project directory and add this auto command to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;au Bufnewfile,bufRead *.pm,*.t,*.pl set filetype=perl6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when I open or create any file with a Perl extension, Vim will set the syntax highlighting to Perl 6. I like this technique because it&amp;rsquo;s not intrusive: it doesn&amp;rsquo;t require any changes to the Perl 6 files themselves, so it works well on shared projects (I never check-in my local vimrc to the Git repo).&lt;/p&gt;

&lt;h4 id=&#34;use-code-detection:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Use code detection&lt;/h4&gt;

&lt;p&gt;I can also have Vim try to detect Perl 6 code automatically. Two directives which would indicate we&amp;rsquo;re working with Perl 6 instead of Perl 5 code: the shebang line and the &lt;code&gt;use v6;&lt;/code&gt; directive. To check for these, I&amp;rsquo;ll add a function to my .vimrc:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function! LooksLikePerl6 ()
  if getline(1) =~# &#39;^#!.*/bin/.*perl6&#39;
    set filetype=perl6
  else
    for i in [1,2,3,4,5]
      if getline(i) == &#39;use v6;&#39;
        set filetype=perl6
        break
      endif
    endfor
  endif
endfunction

au bufRead *.pm,*.t,*.pl call LooksLikePerl6()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function uses &lt;code&gt;getline()&lt;/code&gt; to check the first line of the file to see if it looks like a Perl 6 shebang. This should work well for &lt;code&gt;.pl&lt;/code&gt; scripts, but Perl 6 module files will not have a shebang, so the next part of the script checks the first 5 lines of the file for the &lt;code&gt;use v6;&lt;/code&gt; directive. The last line of code is an auto command which will call the function anytime we open file with a Perl file extension.&lt;/p&gt;

&lt;p&gt;The main drawback of this technique is that not all Perl 6 code uses the &lt;code&gt;use v6;&lt;/code&gt; directive, and so when working with module files, the code detection can fail. However the code detection could be improved to use more rules for detecting Perl 6 code such as class declarations. The &lt;a href=&#34;https://github.com/vim-perl/vim-perl&#34;&gt;vim-perl&lt;/a&gt; plugin has more sophisticated Perl 6 code detection &lt;a href=&#34;https://github.com/vim-perl/vim-perl/blob/master/ftdetect/perl11.vim&#34;&gt;rules&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;complete-vimrc:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Complete .vimrc&lt;/h3&gt;

&lt;p&gt;This &lt;code&gt;.vimrc&lt;/code&gt; contains all the code shown above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;syntax on

&amp;quot;Recognize modeline # vim: filetype=perl6
set ml

&amp;quot;check for a local vimrc
if filereadable(&amp;quot;.vimrc.local&amp;quot;)
  so .vimrc.local
endif

&amp;quot;check for Perl 6 code
function! LooksLikePerl6 ()
  if getline(1) =~# &#39;^#!.*/bin/.*perl6&#39;
    set filetype=perl6
  else
    for i in [1,2,3,4,5]
      if getline(i) == &#39;use v6;&#39;
        set filetype=perl6
        break
      endif
    endfor
  endif
endfunction

au bufRead *.pm,*.t,*.pl call LooksLikePerl6()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion:2b44acefc7661ab01fd1d69f1b86a6cb&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;So that&amp;rsquo;s it, four useful-but-imperfect techniques for detecting file types in Vim. I tend to use a combination of all four. This would be a nice problem not to have. I&amp;rsquo;d like the Perl 6 community to agree and encourage unambiguous file extensions like &lt;code&gt;.pm6&lt;/code&gt;, &lt;code&gt;.t6&lt;/code&gt; and &lt;code&gt;.pl6&lt;/code&gt;. Larry Wall called this &amp;ldquo;free advertising&amp;rdquo;. It&amp;rsquo;s also a simple way to make Perl 6 programmers more productive. Not every text editor is as customizable as Vim.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Get to grips with Prove, Perl&#39;s test workhorse</title>
      <link>https://dnmfarrell.github.io/article/177/2015/6/9/Get-to-grips-with-Prove--Perl-s-test-workhorse/</link>
      <pubDate>Tue, 09 Jun 2015 12:59:02 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/177/2015/6/9/Get-to-grips-with-Prove--Perl-s-test-workhorse/</guid>
      <description>

&lt;p&gt;Prove is a test running tool that ships with Perl. It has a ton of options, which can make it confusing for a beginner to use. If you have never used prove, or are not confident using it, do not despair! This article will get you up to speed with prove and it&amp;rsquo;s most common options.&lt;/p&gt;

&lt;h3 id=&#34;basics:21cbf2b2f91d9b431c49ffbcae20ce43&#34;&gt;Basics&lt;/h3&gt;

&lt;p&gt;If you have Perl installed, you should already have Prove installed as well. To demo the features of Prove, I&amp;rsquo;m going to clone the Mojolicious repo using Git. I like demoing Prove with Mojolicious as it has a large test suite. At the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ git clone https://github.com/kraih/mojo
$ cd mojo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So I&amp;rsquo;ve cloned the Mojolicious repo and changed into the project directory. Now I&amp;rsquo;m ready to run some tests with Prove!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ prove -l t/mojo/asset.t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I executed Prove using the &lt;code&gt;prove&lt;/code&gt; command. I included the &lt;code&gt;-l&lt;/code&gt; option so that Prove would load the Mojolicious code beneath the &lt;code&gt;lib&lt;/code&gt; directory. If I didn&amp;rsquo;t do this, Perl would not find the Mojolicious code referenced in &lt;code&gt;t/mojo/asset.t&lt;/code&gt; and raise an error, or perhaps worse, it might run the tests against an older version of Mojolicious I already had installed on my system.&lt;/p&gt;

&lt;p&gt;Sometimes the code to include is not directly in the &lt;code&gt;lib&lt;/code&gt; directory. For these cases Prove has the &lt;code&gt;-I&lt;/code&gt; option for &amp;ldquo;include&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;prove -I/path/to/lib /path/to/test_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prove can run a single test file, or if given a directory containing multiple test files, with will execute them all:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ prove -l t/mojo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This runs all the test files in &lt;code&gt;t/mojo&lt;/code&gt; directory.&lt;/p&gt;

&lt;h3 id=&#34;recursively-execute-test-files-with-r:21cbf2b2f91d9b431c49ffbcae20ce43&#34;&gt;Recursively execute test files with &amp;ldquo;r&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;The Mojolicious project has test files in several different directories beneath the &lt;code&gt;t&lt;/code&gt; directory. It would be tiresome to locate all of these directory paths and give them to Prove. Instead, Prove provides the &lt;code&gt;-r&lt;/code&gt; option to recursively search for test files.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ prove -lr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This option executed every test file under the &lt;code&gt;t&lt;/code&gt; directory, about 10,000 tests across 85 different files. Pretty convenient huh? Note that I didn&amp;rsquo;t provide the &lt;code&gt;t&lt;/code&gt; directory as an argument, because Prove searches the &lt;code&gt;t&lt;/code&gt; directory by default. Now that&amp;rsquo;s convenience!&lt;/p&gt;

&lt;h3 id=&#34;run-tests-in-parallel-using-j:21cbf2b2f91d9b431c49ffbcae20ce43&#34;&gt;Run tests in parallel using &amp;ldquo;j&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;The ability to run lots of test files is useful, but it can take a long time to run all of the tests. On my machine, executing the Mojolicious test suite takes 32 seconds. To speed things up, Prove can run test files in parallel, to share the work across multiple processes. To do this I just add the &lt;code&gt;-j&lt;/code&gt; option plus the number of processes I want to use. I have a quad core machine, so I&amp;rsquo;m going to use 4 different processes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ prove -lr -j 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This time, prove executed all the tests in 12 seconds. That&amp;rsquo;s a 266% speed-up, not bad!&lt;/p&gt;

&lt;h3 id=&#34;get-more-detail-with-v-for-verbose:21cbf2b2f91d9b431c49ffbcae20ce43&#34;&gt;Get more detail with &amp;ldquo;v&amp;rdquo; for verbose&lt;/h3&gt;

&lt;p&gt;To minimize line noise, by default Prove provides summary-level statistics and low-level detail for test failures. Sometimes it&amp;rsquo;s useful to see the output for each test. I can see this detail by adding the &lt;code&gt;-v&lt;/code&gt; option for &amp;ldquo;verbose&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ prove -lrv
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;running-perl-6-tests:21cbf2b2f91d9b431c49ffbcae20ce43&#34;&gt;Running Perl 6 tests&lt;/h3&gt;

&lt;p&gt;Prove can run tests for other languages, as long as the tests follow the Test Anything Protocol. Perl 6 unit tests follow TAP, so we can use Prove to run Perl 6 tests too! I can demo this on my Perl 6 module, &lt;a href=&#34;https://github.com/dnmfarrell/URI-Encode&#34;&gt;URI::Encode&lt;/a&gt;. To follow along, just clone the repo with Git:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ git clone https://github.com/dnmfarrell/URI-Encode
$ cd URI-Encode
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run non Perl tests with Prove, we need to pass the &lt;code&gt;--exec&lt;/code&gt; option, with a program name. That tells Prove which program to execute the tests with. Like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ prove --exec perl6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I didn&amp;rsquo;t have to pass the filepath of which tests to run. It&amp;rsquo;s just lucky that by convention Perl6 modules have their tests in the &lt;code&gt;t&lt;/code&gt; directory, usually with a &lt;code&gt;.t&lt;/code&gt; extension. For other languages, you&amp;rsquo;ll need to specify the test filepath:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ prove --exec some_program /path/to/testfile
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;documentation:21cbf2b2f91d9b431c49ffbcae20ce43&#34;&gt;Documentation&lt;/h3&gt;

&lt;p&gt;You can get a summary of the options Prove accepts by using the &lt;code&gt;-h&lt;/code&gt; option for help:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ prove -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more detailed documentation, use &lt;code&gt;perldoc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perldoc prove
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perldoc is another useful Perl tool, if you&amp;rsquo;d like to know more about it, have a look at our introductory &lt;a href=&#34;http://perltricks.com/article/155/2015/2/26/Hello-perldoc--productivity-booster&#34;&gt;article&lt;/a&gt;. Prove also has a man page entry (if you&amp;rsquo;re on Unix/BSD based systems).&lt;/p&gt;

&lt;h3 id=&#34;prove-cheat-sheet:21cbf2b2f91d9b431c49ffbcae20ce43&#34;&gt;Prove Cheat sheet&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;prove [options] [filepath]

Options
-------
l       Include the &amp;quot;lib&amp;quot; dir
I       Include a dir: -I/path/to/lib
r       Recursively search and run test files
j       Parallel, specify # procs: -j 4
v       Verbose test output
h       Help, summary of options
exec    Exec tests in another program: --exec perl6
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Parsing Perl 5 pod with Perl 6</title>
      <link>https://dnmfarrell.github.io/article/170/2015/4/30/Parsing-Perl-5-pod-with-Perl-6/</link>
      <pubDate>Thu, 30 Apr 2015 13:14:23 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/170/2015/4/30/Parsing-Perl-5-pod-with-Perl-6/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve just finished developing a Perl 5 pod &lt;a href=&#34;https://github.com/dnmfarrell/Pod-Perl5&#34;&gt;parser&lt;/a&gt; written in Perl 6. Developing the grammar was surprisingly easy, which is a testament to Perl 6 as I&amp;rsquo;m no genius coder. With help from the folks at #perl6, I did learn some interesting things along the way, and wanted to share them. Plus, code!&lt;/p&gt;

&lt;p&gt;By the way, if you haven&amp;rsquo;t read my &lt;a href=&#34;http://perltricks.com/article/144/2015/1/13/How-to-create-a-grammar-in-Perl-6&#34;&gt;introduction&lt;/a&gt; to Perl 6 grammars, check it out first, and the rest of this article should make more sense.&lt;/p&gt;

&lt;h3 id=&#34;developing-the-grammar:78d208860f81988c9597decb37b0b553&#34;&gt;Developing the grammar&lt;/h3&gt;

&lt;p&gt;In Perl 6 a grammar is a special type of class for parsing text. The idea is to declare a series of regexes using the &lt;code&gt;token&lt;/code&gt; method, which are then used to parse input. For &lt;a href=&#34;https://github.com/dnmfarrell/Pod-Perl5/blob/master/lib/Pod/Perl5/Grammar.pm&#34;&gt;Pod::Perl5::Grammar&lt;/a&gt; I literally worked my way through &lt;a href=&#34;http://perldoc.perl.org/perlpod.html&#34;&gt;perlpod&lt;/a&gt;, the Perl 5 pod specification, writing tokens as I went.&lt;/p&gt;

&lt;p&gt;There were a few challenges. First, consider how would you define a regex for lists? In pod, lists can contain lists, so can a definition include itself? The answer is yes, a recursive definition is fine, as long as it doesn&amp;rsquo;t match a zero length string, which leads to an infinite loop. Here&amp;rsquo;s the definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;token over_back { &amp;lt;over&amp;gt;
                    [
                      &amp;lt;_item&amp;gt; | &amp;lt;paragraph&amp;gt; | &amp;lt;verbatim_paragraph&amp;gt; | &amp;lt;blank_line&amp;gt; |
                      &amp;lt;_for&amp;gt; | &amp;lt;begin_end&amp;gt; | &amp;lt;pod&amp;gt; | &amp;lt;encoding&amp;gt; | &amp;lt;over_back&amp;gt;
                    ]*
                    &amp;lt;back&amp;gt;
                  }

token over      { ^^\=over [\h+ &amp;lt;[0..9]&amp;gt;+ ]? \n }
token _item     { ^^\=item \h+ &amp;lt;name&amp;gt;
                    [
                        [ \h+ &amp;lt;paragraph&amp;gt;  ]
                      | [ \h* \n &amp;lt;blank_line&amp;gt; &amp;lt;paragraph&amp;gt;? ]
                    ]
                  }
token back      { ^^\=back \h* \n }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The token &lt;code&gt;over_back&lt;/code&gt; describes an entire list from start to finish. It basically says that a list must begin with an &lt;code&gt;=over&lt;/code&gt; and end with &lt;code&gt;=back&lt;/code&gt;, and can have a whole bunch of things in between, including another &lt;code&gt;over_back&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;For simplicity&amp;rsquo;s sake, I tried to name the tokens the same as how they&amp;rsquo;re written in pod. In some cases this wasn&amp;rsquo;t possible, for instance &lt;code&gt;item&lt;/code&gt; causes a namespace clash with another method that the Grammar class inherits. So watch out for those cases, you&amp;rsquo;ll get weird errors (this is a &lt;a href=&#34;https://rt.perl.org/rt3//Public/Bug/Display.html?id=77350&#34;&gt;bug&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;This is one pattern I really love and used over and over in the grammar:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;[ &amp;lt;pod_section&amp;gt; | &amp;lt;?!before &amp;lt;pod_section&amp;gt; &amp;gt; .]*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The pattern is useful when you have a pattern to capture, but if there&amp;rsquo;s no matching pattern ignore everything else. In this case, &lt;code&gt;pod_section&lt;/code&gt; is a token that defines a section of pod, but pod is often written inline with Perl code, which the grammar should ignore. So the second half of the definition uses a negative lookahead &lt;code&gt;?!before&lt;/code&gt; to check the next character is not a &lt;code&gt;pod_section&lt;/code&gt;, and uses a period &lt;code&gt;.&lt;/code&gt; to match everything else (including newlines). Both conditions are grouped in square brackets with an asterisk placed &lt;strong&gt;outside&lt;/strong&gt; the group in order to check one character at a time.&lt;/p&gt;

&lt;p&gt;The grammar can be used to parse standalone and inline pod. It will extract every pod section it finds into match object (basically a Perl data structure), ready for processing. It&amp;rsquo;s easy to use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Pod::Perl5::Grammar;

my $match = Pod::Perl5::Grammar.parse($pod);

# or

my $match = Pod::Perl5::Grammar.parsefile(&amp;quot;/path/to/some.pod&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;action-classes:78d208860f81988c9597decb37b0b553&#34;&gt;Action classes&lt;/h3&gt;

&lt;p&gt;So far so cool, but we can do more. Action classes are regular Perl 6 classes that can be given to the grammar at parse time. They provide behavior (actions) for token matching events. Just name the methods in the action class the same as the token they should be executed on. I wrote a pod-to-HTML action &lt;a href=&#34;https://github.com/dnmfarrell/Pod-Perl5/blob/master/lib/Pod/Perl5/ToHTML.pm&#34;&gt;class&lt;/a&gt;. Here is the method for converting &lt;code&gt;=head1&lt;/code&gt; to HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;method head1 ($/)
{
  self.add_to_html(&#39;body&#39;, &amp;quot;&amp;lt;h1&amp;gt;{$/&amp;lt;singleline_text&amp;gt;.Str}&amp;lt;/h1&amp;gt;\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every time the grammar matches a head1 token, this method executes. It&amp;rsquo;s passed the regex capture variable &lt;code&gt;$/&lt;/code&gt;, which contains the head1 regex capture, from which it extracts the text string.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a cool fact: action classes are even easier to write than grammars. It would be trivial to write a pod to markdown converter using Pod::Perl5::Grammar, unless someone beats me to it (hint, hint). That said, I did encounter a few challenges along the way.&lt;/p&gt;

&lt;p&gt;Essentially for HTML conversion, each action class method can just extract the text from it&amp;rsquo;s matching token, reformat it as required, and print it out. This approach worked great until I encountered nested tokens like formatting codes, which sit within a paragraph of text. You don&amp;rsquo;t want to go from this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;There are different ways to emphasize text, I&amp;lt;this is in italics&amp;gt; and  B&amp;lt;this is in bold&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;i&amp;gt;this is in italics&amp;lt;/i&amp;gt;
&amp;lt;b&amp;gt;this is in bold&amp;lt;/b&amp;gt;
&amp;lt;p&amp;gt;There are different ways to emphasize text, I&amp;lt;this is in italics&amp;gt; and  B&amp;lt;this is in bold&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This can happen because the italics and bold token regexes match first. So to get around this issue, I used a buffer to store the HTML from the transformed sub-tokens, and then when a paragraph token is matched, it substitutes its own text with the contents of the buffer. The action class code for this looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;method paragraph ($/ is copy)
{
  my $original_text = $/&amp;lt;text&amp;gt;.Str.chomp;
  my $para_text = $/&amp;lt;text&amp;gt;.Str.chomp;

  for self.get_buffer(&#39;paragraph&#39;).reverse -&amp;gt; $pair # reverse as we&#39;re working outside in
  {
    $para_text = $para_text.subst($pair.key, {$pair.value});
  }
  self.add_to_html(&#39;body&#39;, &amp;quot;&amp;lt;p&amp;gt;{$para_text}&amp;lt;/p&amp;gt;\n&amp;quot;);
  self.clear_buffer(&#39;paragraph&#39;);
  }

method italic ($/)
{
  self.add_to_buffer(&#39;paragraph&#39;, $/.Str =&amp;gt; &amp;quot;&amp;lt;i&amp;gt;{$/&amp;lt;multiline_text&amp;gt;.Str}&amp;lt;/i&amp;gt;&amp;quot;);
}

method bold ($/)
{
  self.add_to_buffer(&#39;paragraph&#39;, $/.Str =&amp;gt; &amp;quot;&amp;lt;b&amp;gt;{$/&amp;lt;multiline_text&amp;gt;.Str}&amp;lt;/b&amp;gt;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One thing to watch out for with action classes is regex handling. &lt;strong&gt;Every&lt;/strong&gt; action class example I&amp;rsquo;ve seen uses &lt;code&gt;$/&lt;/code&gt; in the method signature. This is a mistake, as guess what this does:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;method head1 ($/)
{
  if $/.Str ~~ m/foobar/ # silly example
  {
    self.add_to_html(&#39;body&#39;, &amp;quot;&amp;lt;h1&amp;gt;{$/&amp;lt;singleline_text&amp;gt;.Str}\n&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Cannot assign to a readonly variable or a value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mushroom cloud-style boom. When &lt;code&gt;$/&lt;/code&gt; is passed to &lt;code&gt;head1&lt;/code&gt; it is read only. Executing &lt;strong&gt;any&lt;/strong&gt; regex in the same lexical scope will attempt to overwrite &lt;code&gt;$/&lt;/code&gt;. This bit me a few times and with help from #perl6, I ended up using this pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;method head1 ($/ is copy)
{
  my $match = $/;
  if $match.Str ~~ m/foobar/
  {
    self.add_to_html(&#39;body&#39;, &amp;quot;&amp;lt;h1&amp;gt;{$match&amp;lt;singleline_text&amp;gt;.Str}&amp;lt;/h1&amp;gt;\n&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding &lt;code&gt;is copy&lt;/code&gt; to the signature creates a copy instead of a reference for &lt;code&gt;$/&lt;/code&gt;. I then copy the match variable into &lt;code&gt;$match&lt;/code&gt;, so that the following regex can clobber &lt;code&gt;$/&lt;/code&gt;. I *think* a better solution is this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;method head1 ($match)
{
  if $match.Str ~~ m/foobar/
  {
    self.add_to_html(&#39;body&#39;, &amp;quot;&amp;lt;h1&amp;gt;{$match&amp;lt;singleline_text&amp;gt;.Str}&amp;lt;/h1&amp;gt;\n&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think it&amp;rsquo;s that simple, just don&amp;rsquo;t name the signature parameter &lt;code&gt;$/&lt;/code&gt; and all the headaches disappear. I haven&amp;rsquo;t tested this extensively&amp;hellip;&lt;/p&gt;

&lt;p&gt;To use an action class, just pass it to the grammar:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Pod::Perl5::Grammar;
use Pod::Perl5::ToHTML;

my $actions = Pod::Perl5::ToHTML.new;
my $match = Pod::Perl5::Grammar.parse($pod, :$actions);

# or
my $match = Pod::Perl5::Grammar.parse($pod, :actions($actions));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the first example I used a named positional argument &lt;code&gt;:$actions&lt;/code&gt;. This &lt;strong&gt;must&lt;/strong&gt; be called actions to work. In the second example I named the argument like this: &lt;code&gt;:actions($actions)&lt;/code&gt;, in which case the action class object can be called whatever you want.&lt;/p&gt;

&lt;h3 id=&#34;improving-pod:78d208860f81988c9597decb37b0b553&#34;&gt;Improving pod&lt;/h3&gt;

&lt;p&gt;PerlTricks.com articles are written in HTML. Special snowflake style HTML with class names and &lt;code&gt;span&lt;/code&gt; tags. This is a pain for writers to use and a pain to edit. I&amp;rsquo;d love to use pod as the source - it would be easier for writers to use and faster for me to edit. That said, I&amp;rsquo;d like to extend pod with some useful features for blogging. For instance, you may be familiar with formatting codes like &lt;code&gt;B&amp;lt;...&amp;gt;&lt;/code&gt; for bold and the like. Well, what about &lt;code&gt;@&amp;lt; ... &amp;gt;&lt;/code&gt; for a Twitter references, or &lt;code&gt;M&amp;lt; ... &amp;gt;&lt;/code&gt; for &lt;a href=&#34;https://metacpan.org/&#34;&gt;MetaCPAN&lt;/a&gt; links?&lt;/p&gt;

&lt;p&gt;As Perl 6 grammars are classes, they can be inherited and overridden. So I can add my Twitter and Metacpan formatting codes to the grammar like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;grammar Pod::Perl5::Grammar::PerlTricks is Pod::Perl5::Grammar
{
  token twitter  { @\&amp;lt; &amp;lt;name&amp;gt; \&amp;gt; }
  token metacpan { M\&amp;lt; &amp;lt;name&amp;gt; \&amp;gt; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ll also need to override the &lt;code&gt;format_codes&lt;/code&gt; token to include the new tokens:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;token format_codes  {
  [
    &amp;lt;italic&amp;gt;|&amp;lt;bold&amp;gt;|&amp;lt;code&amp;gt;|&amp;lt;link&amp;gt;
    |&amp;lt;escape&amp;gt;|&amp;lt;filename&amp;gt;|&amp;lt;singleline&amp;gt;
    |&amp;lt;index&amp;gt;|&amp;lt;zeroeffect&amp;gt;|&amp;lt;twitter|&amp;lt;metacpan&amp;gt;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s that easy. The new grammar will parse all pod, plus my two new formatting codes. Of course the action class Pod::Perl5::Pod can be extended and overridden too, and would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;Pod::Perl5::ToHTML::PerlTricks is Pod::Perl5::ToHTML
{
  method twitter ($match)
  {
    self.add_to_buffer(&#39;paragraph&#39;,
      $match.Str =&amp;gt;
&amp;quot;&amp;lt;a href=&amp;quot;http://twitter.com/{$match&amp;lt;name&amp;gt;.Str}&amp;quot;&amp;gt;{$match&amp;lt;name&amp;gt;.Str}&amp;lt;/a&amp;gt;&amp;quot;);
  }
  method metacpan ($match)
  {
    self.add_to_buffer(&#39;paragraph&#39;, 
      $match.Str =&amp;gt; 
&amp;quot;&amp;lt;a href=&amp;quot;https://metacpan.org/pod//{$match&amp;lt;name&amp;gt;.Str}&amp;quot;&amp;gt;{$match&amp;lt;name&amp;gt;.Str}&amp;lt;/a&amp;gt;&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wait-there-s-more:78d208860f81988c9597decb37b0b553&#34;&gt;Wait, there&amp;rsquo;s more&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s a cleaner way to manage groups of tokens, it&amp;rsquo;s called &lt;a href=&#34;http://design.perl6.org/S06.html#Routine_modifiers&#34;&gt;multi-dispatch&lt;/a&gt;. Instead of defining &lt;code&gt;format_codes&lt;/code&gt; as a list of alternative tokens it can match against, we declare a prototype method, and declare each formatting method as a &lt;code&gt;multi&lt;/code&gt; of the prototype. Check this out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;proto token format_codes  { * }
multi token format_codes:italic { I\&amp;lt; &amp;lt;multiline_text&amp;gt;  \&amp;gt;  }
multi token format_codes:bold   { B\&amp;lt; &amp;lt;multiline_text&amp;gt;  \&amp;gt;  }
multi token format_codes:code   { C\&amp;lt; &amp;lt;multiline_text&amp;gt;  \&amp;gt;  }
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when this grammar is inherited, there is no need to override &lt;code&gt;format_codes&lt;/code&gt;. Instead I can declare the new tokens as multis:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;grammar Pod::Perl5::Grammar::PerlTricks is Pod::Perl5::Grammar
{
  token format_codes:twitter  { @\&amp;lt; &amp;lt;name&amp;gt; \&amp;gt; }
  token format_codes:metacpan { M\&amp;lt; &amp;lt;name&amp;gt; \&amp;gt; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using multi-dispatch also has the modest benefit of simplifying the data extraction path when working with a match object. For instance, these code extracts the link section from the 3rd paragraph of a pod block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;is $match&amp;lt;pod_section&amp;gt;[0]&amp;lt;paragraph&amp;gt;[2]&amp;lt;text&amp;gt;&amp;lt;format_codes&amp;gt;[0]&amp;lt;link&amp;gt;&amp;lt;section&amp;gt;.Str # regular version
is $match&amp;lt;pod_section&amp;gt;[0]&amp;lt;paragraph&amp;gt;[2]&amp;lt;text&amp;gt;&amp;lt;format_codes&amp;gt;[0]&amp;lt;section&amp;gt;.Str # multi dispatch equivalent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the first example, the format token name &lt;code&gt;link&lt;/code&gt; is required. But with multi-dispatch, we can remove that, as shown in the second example.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:78d208860f81988c9597decb37b0b553&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;So that&amp;rsquo;s what I learned; overall writing a pod parser in Perl 6 was straightforward. If you&amp;rsquo;re programming in Perl 6 and have questions, I&amp;rsquo;d highly recommend the &lt;a href=&#34;http://perl6.org/community/irc&#34;&gt;#perl6&lt;/a&gt; irc channel on freenode, the people there were friendly and responsive.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; &lt;em&gt;Multi-dispatch example added. Thanks to Jonathan Scott Duff for providing the multi-dispatch explanation and code. 2015-05-01&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Get started with Perl 6 one liners</title>
      <link>https://dnmfarrell.github.io/article/136/2014/11/20/Get-started-with-Perl-6-one-liners/</link>
      <pubDate>Thu, 20 Nov 2014 14:04:56 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/136/2014/11/20/Get-started-with-Perl-6-one-liners/</guid>
      <description>

&lt;p&gt;One thing that sets Perl apart from other languages is the ability to write small programs in a single line of code, known as a &amp;ldquo;one liner&amp;rdquo;. It&amp;rsquo;s often faster to type a program directly into the terminal than to write a throwaway script. And one liners are powerful too; they&amp;rsquo;re complete Perl programs that can load external libraries but also integrate into the terminal. You can pipe data in or out of a one liner.&lt;/p&gt;

&lt;p&gt;Like its predecessor, Perl 6 supports one liners. And in the same way Perl 6 cleaned up Perl 5&amp;rsquo;s warts elsewhere, the one liner syntax is also better. It&amp;rsquo;s cleaner with fewer special variables and options to memorize. This article aims to get you up-and-running with Perl 6 one liners.&lt;/p&gt;

&lt;h3 id=&#34;the-basics:f134c951b57c0f63005d49172b15ce32&#34;&gt;The basics&lt;/h3&gt;

&lt;p&gt;To get started with one liners, all you really need to understand is the &lt;code&gt;-e&lt;/code&gt; option. This tells Perl to execute what follows as a program. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perl6 -e &#39;say &amp;quot;Hello, World!&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s step through this code.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;perl6&lt;/code&gt; invokes the Perl 6 program&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt; tells Perl 6 to execute&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;say &amp;quot;Hello, World!&amp;quot;&#39;&lt;/code&gt; is the program. Every program must be surrounded in single quotes (except on Windows, see (&lt;a href=&#34;https://github.com/sillymoose/Perl6-One-Liners#converting-for-windows&#34;&gt;converting for Windows&lt;/a&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To run a one-liner, just type it into the terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -e &#39;say &amp;quot;Hello, World!&amp;quot;&#39;
Hello, World!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;file-processing:f134c951b57c0f63005d49172b15ce32&#34;&gt;File processing&lt;/h3&gt;

&lt;p&gt;If you want to load a file, just add the path to the file after the program code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -e &#39;for (lines) { say $_ }&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program prints every line in &lt;code&gt;/path/to/file.txt&lt;/code&gt;. You may know that &lt;code&gt;$_&lt;/code&gt; is the default variable, which in this case is the current line being looped through. &lt;code&gt;lines&lt;/code&gt; is a list that is automatically created for you whenever you pass a filepath to a one-liner. Now let&amp;rsquo;s re-write that one liner, step-by-step. These one liners are all equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -e &#39;for (lines) { say $_ }&#39; /path/to/file.txt
&amp;gt; perl6 -e &#39;for (lines) { $_.say }&#39; /path/to/file.txt
&amp;gt; perl6 -e &#39;for (lines) { .say }&#39; /path/to/file.txt
&amp;gt; perl6 -e &#39;.say for (lines)&#39; /path/to/file.txt
&amp;gt; perl6 -e &#39;.say for lines&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like &lt;code&gt;$_&lt;/code&gt; is the default variable, methods called on the default variable can omit the variable name. They become default methods. So &lt;code&gt;$_.say&lt;/code&gt; becomes &lt;code&gt;.say&lt;/code&gt;. This brevity pays off with one liners - it&amp;rsquo;s less typing!&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;-n&lt;/code&gt; option changes the behavior of the program: it executes the code once for every line of the file. To uppercase and print every line of &lt;code&gt;/path/to/file.txt&lt;/code&gt; you can type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -ne &#39;.uc.say&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-p&lt;/code&gt; option is just like &lt;code&gt;-n&lt;/code&gt; except that it will automatically print &lt;code&gt;$_&lt;/code&gt;. This means that another way we could uppercase a file would be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -pe &#39;$_ = $_.uc&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or by applying a shortcut, this does the same thing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -pe &#39;.=uc&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt; options are really useful and often spare the programmer from extra typing.&lt;/p&gt;

&lt;h3 id=&#34;load-modules:f134c951b57c0f63005d49172b15ce32&#34;&gt;Load modules&lt;/h3&gt;

&lt;p&gt;The final thing you should know is how to load a module. This is really powerful as you can extend Perl 6&amp;rsquo;s capabilities by importing external libraries. The &lt;code&gt;-M&lt;/code&gt; switch stands for load module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -M URI::Encode -e &#39;say encode_uri(&amp;quot;/10 ways to crush it with Perl 6&amp;quot;)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code &lt;code&gt;-M URI::Encode&lt;/code&gt; loads the URI::Encode module, which exports the &lt;code&gt;encode_uri&lt;/code&gt; subroutine. It prints:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;%2F10%20ways%20to%20crush%20it%20with%20Perl%206
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What if you have a module that is not installed in a standard location? In this case using &lt;code&gt;-M&lt;/code&gt; alone won&amp;rsquo;t work, as Perl won&amp;rsquo;t find the module. For these scenarios, just pass use the &lt;code&gt;-I&lt;/code&gt; switch to include the directory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -I lib -M URI::Encode -e &#39;say encode_uri(&amp;quot;www.example.com/10 ways to crush it with Perl 6&amp;quot;)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now Perl 6 will search for URI::Encode in &lt;code&gt;lib&lt;/code&gt; as well as the standard install locations.&lt;/p&gt;

&lt;p&gt;Finally, if you want a summary of all of these options, just use the &lt;code&gt;-h&lt;/code&gt; option:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;    With no arguments, enters a REPL. With a &amp;quot;[programfile]&amp;quot; or the &amp;quot;-e&amp;quot; option, compiles the given program and by default also executes the compiled code.
 
    -c                   check syntax only (runs BEGIN and CHECK blocks)
    --doc                extract documentation and print it as text
    -e program           one line of program
    -h, --help           display this help text
    -n                   run program once for each line of input
    -p                   same as -n, but also print $_ at the end of lines
    -I path              adds the path to the module search path
    -M module            loads the module prior to running the program
    --target=[stage]     specify compilation stage to emit
    --optimize=[level]   use the given level of optimization (0..3)
    -t, --trace=[flags]  enable trace flags, see &#39;parrot --help-debug&#39;
    --encoding=[mode]    specify string encoding mode
    -o, --output=[name]  specify name of output file
    -v, --version        display version information
    --stagestats         display time spent in the compilation stages
    --ll-exception       display a low level backtrace on errors
    --profile            print profile information to standard error
    --doc=[module]       Use Pod::To::[module] to render inline documentation.
     
    Note that only boolean single-letter options may be bundled.

    Output from --profile can be visualized by kcachegrind.

    To modify the include path, you can set the PERL6LIB environment variable:

    PERL6LIB=&amp;quot;lib&amp;quot; perl6 example.pl

    For more information, see the perl6(1) man page.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion:f134c951b57c0f63005d49172b15ce32&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This article was adapted from my open source &lt;a href=&#34;https://github.com/sillymoose/Perl6-One-Liners&#34;&gt;book&lt;/a&gt;, which has lots of example Perl 6 one liners, many of which were contributed by the Perl 6 community. If you&amp;rsquo;re interested in learning more Perl 6, I&amp;rsquo;d recommend visiting the official &lt;a href=&#34;http://perl6.org/&#34;&gt;website&lt;/a&gt;, which has links to the IRC channel and official documentation.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Perl 6 with Visual Studio 2013</title>
      <link>https://dnmfarrell.github.io/article/135/2014/11/18/Building-Perl-6-with-Visual-Studio-2013/</link>
      <pubDate>Tue, 18 Nov 2014 13:34:36 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/135/2014/11/18/Building-Perl-6-with-Visual-Studio-2013/</guid>
      <description>

&lt;p&gt;I think the last time I tried playing around with anything related to Perl 6 was at least two years ago. Recently, &lt;a href=&#34;https://fosdem.org/2015/schedule/event/get_ready_to_party/&#34;&gt;an understated entry&lt;/a&gt; in Fosdem &amp;lsquo;15 schedule caught the Perl community&amp;rsquo;s attention:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The last pieces are finally falling into place. After years of design and implementation, 2015 will be the year that Perl 6 officially launches for production use.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since then, Microsoft made &lt;a href=&#34;http://blog.nu42.com/2014/11/64-bit-perl-5201-with-visual-studio.html&#34;&gt;Visual Studio 2013 freely available&lt;/a&gt; for individuals and small teams. Up to this point, I had been using the compiler that comes with Windows SDK 7.1 with decent results, but, of course, couldn&amp;rsquo;t resist the temptation to build Perl 5.20.1 with the new compiler.&lt;/p&gt;

&lt;p&gt;This was followed by an encouraging question from &lt;a href=&#34;http://www.reddit.com/r/perl/comments/2m3t6s/%CE%BD42_64bit_perl_5201_with_visual_studio_2013/cm1iqnb&#34;&gt;David Farrell&lt;/a&gt;: &amp;ldquo;Have you thought about compiling Rakudo?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Well, I hadn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;I had been anticipating too many headaches from not using *nix tools, but I decided to give it a shot. Perl 6 really couldn&amp;rsquo;t be ready enough that I could just get the source and build it, could it?&lt;/p&gt;

&lt;p&gt;I started with Rakudo Star - a Perl 6 distribution that bundles some useful modules and a package manager. I downloaded &lt;a href=&#34;http://rakudo.org/downloads/star/&#34;&gt;rakudo-star-2014.09.tar.gz&lt;/a&gt;, extracted it and ran the configure script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;C:\Src&amp;gt; perl Configure.pl --gen-moar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This configures Perl 6 to use &lt;a href=&#34;http://moarvm.com/&#34;&gt;MoarVM&lt;/a&gt;, one of several virtual machines that Perl 6 can be built for. From that point on, it was just a matter of following a few prompts and soon I had a &lt;code&gt;perl6&lt;/code&gt; that was churning through the specification tests.&lt;/p&gt;

&lt;p&gt;Those did take a while. In the end there were about a dozen test failures which represent a tiny fraction of the total number of tests.&lt;/p&gt;

&lt;h3 id=&#34;compiling-rakudo-from-source:8e521b9a6a55a3a00378444bf2aee097&#34;&gt;Compiling Rakudo from source&lt;/h3&gt;

&lt;p&gt;Using the two months old Rakudo Star distribution left me wanting more. So I headed over to &lt;a href=&#34;https://github.com/rakudo/rakudo/&#34;&gt;Rakudo&amp;rsquo;s GitHub repository&lt;/a&gt; and proceeded to checkout and build the default branch.&lt;/p&gt;

&lt;p&gt;If you want to build Rakudo from source you will need &lt;a href=&#34;http://git-scm.com/&#34;&gt;Git&lt;/a&gt; for this to work. There are several options available, including &lt;a href=&#34;https://windows.github.com/&#34;&gt;GitHub Windows&lt;/a&gt; and &lt;a href=&#34;http://git-scm.com/download/win&#34;&gt;Git for Windows&lt;/a&gt;. I prefer to use &lt;a href=&#34;https://www.cygwin.com/&#34;&gt;Cygwin&lt;/a&gt; versions of *nixy utilities by adding Cygwin&amp;rsquo;s executable locations &lt;em&gt;last&lt;/em&gt; in my &lt;code&gt;%PATH%&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Once you have a version of Git installed, these are the steps to follow:&lt;/p&gt;

&lt;p&gt;Open a &amp;ldquo;VS2013 x64 Native Tools Command Prompt&amp;rdquo;. You can find the shortcuts under &lt;code&gt;C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\Tools\Shortcuts&lt;/code&gt; (with Visual Studio 2015, the shortcut is under: &lt;code&gt;C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Visual Studio 2015\Visual Studio Tools\Windows Desktop Command Prompts&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Run the following commands to get the Rakudo source and build it for MoarVM:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; git clone https://github.com/rakudo/rakudo.git
&amp;gt; cd rakudo
&amp;gt; perl Configure.pl --gen-moar --gen-nqp --backends=moar --prefix=C:/opt/Perl6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;N.B. Make sure this is a native Windows &lt;code&gt;perl&lt;/code&gt;, not a Cygwin version in case you have those on the path. If you want to be absolutely certain, specify the full path. E.g., in my case, &lt;code&gt;C:\opt\perl-5.20.1\bin\perl Configure.pl ...&lt;/code&gt;. You may also have to adjust the &lt;code&gt;--prefix&lt;/code&gt; path to suit your system.&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;Configure.pl&lt;/code&gt; will pull in the rest of the components necessary to build Rakudo. The rest is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; nmake
&amp;gt; nmake test
&amp;gt; nmake spectest
&amp;gt; nmake install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run spectest only if you are really patient or curious. When those tests were done, I had seven spectest failures. I didn&amp;rsquo;t care much about those at this point. My purpose was to have a &lt;code&gt;perl6&lt;/code&gt; working well enough to let me try, (for the first time ever!), some Perl 6 examples.&lt;/p&gt;

&lt;p&gt;You can also add the &lt;code&gt;Perl6\bin&lt;/code&gt; path to your user path. If everything worked as smoothly as it did for me, try:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -v
This is perl6 version 2014.10-114-gf8f6feb built on MoarVM version
2014.10-17-g05b25a6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And just for fun:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -e &amp;quot;&#39;Hello World!&#39;.say&amp;quot;
Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;installing-perl-6-modules:8e521b9a6a55a3a00378444bf2aee097&#34;&gt;Installing Perl 6 Modules&lt;/h3&gt;

&lt;p&gt;What is Perl without the ability to exploit other people&amp;rsquo;s hard work for your gain?&lt;/p&gt;

&lt;p&gt;Perl 6, just like Perl 5, has a module system. You can find contributed modules at &lt;a href=&#34;http://modules.perl6.org/&#34;&gt;modules.perl6.org&lt;/a&gt;, and install them using &lt;a href=&#34;https://github.com/tadzik/panda/&#34;&gt;panda&lt;/a&gt;. Unfortunately bootstrapping panda didn&amp;rsquo;t work for me due to &lt;a href=&#34;https://github.com/tadzik/File-Find/blob/master/t/01-file-find.t&#34;&gt;test failures with File::Find&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I am not sure if these indicate problems with the underlying library, or problems with the way tests are written. I suspect the latter, but that will have to wait. In the mean time, I will &lt;a href=&#34;http://perl6.org/documentation/&#34;&gt;explore the basic language&lt;/a&gt; to get a better feel for Perl 6.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; - added VS2015 instructions. 2016-01-04&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to contribute to the exercism.io Perl 5 repo</title>
      <link>https://dnmfarrell.github.io/article/91/2014/5/22/How-to-contribute-to-the-exercism-io-Perl-5-repo/</link>
      <pubDate>Thu, 22 May 2014 15:09:13 +0000</pubDate>
      
      <guid>https://dnmfarrell.github.io/article/91/2014/5/22/How-to-contribute-to-the-exercism-io-Perl-5-repo/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Earlier this week I rounded off our exercism.io article with a call to action to help port exercises into the Perl 5 repo. Today I&amp;rsquo;m going to walk through the porting process step-by-step and show you how easy it is to contribute.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;requirements:96c520196f6519b815b433280ae5ea10&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ll need a GitHub account and Perl installed. That&amp;rsquo;s it!&lt;/p&gt;

&lt;h3 id=&#34;fork-the-repo:96c520196f6519b815b433280ae5ea10&#34;&gt;Fork the repo&lt;/h3&gt;

&lt;p&gt;To contribute to a project on GitHub, we&amp;rsquo;ll use the &amp;ldquo;fork and pull&amp;rdquo; approach. First we&amp;rsquo;ll login to GitHub:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dnmfarrell.github.io/static/images/91/github_1.png&#34; title=&#34;Login to GitHub&#34;&gt;&lt;img src=&#34;https://dnmfarrell.github.io/static/images/91/github_1_small.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Next, search for the exercism/xperl5 repo:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dnmfarrell.github.io/static/images/91/github_2.png&#34; title=&#34;Search for exercism/xperl5&#34;&gt;&lt;img src=&#34;https://dnmfarrell.github.io/static/images/91/github_2_small.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dnmfarrell.github.io/static/images/91/github_3.png&#34; title=&#34;Click the fork button&#34;&gt;&lt;img src=&#34;https://dnmfarrell.github.io/static/images/91/github_3_small.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Click the &amp;ldquo;Fork&amp;rdquo; button to copy the repo into our own perltricks/xperl5 repo:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dnmfarrell.github.io/static/images/91/github_4.png&#34; title=&#34;Our own forked repo&#34;&gt;&lt;img src=&#34;https://dnmfarrell.github.io/static/images/91/github_4_small.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;get-the-exercises:96c520196f6519b815b433280ae5ea10&#34;&gt;Get the exercises&lt;/h3&gt;

&lt;p&gt;Now we&amp;rsquo;ve forked the repo, we can commit changes to our forked version. To start we&amp;rsquo;ll need to download the Perl exercises from our forked repo. We can do this from the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ git clone https://github.com/sillymoose/xperl5.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will download the xperl5 repo into a directory called &amp;ldquo;xperl5&amp;rdquo;. Next download the list of common exercises:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ git clone https://github.com/exercism/x-common.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will download the latest list of available exercises to the &amp;ldquo;x-common&amp;rdquo; directory, which contains a collection of readme files for the exercises. Any exercise that has a readme file in x-common that is missing from the xperl5 directory needs to be ported.&lt;/p&gt;

&lt;h3 id=&#34;find-the-exercise-in-another-language:96c520196f6519b815b433280ae5ea10&#34;&gt;Find the exercise in another language&lt;/h3&gt;

&lt;p&gt;Once you&amp;rsquo;ve found an exercise that needs to be ported, you&amp;rsquo;ll want to find that exercise in one of the other languages repos. It&amp;rsquo;s far easier to translate an exercise than to write it from scratch yourself! The Ruby, Python and JavaScript repos have most of the exercises, so we&amp;rsquo;ll start with one of those. For example to download the Ruby exercises repo, just type this command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ git clone https://github.com/exercism/xruby.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the xruby directory doesn&amp;rsquo;t have the exercise you&amp;rsquo;re looking to port, try cloning xpython or xjavascript instead.&lt;/p&gt;

&lt;h3 id=&#34;porting-the-exercise:96c520196f6519b815b433280ae5ea10&#34;&gt;Porting the exercise&lt;/h3&gt;

&lt;p&gt;To port an exercise you need to provide the exercise test file and an Example.pm module which passes the tests. Earlier this week I ported the &amp;ldquo;leap&amp;rdquo; exercise from Ruby to Perl. This involved three steps. First I created the new exercise subdirectory in the xperl5 directory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ mkdir xperl5/leap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, I translated the Ruby test file &amp;ldquo;xruby/leap/leap_test.rb&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;require &#39;date&#39;
require &#39;minitest/autorun&#39;
require_relative &#39;year&#39;

class Date
  def leap?
    throw &amp;quot;Try to implement this yourself instead of using Ruby&#39;s implementation.&amp;quot;
  end
  
  alias :gregorian_leap? :leap?
  alias :julian_leap? :leap?
end

class YearTest &amp;lt; MiniTest::Unit::TestCase
  def test_leap_year
    assert Year.leap?(1996)
  end

  def test_non_leap_year
    skip
    refute Year.leap?(1997)
  end
  
  def test_non_leap_even_year
    skip
    refute Year.leap?(1998)
  end

  def test_century
    skip
    refute Year.leap?(1900)
  end

  def test_fourth_century
    skip
    assert Year.leap?(2400)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to &amp;ldquo;xperl5/leap/leap.t&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use warnings;
use strict;
use Test::More tests =&amp;gt; 7;

my $module = $ENV{EXERCISM} ? &#39;Example&#39; : &#39;Leap&#39;;
my $sub = $module . &#39;::is_leap&#39;;

use_ok($module) or BAIL_OUT (&amp;quot;You need to create a module called $module.pm.&amp;quot;);
can_ok($module, &#39;is_leap&#39;) or BAIL_OUT(&amp;quot;Missing package $module with sub is_leap().&amp;quot;);

do {
    no strict &#39;refs&#39;;
    is 1, $sub-&amp;gt;(1996), &#39;1996 is a leap year&#39;;
    is 0, $sub-&amp;gt;(1997), &#39;1997 is not a leap year&#39;;
    is 0, $sub-&amp;gt;(1998), &#39;1998 is not a leap year&#39;;
    is 0, $sub-&amp;gt;(1900), &#39;1900 is not a leap year&#39;;
    is 1, $sub-&amp;gt;(2400), &#39;2400 is a leap year&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally I ported the example answer &amp;ldquo;xruby/leap/example.rb&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;require &#39;delegate&#39;

class Year &amp;lt; SimpleDelegator

  def self.leap?(number)
    Year.new(number).leap?
  end 

  def leap?
    divisible_by?(400) || divisible_by?(4) &amp;amp;&amp;amp; !divisible_by?(100)
  end

  private

  def divisible_by?(i)
    (self % i) == 0
  end 
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the Perl version, &amp;ldquo;xperl5/leap/Example.pm&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Example;
use warnings;
use strict;

sub is_leap {
    my $year = shift;
    divisible_by($year, 400)
        or divisible_by($year, 4) and !divisible_by($year, 100)
        ? 1 : 0;
}

sub divisible_by {
    $_[0] % $_[1] == 0 ? 1 : 0;
}

__PACKAGE__;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the test file at the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ EXERCISM=1 prove leap.t
leap.t .. ok   
All tests successful.
Files=1, Tests=7,  0 wallclock secs ( 0.02 usr  0.00 sys +  0.02 cusr  0.00 csys =  0.04 CPU)
Result: PASS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of our tests passed, so we can commit these files. I also &lt;a href=&#34;https://github.com/sillymoose/xperl6/tree/master/leap&#34;&gt;ported&lt;/a&gt; a Perl 6 version.&lt;/p&gt;

&lt;h3 id=&#34;add-the-new-exercise-to-the-forked-repo:96c520196f6519b815b433280ae5ea10&#34;&gt;Add the new exercise to the forked repo&lt;/h3&gt;

&lt;p&gt;Now that we&amp;rsquo;ve ported the files, we need to add them to the forked xperl5 repository and commit the change. Here&amp;rsquo;s are the commands to do that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cd xperl5
$ git add leap/Example.pm leap/leap.t
$ git commit -am &#39;Added the leap exercise&#39;
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the forked repo is out of sync with exercism/xperl5 you&amp;rsquo;ll need to &lt;a href=&#34;http://stackoverflow.com/questions/7244321/how-to-update-github-forked-repository&#34;&gt;rebase&lt;/a&gt; it.&lt;/p&gt;

&lt;h3 id=&#34;create-a-pull-request:96c520196f6519b815b433280ae5ea10&#34;&gt;Create a pull request&lt;/h3&gt;

&lt;p&gt;Returning to GitHub, all we have to do is initiate a pull request from our forked repo at perltricks/xperl5. Clicking the &amp;ldquo;pull requests&amp;rdquo; link on the right of the screen brings us to the pull requests screen:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dnmfarrell.github.io/static/images/91/github_5.png&#34; title=&#34;The pull requests screen&#34;&gt;&lt;img src=&#34;https://dnmfarrell.github.io/static/images/91/github_5_small.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Clicking the &amp;ldquo;new pull request&amp;rdquo; button will create the pull request form, GitHub automatically knows that the pull request should go back to exercism/xperl5.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dnmfarrell.github.io/static/images/91/github_6.png&#34; title=&#34;The new pull request. Send the pull request!&#34;&gt;&lt;img src=&#34;https://dnmfarrell.github.io/static/images/91/github_6_small.png&#34; alt=&#34;&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Clicking the &amp;ldquo;Send pull request&amp;rdquo; button submits the pull request and we&amp;rsquo;re done! The exercism repo committers usually respond within a couple of hours. So now you&amp;rsquo;ve seen how easy it is to port an exercise, be warned it can be addictive &amp;hellip;&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F91%2F2014%2F5%2F21%2FHow-to-contribute-to-the-exercism-io-Perl-5-repo&amp;amp;text=How+to+contribute+to+the+exercism.io+Perl+5+repo&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F91%2F2014%2F5%2F21%2FHow-to-contribute-to-the-exercism-io-Perl-5-repo&amp;amp;via=perltricks&#34;&gt;tweet&lt;/a&gt; about it!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

