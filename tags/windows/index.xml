<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Windows on Perl programming news, code and culture</title>
    <link>http://perltricks.com/tags/windows/</link>
    <description>Recent content in Windows on Perl programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 31 Dec 2015 19:08:59 +0000</lastBuildDate>
    <atom:link href="http://perltricks.com/tags/windows/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How to get Perl 6 now</title>
      <link>http://perltricks.com/article/207/2015/12/31/How-to-get-Perl-6-now/</link>
      <pubDate>Thu, 31 Dec 2015 19:08:59 +0000</pubDate>
      
      <guid>http://perltricks.com/article/207/2015/12/31/How-to-get-Perl-6-now/</guid>
      <description>

&lt;p&gt;Great news, Perl 6 was &lt;a href=&#34;https://perl6advent.wordpress.com/2015/12/25/christmas-is-here/&#34;&gt;released&lt;/a&gt; on Christmas Day; finally us geeks got something we wanted for Christmas. Send the books back Grandma! (unless you got &lt;a href=&#34;http://perltricks.com/article/205/2015/12/21/Modern-Perl-4th-edition--a-review&#34;&gt;Modern Perl&lt;/a&gt;).&lt;/p&gt;

&lt;h3 id=&#34;installation-on-linux-osx:961206b7582ff32549d5b3ed6ab9aa7e&#34;&gt;Installation on Linux, OSX&lt;/h3&gt;

&lt;p&gt;On Linux and Mac the easiest way to get Perl 6 is with &lt;a href=&#34;https://github.com/tadzik/rakudobrew&#34;&gt;rakudobrew&lt;/a&gt;. You&amp;rsquo;ll need the typical software development tools like &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt;. On OSX Apple&amp;rsquo;s &lt;a href=&#34;https://developer.apple.com/opensource/&#34;&gt;Command Line Tools app&lt;/a&gt; provides most of these and is easy to install. On Linux they&amp;rsquo;re available via the package manager. Once you have the prerequisite tools installed, you can install rakudobrew via the terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ git clone https://github.com/tadzik/rakudobrew ~/.rakudobrew
$ export PATH=~/.rakudobrew/bin:$PATH
$ rakudobrew build moar
$ rakudobrew build panda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will install &lt;code&gt;perl6&lt;/code&gt; and &lt;code&gt;panda&lt;/code&gt; the Perl 6 package manager.&lt;/p&gt;

&lt;h3 id=&#34;installation-on-windows:961206b7582ff32549d5b3ed6ab9aa7e&#34;&gt;Installation on Windows&lt;/h3&gt;

&lt;p&gt;On Windows it&amp;rsquo;s a different story. I was unable to get rakudobrew to work on Windows, which is a shame as it&amp;rsquo;s such a convenient tool. If you&amp;rsquo;re feeling adventurous, you can &lt;a href=&#34;http://perltricks.com/article/135/2014/11/18/Building-Perl-6-with-Visual-Studio-2013&#34;&gt;build your own Perl 6 with Visual Studio&lt;/a&gt;. Sinan Unur has &lt;a href=&#34;https://www.nu42.com/2015/12/perl6-rakudo-released.html&#34;&gt;blogged&lt;/a&gt; about building panda with the same toolset.&lt;/p&gt;

&lt;p&gt;Alternatively you can use the latest &lt;a href=&#34;http://rakudo.org/downloads/star/&#34;&gt;Rakudo Star distribution&lt;/a&gt; which comes with a convenient &lt;code&gt;.msi&lt;/code&gt; installer. Unfortunately the most recent Rakudo Star distribution is from September, so you won&amp;rsquo;t benefit from the last 3 months of updates to Perl 6 (a new version should be available soon). If you&amp;rsquo;ve installed Rakudo Star, you&amp;rsquo;ll need to add the Perl 6 binaries to your path. You can do that using &lt;code&gt;cmd.exe&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; SETX PATH &amp;quot;%PATH%;C:\rakudo\bin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now start a new &lt;code&gt;cmd.exe&lt;/code&gt; terminal, and you&amp;rsquo;ll be use Perl 6. Rakudo Star ships with Panda too, so you&amp;rsquo;ll be able to start installing Perl 6 modules right away.&lt;/p&gt;

&lt;h3 id=&#34;useful-perl-6-resources:961206b7582ff32549d5b3ed6ab9aa7e&#34;&gt;Useful Perl 6 resources&lt;/h3&gt;

&lt;p&gt;So you&amp;rsquo;ve got Perl 6 installed, now what? To keep up to date with Perl 6 developments, I read the &lt;a href=&#34;https://p6weekly.wordpress.com/&#34;&gt;Perl 6 Weekly&lt;/a&gt; blog. The &lt;a href=&#34;http://perlweekly.com/&#34;&gt;Perl Weekly&lt;/a&gt; newsletter also includes Perl 6 articles, so be sure to subscribe if you haven&amp;rsquo;t already. The official website &lt;a href=&#34;http://perl6.org/&#34;&gt;Perl6.org&lt;/a&gt; is a good reference for all things Perl 6 related. Wendy has posted a &lt;a href=&#34;https://wendyga.wordpress.com/2015/12/25/why-would-you-want-to-use-perl-6-some-answers/&#34;&gt;useful list&lt;/a&gt; of Perl 6 features.&lt;/p&gt;

&lt;p&gt;Here at PerlTricks.com, we&amp;rsquo;ve got several Perl 6 articles that may be of interest:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://perltricks.com/article/144/2015/1/13/How-to-create-a-grammar-in-Perl-6&#34;&gt;How to create a Grammar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://perltricks.com/article/170/2015/4/30/Parsing-Perl-5-pod-with-Perl-6&#34;&gt;Parsing Perl 5 Pod with Perl 6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://perltricks.com/article/136/2014/11/20/Get-started-with-Perl-6-one-liners&#34;&gt;Get started with Perl 6 One Liners&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://perltricks.com/article/177/2015/6/9/Get-to-grips-with-Prove--Perl-s-test-workhorse&#34;&gt;How to run Perl 6 tests with prove&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://perltricks.com/article/194/2015/9/22/Activating-Perl-6-syntax-highlighting-in-Vim&#34;&gt;Activate Perl 6 syntax highlighting in Vim&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; - Visual Studio article now includes instructions for VS2015. Added link to nu42.com. 2016-01-04&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Automated Internet Explorer screenshots using Win32::OLE</title>
      <link>http://perltricks.com/article/139/2014/12/11/Automated-Internet-Explorer-screenshots-using-Win32--OLE/</link>
      <pubDate>Thu, 11 Dec 2014 14:44:25 +0000</pubDate>
      
      <guid>http://perltricks.com/article/139/2014/12/11/Automated-Internet-Explorer-screenshots-using-Win32--OLE/</guid>
      <description>

&lt;h3 id=&#34;background:97eeb34526f592925997048598be600f&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;Some time ago I &lt;a href=&#34;http://blog.nu42.com/2012/06/using-win32ole-with-events-to-capture.html&#34;&gt;wrote&lt;/a&gt; about using Perl&amp;rsquo;s Win32::OLE to drive Internet Explorer in response to a &lt;a href=&#34;http://stackoverflow.com/a/11220026/100754&#34;&gt;question&lt;/a&gt; on Stackoverflow.&lt;/p&gt;

&lt;p&gt;At the time I was still clinging to Windows XP. Since then, I have upgraded to Windows 8.1 Pro 64-bit, and instead of using &lt;a href=&#34;http://www.activestate.com/activeperl/ppm-perl-modules&#34;&gt;PPMs&lt;/a&gt; for &lt;a href=&#34;http://www.activestate.com/activeperl&#34;&gt;ActivePerl&lt;/a&gt;, I have been using &lt;a href=&#34;http://blog.nu42.com/2014/11/64-bit-perl-5201-with-visual-studio.html&#34;&gt;Visual Studio 2013&lt;/a&gt; to build &lt;code&gt;perl&lt;/code&gt;, and the modules I need.&lt;/p&gt;

&lt;p&gt;I have been using Perl&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/pod/Win32::OLE&#34;&gt;Win32::OLE&lt;/a&gt; to drive Internet Explorer for various purposes for almost 10 years now. There is really not much to it other than having to read copious amounts of Microsoft documentation. It always amazes me how, after all these years, there is no language or environment as well documented as Perl, not just in terms of the amount of information provided, but also the ease with which you can find clear, correct, and useful information.&lt;/p&gt;

&lt;p&gt;In any case, while the organization of the information leaves a lot to be desired, a good starting point for finding information on driving Internet Explorer via OLE is the InternetExplorer object &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa752084%28v=vs.85%29&#34;&gt;documentation&lt;/a&gt; on MSDN. If you want to interact with the content within an InternetExplorer object, you can consult the MSHTML Scripting Object Interfaces &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh801967%28v=vs.85%29.aspx&#34;&gt;topic&lt;/a&gt;. It also helps to know a little bit about the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/19z074ky.aspx&#34;&gt;OLE&lt;/a&gt; interface.&lt;/p&gt;

&lt;p&gt;Reading brian d foy&amp;rsquo;s article on &lt;a href=&#34;https://perltricks.com/article/138/2014/12/7/Controlling-Firefox-from-Perl&#34;&gt;controlling Firefox from Perl&lt;/a&gt;, I noticed that &lt;a href=&#34;https://metacpan.org/search?q=Win32-IE-Mechanize&#34;&gt;Win32::IE::Mechanize&lt;/a&gt; has disappeared from CPAN. The &lt;a href=&#34;http://www.perlmonks.org?node_id=1061372&#34;&gt;discussion on PerlMonks&lt;/a&gt; did not make much sense to me, as I remember very clearly using Win32::OLE to drive Internet Explorer 8 for a massive scraping job.&lt;/p&gt;

&lt;p&gt;I decided to look at my old screenshot utility, and see what changes were needed to get it to run on Windows 8, using Internet Explorer 10. My &lt;a href=&#34;https://gist.github.com/nanis/3dac6b386bd056095e12&#34;&gt;revised working script is available in a GitHub gist&lt;/a&gt;. Here, I am going to cover the highlights.&lt;/p&gt;

&lt;h3 id=&#34;tracing-execution:97eeb34526f592925997048598be600f&#34;&gt;Tracing execution&lt;/h3&gt;

&lt;p&gt;The idea is to use the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa768283%28v=vs.85%29.aspx&#34;&gt;DWebBrowserEvents2&lt;/a&gt; to figure out the right time to capture the browser window. I decided to see if my answer from 2012 still worked. I pointed it to my personal website, and it failed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Win32::OLE(0.1712) error 0x80020009: &amp;quot;Exception occurred&amp;quot;
    in METHOD/PROPERTYGET &amp;quot;StatusText&amp;quot; at iescreenshot.pl line 38.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The cause of the problem lay in accessing the &lt;code&gt;StatusText&lt;/code&gt; property of the &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa752084%28v=vs.85%29&#34;&gt;Internet Explorer object&lt;/a&gt;. Apparently, IE10 no longer exposes this property. Well, I had only used it so as to give some idea of what was happening. I decided instead to write a quick logging function which could be used with all events:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub log_browser_event {
    my $event = shift;
    no warnings &#39;uninitialized&#39;;
    my $args = eval { join(&#39; &#39; =&amp;gt; map valof($_), @_) };
    say &amp;quot;$event: $args&amp;quot;;
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not an example of perfect code, but, I am trying to keep this short and sweet.&lt;/p&gt;

&lt;h3 id=&#34;event-handling:97eeb34526f592925997048598be600f&#34;&gt;Event handling&lt;/h3&gt;

&lt;p&gt;We are only interested in two events: &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa768282%28v=vs.85%29.aspx&#34;&gt;DocumentComplete&lt;/a&gt;, so we know when to take a screenshot, and &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa768340%28v=vs.85%29.aspx&#34;&gt;onQuit&lt;/a&gt;, so we can quit cleanly if the user closes the browser window before we get to that point.&lt;/p&gt;

&lt;p&gt;You initialize OLE events using the call:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;Win32::OLE-&amp;gt;WithEvents(
    $object,
    $handler,
    $interface
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, presumably, your &lt;code&gt;$handler&lt;/code&gt; has some giant switch statement, dispatching on the basis of the actual events received. Instead, I opted for a dispatch table:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;const my %BrowserEvents =&amp;gt; (
    DocumentComplete =&amp;gt; sub {
        $do_take_screenshot = 1;
        Win32::MessageLoop-&amp;gt;QuitMessageLoop;
    },
    OnQuit =&amp;gt; sub {
        $do_take_screenshot = 0;
        Win32::MessageLoop-&amp;gt;QuitMessageLoop;
    },
    _ =&amp;gt; sub { },
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the use of &lt;a href=&#34;https://metacpan.org/pod/Win32::MessageLoop&#34;&gt;Win32::MessageLoop-&amp;gt;QuitMessageLoop&lt;/a&gt; instead of &lt;code&gt;Win32::OLE-&amp;gt;QuitMessageLoop&lt;/code&gt; to avoid spurious sleep calls.&lt;/p&gt;

&lt;p&gt;Then, I initialize the OLE events interface using:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;Win32::OLE-&amp;gt;WithEvents(
    $browser,
    sub { $handler-&amp;gt;(\%BrowserEvents, @_) },
    &#39;DWebBrowserEvents2&#39;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$handler&lt;/code&gt; in this case just logs the event, and consults the dispatch table to see if we are interested in the event:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub WebBrowserEventHandler {
    my $handlers = shift;
    my $browser = shift;
    my $event = shift;

    log_browser_event($event, @_);

    my $handler = exists $handlers-&amp;gt;{$event}
                ? $handlers-&amp;gt;{$event}
                : $handlers-&amp;gt;{_}
    ;
    $handler-&amp;gt;($browser, $event, @_);
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Upon receiving either &lt;code&gt;DocumentComplete&lt;/code&gt; or &lt;code&gt;onQuit&lt;/code&gt;, we terminate the message loop, which returns control to the navigation function. At that point, the only thing left is to check if we should capture a screenshot. After that, the program terminates.&lt;/p&gt;

&lt;h3 id=&#34;capturing-the-internet-explorer-window:97eeb34526f592925997048598be600f&#34;&gt;Capturing the Internet Explorer window&lt;/h3&gt;

&lt;p&gt;When I ran this revised script, and tried to take screenshots using &lt;a href=&#34;https://metacpan.org/pod/Imager::Screenshot&#34;&gt;Imager::Screenshot&lt;/a&gt;, I got screenshots with only the frame of the browser, and none of the content. I am not sure what&amp;rsquo;s going on, and I will try to diagnose that issue later. For now, since I was using the venerable &lt;a href=&#34;https://metacpan.org/pod/Win32::GuiTest&#34;&gt;Win32::GuiTest&lt;/a&gt; module anyway, I decided to use the &lt;code&gt;Win32::GuiTest::DibSect&lt;/code&gt; class it provides:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub take_screenshot {
    my $browser = shift;

    wait_until_ready($browser);

    my $hwnd = $browser-&amp;gt;{HWND};
    my $title = $browser-&amp;gt;{Document}{title};
    $title =~ s/[^A-Za-z0-9_-]+/-/g;

    my $ds = Win32::GuiTest::DibSect-&amp;gt;new;

    my $fgwnd = GetForegroundWindow();
    SetForegroundWindow $hwnd;
    $ds-&amp;gt;CopyWindow($hwnd);
    SetForegroundWindow $fgwnd;

    $ds-&amp;gt;SaveAs(&amp;quot;$title.bmp&amp;quot;);
    $ds-&amp;gt;Destroy;

    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;waiting-for-the-document-to-be-rendered:97eeb34526f592925997048598be600f&#34;&gt;Waiting for the document to be rendered&lt;/h3&gt;

&lt;p&gt;With that in place, I was still getting the occasional screenshot with a blank document area. If I understand this correctly, the fact that the &lt;code&gt;DocumentReady&lt;/code&gt; event fired does not mean the document has been fully rendered. It just means that you can manipulate the DOM. So, I added a simple spin loop for the browser to stop being &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/aa752050%28v=vs.85%29&#34;&gt;busy&lt;/a&gt;. This is by no means foolproof, but it has worked for most sites have tried. Sites with a lot of AJAXy stuff tend to have issues with this. There are site-specific ways of dealing with that, but that&amp;rsquo;s beyond the scope of this article.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;sub wait_until_ready {
    my $browser = shift;
    {
        local $| = 1;
        while ($browser-&amp;gt;Busy) {
            print &#39;.&#39;;
            sleep 1;
        }
    }
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, you can run the script from the command line with a simple &lt;code&gt;perl iescreenshot.pl perltricks.com&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;the-webdriver-api:97eeb34526f592925997048598be600f&#34;&gt;The WebDriver API&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ie/dn725045%28v=vs.85%29.aspx&#34;&gt;WebDriver API&lt;/a&gt; might obviate the need for using any other solution to drive Internet Explorer, but, until that is available everywhere, &lt;a href=&#34;https://metacpan.org/pod/Win32::OLE&#34;&gt;Win32::OLE&lt;/a&gt; is more than adequate.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:97eeb34526f592925997048598be600f&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Using &lt;a href=&#34;https:/metacpan.org/pod/Win32::OLE&#34;&gt;Win32::OLE&lt;/a&gt; to drive Internet Explorer has been very helpful to me in the past. Taking a screenshot is just a simple, proof-of-concept exercise. The beauty of using Perl is that once you reach a page containing the information you want, you can use Perl&amp;rsquo;s excellent HTML parsing modules to get exactly what you want out of it, and then, say, save it to an Excel worksheet, generate PDF document, or just stuff it in a database somewhere.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Get started with Perl 6 one liners</title>
      <link>http://perltricks.com/article/136/2014/11/20/Get-started-with-Perl-6-one-liners/</link>
      <pubDate>Thu, 20 Nov 2014 14:04:56 +0000</pubDate>
      
      <guid>http://perltricks.com/article/136/2014/11/20/Get-started-with-Perl-6-one-liners/</guid>
      <description>

&lt;p&gt;One thing that sets Perl apart from other languages is the ability to write small programs in a single line of code, known as a &amp;ldquo;one liner&amp;rdquo;. It&amp;rsquo;s often faster to type a program directly into the terminal than to write a throwaway script. And one liners are powerful too; they&amp;rsquo;re complete Perl programs that can load external libraries but also integrate into the terminal. You can pipe data in or out of a one liner.&lt;/p&gt;

&lt;p&gt;Like its predecessor, Perl 6 supports one liners. And in the same way Perl 6 cleaned up Perl 5&amp;rsquo;s warts elsewhere, the one liner syntax is also better. It&amp;rsquo;s cleaner with fewer special variables and options to memorize. This article aims to get you up-and-running with Perl 6 one liners.&lt;/p&gt;

&lt;h3 id=&#34;the-basics:f134c951b57c0f63005d49172b15ce32&#34;&gt;The basics&lt;/h3&gt;

&lt;p&gt;To get started with one liners, all you really need to understand is the &lt;code&gt;-e&lt;/code&gt; option. This tells Perl to execute what follows as a program. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;perl6 -e &#39;say &amp;quot;Hello, World!&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s step through this code.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;perl6&lt;/code&gt; invokes the Perl 6 program&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt; tells Perl 6 to execute&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&#39;say &amp;quot;Hello, World!&amp;quot;&#39;&lt;/code&gt; is the program. Every program must be surrounded in single quotes (except on Windows, see (&lt;a href=&#34;https://github.com/sillymoose/Perl6-One-Liners#converting-for-windows&#34;&gt;converting for Windows&lt;/a&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To run a one-liner, just type it into the terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -e &#39;say &amp;quot;Hello, World!&amp;quot;&#39;
Hello, World!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;file-processing:f134c951b57c0f63005d49172b15ce32&#34;&gt;File processing&lt;/h3&gt;

&lt;p&gt;If you want to load a file, just add the path to the file after the program code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -e &#39;for (lines) { say $_ }&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program prints every line in &lt;code&gt;/path/to/file.txt&lt;/code&gt;. You may know that &lt;code&gt;$_&lt;/code&gt; is the default variable, which in this case is the current line being looped through. &lt;code&gt;lines&lt;/code&gt; is a list that is automatically created for you whenever you pass a filepath to a one-liner. Now let&amp;rsquo;s re-write that one liner, step-by-step. These one liners are all equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -e &#39;for (lines) { say $_ }&#39; /path/to/file.txt
&amp;gt; perl6 -e &#39;for (lines) { $_.say }&#39; /path/to/file.txt
&amp;gt; perl6 -e &#39;for (lines) { .say }&#39; /path/to/file.txt
&amp;gt; perl6 -e &#39;.say for (lines)&#39; /path/to/file.txt
&amp;gt; perl6 -e &#39;.say for lines&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just like &lt;code&gt;$_&lt;/code&gt; is the default variable, methods called on the default variable can omit the variable name. They become default methods. So &lt;code&gt;$_.say&lt;/code&gt; becomes &lt;code&gt;.say&lt;/code&gt;. This brevity pays off with one liners - it&amp;rsquo;s less typing!&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;-n&lt;/code&gt; option changes the behavior of the program: it executes the code once for every line of the file. To uppercase and print every line of &lt;code&gt;/path/to/file.txt&lt;/code&gt; you can type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -ne &#39;.uc.say&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-p&lt;/code&gt; option is just like &lt;code&gt;-n&lt;/code&gt; except that it will automatically print &lt;code&gt;$_&lt;/code&gt;. This means that another way we could uppercase a file would be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -pe &#39;$_ = $_.uc&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or by applying a shortcut, this does the same thing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -pe &#39;.=uc&#39; /path/to/file.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt; options are really useful and often spare the programmer from extra typing.&lt;/p&gt;

&lt;h3 id=&#34;load-modules:f134c951b57c0f63005d49172b15ce32&#34;&gt;Load modules&lt;/h3&gt;

&lt;p&gt;The final thing you should know is how to load a module. This is really powerful as you can extend Perl 6&amp;rsquo;s capabilities by importing external libraries. The &lt;code&gt;-M&lt;/code&gt; switch stands for load module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -M URI::Encode -e &#39;say encode_uri(&amp;quot;/10 ways to crush it with Perl 6&amp;quot;)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code &lt;code&gt;-M URI::Encode&lt;/code&gt; loads the URI::Encode module, which exports the &lt;code&gt;encode_uri&lt;/code&gt; subroutine. It prints:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;%2F10%20ways%20to%20crush%20it%20with%20Perl%206
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What if you have a module that is not installed in a standard location? In this case using &lt;code&gt;-M&lt;/code&gt; alone won&amp;rsquo;t work, as Perl won&amp;rsquo;t find the module. For these scenarios, just pass use the &lt;code&gt;-I&lt;/code&gt; switch to include the directory:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -I lib -M URI::Encode -e &#39;say encode_uri(&amp;quot;www.example.com/10 ways to crush it with Perl 6&amp;quot;)&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now Perl 6 will search for URI::Encode in &lt;code&gt;lib&lt;/code&gt; as well as the standard install locations.&lt;/p&gt;

&lt;p&gt;Finally, if you want a summary of all of these options, just use the &lt;code&gt;-h&lt;/code&gt; option:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will print:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;    With no arguments, enters a REPL. With a &amp;quot;[programfile]&amp;quot; or the &amp;quot;-e&amp;quot; option, compiles the given program and by default also executes the compiled code.
 
    -c                   check syntax only (runs BEGIN and CHECK blocks)
    --doc                extract documentation and print it as text
    -e program           one line of program
    -h, --help           display this help text
    -n                   run program once for each line of input
    -p                   same as -n, but also print $_ at the end of lines
    -I path              adds the path to the module search path
    -M module            loads the module prior to running the program
    --target=[stage]     specify compilation stage to emit
    --optimize=[level]   use the given level of optimization (0..3)
    -t, --trace=[flags]  enable trace flags, see &#39;parrot --help-debug&#39;
    --encoding=[mode]    specify string encoding mode
    -o, --output=[name]  specify name of output file
    -v, --version        display version information
    --stagestats         display time spent in the compilation stages
    --ll-exception       display a low level backtrace on errors
    --profile            print profile information to standard error
    --doc=[module]       Use Pod::To::[module] to render inline documentation.
     
    Note that only boolean single-letter options may be bundled.

    Output from --profile can be visualized by kcachegrind.

    To modify the include path, you can set the PERL6LIB environment variable:

    PERL6LIB=&amp;quot;lib&amp;quot; perl6 example.pl

    For more information, see the perl6(1) man page.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion:f134c951b57c0f63005d49172b15ce32&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;This article was adapted from my open source &lt;a href=&#34;https://github.com/sillymoose/Perl6-One-Liners&#34;&gt;book&lt;/a&gt;, which has lots of example Perl 6 one liners, many of which were contributed by the Perl 6 community. If you&amp;rsquo;re interested in learning more Perl 6, I&amp;rsquo;d recommend visiting the official &lt;a href=&#34;http://perl6.org/&#34;&gt;website&lt;/a&gt;, which has links to the IRC channel and official documentation.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building Perl 6 with Visual Studio 2013</title>
      <link>http://perltricks.com/article/135/2014/11/18/Building-Perl-6-with-Visual-Studio-2013/</link>
      <pubDate>Tue, 18 Nov 2014 13:34:36 +0000</pubDate>
      
      <guid>http://perltricks.com/article/135/2014/11/18/Building-Perl-6-with-Visual-Studio-2013/</guid>
      <description>

&lt;p&gt;I think the last time I tried playing around with anything related to Perl 6 was at least two years ago. Recently, &lt;a href=&#34;https://fosdem.org/2015/schedule/event/get_ready_to_party/&#34;&gt;an understated entry&lt;/a&gt; in Fosdem &amp;lsquo;15 schedule caught the Perl community&amp;rsquo;s attention:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The last pieces are finally falling into place. After years of design and implementation, 2015 will be the year that Perl 6 officially launches for production use.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since then, Microsoft made &lt;a href=&#34;http://blog.nu42.com/2014/11/64-bit-perl-5201-with-visual-studio.html&#34;&gt;Visual Studio 2013 freely available&lt;/a&gt; for individuals and small teams. Up to this point, I had been using the compiler that comes with Windows SDK 7.1 with decent results, but, of course, couldn&amp;rsquo;t resist the temptation to build Perl 5.20.1 with the new compiler.&lt;/p&gt;

&lt;p&gt;This was followed by an encouraging question from &lt;a href=&#34;http://www.reddit.com/r/perl/comments/2m3t6s/%CE%BD42_64bit_perl_5201_with_visual_studio_2013/cm1iqnb&#34;&gt;David Farrell&lt;/a&gt;: &amp;ldquo;Have you thought about compiling Rakudo?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Well, I hadn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;I had been anticipating too many headaches from not using *nix tools, but I decided to give it a shot. Perl 6 really couldn&amp;rsquo;t be ready enough that I could just get the source and build it, could it?&lt;/p&gt;

&lt;p&gt;I started with Rakudo Star - a Perl 6 distribution that bundles some useful modules and a package manager. I downloaded &lt;a href=&#34;http://rakudo.org/downloads/star/&#34;&gt;rakudo-star-2014.09.tar.gz&lt;/a&gt;, extracted it and ran the configure script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;C:\Src&amp;gt; perl Configure.pl --gen-moar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This configures Perl 6 to use &lt;a href=&#34;http://moarvm.com/&#34;&gt;MoarVM&lt;/a&gt;, one of several virtual machines that Perl 6 can be built for. From that point on, it was just a matter of following a few prompts and soon I had a &lt;code&gt;perl6&lt;/code&gt; that was churning through the specification tests.&lt;/p&gt;

&lt;p&gt;Those did take a while. In the end there were about a dozen test failures which represent a tiny fraction of the total number of tests.&lt;/p&gt;

&lt;h3 id=&#34;compiling-rakudo-from-source:8e521b9a6a55a3a00378444bf2aee097&#34;&gt;Compiling Rakudo from source&lt;/h3&gt;

&lt;p&gt;Using the two months old Rakudo Star distribution left me wanting more. So I headed over to &lt;a href=&#34;https://github.com/rakudo/rakudo/&#34;&gt;Rakudo&amp;rsquo;s GitHub repository&lt;/a&gt; and proceeded to checkout and build the default branch.&lt;/p&gt;

&lt;p&gt;If you want to build Rakudo from source you will need &lt;a href=&#34;http://git-scm.com/&#34;&gt;Git&lt;/a&gt; for this to work. There are several options available, including &lt;a href=&#34;https://windows.github.com/&#34;&gt;GitHub Windows&lt;/a&gt; and &lt;a href=&#34;http://git-scm.com/download/win&#34;&gt;Git for Windows&lt;/a&gt;. I prefer to use &lt;a href=&#34;https://www.cygwin.com/&#34;&gt;Cygwin&lt;/a&gt; versions of *nixy utilities by adding Cygwin&amp;rsquo;s executable locations &lt;em&gt;last&lt;/em&gt; in my &lt;code&gt;%PATH%&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Once you have a version of Git installed, these are the steps to follow:&lt;/p&gt;

&lt;p&gt;Open a &amp;ldquo;VS2013 x64 Native Tools Command Prompt&amp;rdquo;. You can find the shortcuts under &lt;code&gt;C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\Tools\Shortcuts&lt;/code&gt; (with Visual Studio 2015, the shortcut is under: &lt;code&gt;C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Visual Studio 2015\Visual Studio Tools\Windows Desktop Command Prompts&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Run the following commands to get the Rakudo source and build it for MoarVM:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; git clone https://github.com/rakudo/rakudo.git
&amp;gt; cd rakudo
&amp;gt; perl Configure.pl --gen-moar --gen-nqp --backends=moar --prefix=C:/opt/Perl6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;N.B. Make sure this is a native Windows &lt;code&gt;perl&lt;/code&gt;, not a Cygwin version in case you have those on the path. If you want to be absolutely certain, specify the full path. E.g., in my case, &lt;code&gt;C:\opt\perl-5.20.1\bin\perl Configure.pl ...&lt;/code&gt;. You may also have to adjust the &lt;code&gt;--prefix&lt;/code&gt; path to suit your system.&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;Configure.pl&lt;/code&gt; will pull in the rest of the components necessary to build Rakudo. The rest is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; nmake
&amp;gt; nmake test
&amp;gt; nmake spectest
&amp;gt; nmake install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run spectest only if you are really patient or curious. When those tests were done, I had seven spectest failures. I didn&amp;rsquo;t care much about those at this point. My purpose was to have a &lt;code&gt;perl6&lt;/code&gt; working well enough to let me try, (for the first time ever!), some Perl 6 examples.&lt;/p&gt;

&lt;p&gt;You can also add the &lt;code&gt;Perl6\bin&lt;/code&gt; path to your user path. If everything worked as smoothly as it did for me, try:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -v
This is perl6 version 2014.10-114-gf8f6feb built on MoarVM version
2014.10-17-g05b25a6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And just for fun:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; perl6 -e &amp;quot;&#39;Hello World!&#39;.say&amp;quot;
Hello World!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;installing-perl-6-modules:8e521b9a6a55a3a00378444bf2aee097&#34;&gt;Installing Perl 6 Modules&lt;/h3&gt;

&lt;p&gt;What is Perl without the ability to exploit other people&amp;rsquo;s hard work for your gain?&lt;/p&gt;

&lt;p&gt;Perl 6, just like Perl 5, has a module system. You can find contributed modules at &lt;a href=&#34;http://modules.perl6.org/&#34;&gt;modules.perl6.org&lt;/a&gt;, and install them using &lt;a href=&#34;https://github.com/tadzik/panda/&#34;&gt;panda&lt;/a&gt;. Unfortunately bootstrapping panda didn&amp;rsquo;t work for me due to &lt;a href=&#34;https://github.com/tadzik/File-Find/blob/master/t/01-file-find.t&#34;&gt;test failures with File::Find&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I am not sure if these indicate problems with the underlying library, or problems with the way tests are written. I suspect the latter, but that will have to wait. In the mean time, I will &lt;a href=&#34;http://perl6.org/documentation/&#34;&gt;explore the basic language&lt;/a&gt; to get a better feel for Perl 6.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; - added VS2015 instructions. 2016-01-04&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello berrybrew, the Strawberry Perl version manager</title>
      <link>http://perltricks.com/article/119/2014/10/10/Hello-berrybrew--the-Strawberry-Perl-version-manager/</link>
      <pubDate>Fri, 10 Oct 2014 12:39:52 +0000</pubDate>
      
      <guid>http://perltricks.com/article/119/2014/10/10/Hello-berrybrew--the-Strawberry-Perl-version-manager/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://perlbrew.pl/&#34;&gt;Perlbrew&lt;/a&gt; and [plenv]() are tools for managing local Perl installations. They&amp;rsquo;re useful as they let you install and use multiple versions of Perl without administrator privileges. I have a special appreciation for them as I once tried to upgrade my mac system Perl and instead wrecked it and had to reinstall OSX.&lt;/p&gt;

&lt;p&gt;When I&amp;rsquo;m on Windows I use Strawberry Perl, so I wrote &lt;a href=&#34;https://github.com/sillymoose/berrybrew&#34;&gt;berrybrew&lt;/a&gt; to help manage Perl on Windows. It&amp;rsquo;s similar to Perlbrew and plenv; it will download, install and manage multiple versions of Strawberry Perl for you, no administrator privileges required.&lt;/p&gt;

&lt;h3 id=&#34;installation:d5167bc4d58ffc1d5402991419a8e81b&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;berrybrew is written in C#. If you have git you can install berrybrew by cloning the GitHub &lt;a href=&#34;https://github.com/sillymoose/berrybrew&#34;&gt;repo&lt;/a&gt; and either using the pre-compiled binary, or minting your own with Mono. The pre-compiled binary is &lt;code&gt;bin/berrybrew.exe&lt;/code&gt; and should work out of the box on Windows 7 and 8 (it might work on Windows XP if you have .Net framework 2 or higher installed).&lt;/p&gt;

&lt;p&gt;To download the project with git and compile it with &lt;a href=&#34;http://www.mono-project.com/&#34;&gt;Mono&lt;/a&gt; type the following commands at the terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; git clone https://github.com/sillymoose/berrybrew
&amp;gt; mcs src/berrybrew.cs -lib:lib -r:ICSharpCode.SharpZipLib.dll -out:bin/berrybrew.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will output a fresh binary in the &lt;code&gt;bin&lt;/code&gt; directory.&lt;/p&gt;

&lt;h3 id=&#34;features:d5167bc4d58ffc1d5402991419a8e81b&#34;&gt;Features&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;available&lt;/code&gt; command lists available Strawberry Perls and whether they&amp;rsquo;re installed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; berrybrew available

The following Strawberry Perls are available:

            5.20.1_64 [installed]
            5.20.1_32 [installed]
            5.18.4_64
            5.18.4_32
            5.16.3_64
            5.16.3_32
            5.14.4_64
            5.14.4_32
            5.12.3_32
            5.10.1_32
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output shows that I have both versions of Perl 5.20.1 installed. I can install another version using the &lt;code&gt;install&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; berrybrew install 5.10.1_32
Downloading http://strawberryperl.com/download/5.10.1.2/strawberry-perl-5.10.1.2-portable.zip to C:\Users\dfarrell\AppData\Local\Temp\gp5d33yg.qjo/strawberry-pe
rl-5.10.1.2-portable.zip
Confirming checksum ...
Extracting C:\Users\dfarrell\AppData\Local\Temp\gp5d33yg.qjo/strawberry-perl-5.10.1.2-portable.zip

The following Strawberry Perls are available:

            5.20.1_64 [installed]
            5.20.1_32 [installed]
            5.18.4_64
            5.18.4_32
            5.16.3_64
            5.16.3_32
            5.14.4_64
            5.14.4_32
            5.12.3_32
            5.10.1_32 [installed]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;berrybrew will download a temporary zip archive, confirm the checksums match, and extract the files to &lt;code&gt;C:\berrybrew&lt;/code&gt;. Finally I can use the newly installed Perl with the &lt;code&gt;switch&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&amp;gt; berrybrew switch 5.10.1_32
Switched to 5.10.1_32, start a new terminal to use it.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This updates my user &lt;code&gt;%PATH%&lt;/code&gt; environment variable to point at the new Perl binary. berrybrew will also warn if it finds another Perl binary in the system or user path (such as an ActiveState or vanilla Strawberry Perl). The system path can be problematic as Windows appends the user path to the system path which means it will search the system path first for any matching Perl binary and if it finds one, it will ignore the berrybrew binary. The system path also requires administrator privileges to update, which kind of goes against the spirit of berrybrew. One way to handle these would be to ask the user if they want to remove the other path, if they say yes, then berrybrew could prompt for administrator credentials, fire up another berrybrew process and remove them. For now it just warns the user and leaves the path variables untouched.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:d5167bc4d58ffc1d5402991419a8e81b&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I plan to add a few more commands to berrybrew: &lt;code&gt;exec&lt;/code&gt; to run a Perl program against every installed Perl, &lt;code&gt;uninstall&lt;/code&gt; to remove a Perl and &lt;code&gt;config&lt;/code&gt; to manage berrybrew&amp;rsquo;s settings. Under the hood a feature I&amp;rsquo;d love to add but am not sure how, is to refresh the current shell&amp;rsquo;s environment variable block, so the user doesn&amp;rsquo;t have to start a new cmd.exe when switching to a new Perl version.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s early days but if you have any suggestions for new features or feedback drop me an email or fork the project on &lt;a href=&#34;https://github.com/sillymoose/berrybrew&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Become a better programmer with exercism.io</title>
      <link>http://perltricks.com/article/90/2014/5/19/Become-a-better-programmer-with-exercism-io/</link>
      <pubDate>Mon, 19 May 2014 01:15:07 +0000</pubDate>
      
      <guid>http://perltricks.com/article/90/2014/5/19/Become-a-better-programmer-with-exercism-io/</guid>
      <description>

&lt;p&gt;&lt;em&gt;For the past week I&amp;rsquo;ve been trying out &lt;a href=&#34;http://exercism.io/&#34;&gt;exercism.io&lt;/a&gt; the programming exercises app. I heard about it back in December when Gabor &lt;a href=&#34;http://blogs.perl.org/users/gabor_szabo/2013/12/perl-exercism.html&#34;&gt;blogged&lt;/a&gt; about it, but didn&amp;rsquo;t try it until now. I wish I hadn&amp;rsquo;t waited so long, as exercism is a lot of fun.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;how-exercism-works:b8fc90b81a72b2595146025a61f1ef5d&#34;&gt;How exercism works&lt;/h3&gt;

&lt;p&gt;exercism comes with a command line app that downloads programming exercises and submits your coded answers to the exercism website. Every programming exercise comes with a readme and a test file. To complete the exercise you need to write a Perl module that passes all of the tests.&lt;/p&gt;

&lt;p&gt;When you are done and have submitted your Perl module via the command line app, you and other programmers can &amp;ldquo;nitpick&amp;rdquo; your code and comment on it. Once you feel you have gotten enough comments, you can finalize your submission and view other programmer&amp;rsquo;s solutions for the same exercise. The kicker is that you only receive one programming exercise at a time, and cannot access another exercise until you complete the current one.&lt;/p&gt;

&lt;p&gt;Perl&amp;rsquo;s TIMTOWTDI nature means that there are several correct solutions for the exercises and you can often learn something from viewing other programmers&amp;rsquo; solutions. For example in one exercise I used a regular expression only to find that the simpler &lt;a href=&#34;http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators&#34;&gt;transliteration&lt;/a&gt; operator worked just as well. The exercise difficulty varies from easy to hard, but the real challenge is finding a clean, generalized solution for the spec.&lt;/p&gt;

&lt;h3 id=&#34;try-it-out:b8fc90b81a72b2595146025a61f1ef5d&#34;&gt;Try it out&lt;/h3&gt;

&lt;p&gt;Grab the &lt;a href=&#34;https://github.com/exercism/cli/releases/latest&#34;&gt;latest binary&lt;/a&gt; for your platform and extract it. Fire up the command line and type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ exercism demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will fetch the first exercise (&amp;ldquo;Bob&amp;rdquo; at the time of writing). You can find the test file and readme at &amp;ldquo;perl5/bob/&amp;rdquo;. Opening the readme you&amp;rsquo;ll see:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# Bob

Bob is a lackadaisical teenager. In conversation, his responses are very limited.

Bob answers &#39;Sure.&#39; if you ask him a question.

He answers &#39;Woah, chill out!&#39; if you yell at him.

He says &#39;Fine. Be that way!&#39; if you address him without actually saying anything.

He answers &#39;Whatever.&#39; to anything else.

## Instructions

Run the test file, and fix each of the errors in turn. When you get the first test to pass, go to the first pending or skipped test, and make that pass as well. When all of the tests are passing, feel free to submit. 

Remember that passing code is just the first step. The goal is to work towards a solution that is as readable and expressive as you can make it. 

Please make your solution as general as possible. Good code doesn&#39;t just pass the test suite, it works with any input that fits the specification.

Have fun!

## Source

Inspired by the &#39;Deaf Grandma&#39; exercise in Chris Pine&#39;s Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run the test file change into the exercise directory and use prove:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cd perl5/bob
$ prove bob.t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That will get this output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;bob.t .. 1/22 Bailout called.  Further testing stopped:  You need to create a module called Bob.pm with a function called hey() that gets one parameter: The text Bob hears.

#   Failed test &#39;missing Bob.pm&#39;
#   at bob.t line 37.
FAILED--Further testing stopped: You need to create a module called Bob.pm with a function called hey() that gets one parameter: The text Bob hears.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s create a basic Bob.pm module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Bob;
use warnings;
use strict;

sub hey {
    my $input = shift;
}

1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a shell of the solution. Our &amp;ldquo;hey&amp;rdquo; subroutine returns the first input it receives. Re-running prove, we get this output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ prove bob.t
bob.t .. 1/22 
#   Failed test &#39;stating something: Tom-ay-to, tom-aaaah-to.&#39;
#   at bob.t line 52.
#          got: &#39;Tom-ay-to, tom-aaaah-to.&#39;
#     expected: &#39;Whatever.&#39;

...

# Looks like you failed 19 tests of 22.
bob.t .. Dubious, test returned 19 (wstat 4864, 0x1300)
Failed 19/22 subtests 

Test Summary Report
-------------------
bob.t (Wstat: 4864 Tests: 22 Failed: 19)
  Failed tests:  4-22
  Non-zero exit status: 19
Files=1, Tests=22,  1 wallclock secs ( 0.02 usr  0.00 sys +  0.04 cusr  0.00 csys =  0.06 CPU)
Result: FAIL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that Bailout is no longer being called, so our basic module passed the first few tests, but failed 19 of 22. I&amp;rsquo;ve abbreviated the output to show only the first failing test. The output tells us everything we need to know: our &amp;ldquo;hey&amp;rdquo; subroutine did not return the content required by the spec. I&amp;rsquo;ll leave the exercise here - if you&amp;rsquo;re feeling suitably inspired see if you can complete it.&lt;/p&gt;

&lt;h3 id=&#34;help-represent-perl:b8fc90b81a72b2595146025a61f1ef5d&#34;&gt;Help represent Perl&lt;/h3&gt;

&lt;p&gt;One of the exercism&amp;rsquo;s strengths is it has the same programming exercises in different programming languages, so you can develop your polyglot skills. Looking at the &lt;a href=&#34;https://github.com/exercism&#34;&gt;source&lt;/a&gt;, it appears that JavaScript, Python, Ruby and Haskell are leading the pack with about 55 exercises available each. Perl is well-represented with 36 exercises and the other languages have about 20 or fewer.&lt;/p&gt;

&lt;p&gt;This week I ported a couple of the missing exercises to the Perl &lt;a href=&#34;https://github.com/exercism/xperl5&#34;&gt;repo&lt;/a&gt;. To port a missing exercise you have to provide the test file and module solution. This is easier than it sounds as you can just translate the exercise code from another language into Perl. Across all the languages there are about 80 different exercises. I&amp;rsquo;ve created a &lt;a href=&#34;https://questhub.io/realm/perl/quest/53795a10bbd0be180400014f&#34;&gt;quest&lt;/a&gt; which lists the missing exercises.&lt;/p&gt;

&lt;p&gt;It only take about 30 minutes to port one exercise: if 2% of the readers of this article port one exercise each today, Perl will immediately have more exercises than any other language. There is also an empty Perl 6 &lt;a href=&#34;https://github.com/exercism/xperl6&#34;&gt;repo&lt;/a&gt;; porting the Perl 5 exercises to Perl 6 could make for a juicy hackathon target.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:b8fc90b81a72b2595146025a61f1ef5d&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Playing with exercism has been loads of fun and I&amp;rsquo;ve learned a few Perl tricks (hah!) along the way. The source is MIT licensed and the committers are friendly. It would be great to see more Perlers participating or porting an exercise or too. Feel free to clone or or stencil the &lt;a href=&#34;https://questhub.io/realm/perl/quest/53795a10bbd0be180400014f&#34;&gt;quest&lt;/a&gt;. Let&amp;rsquo;s show people what our language can do!&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F90%2F2014%2F5%2F18%2FBecome-a-better-programmer-with-exercism-io&amp;amp;text=Become+a+better+programmer+with+exercism.io&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F90%2F2014%2F5%2F18%2FBecome-a-better-programmer-with-exercism-io&amp;amp;via=perltricks&#34;&gt;tweet&lt;/a&gt; about it!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The ultimate guide to Windows and Unix file line ending conversion in Perl </title>
      <link>http://perltricks.com/article/53/2013/12/14/The-ultimate-guide-to-Windows-and-Unix-file-line-ending-conversion-in-Perl-/</link>
      <pubDate>Sat, 14 Dec 2013 21:13:28 +0000</pubDate>
      
      <guid>http://perltricks.com/article/53/2013/12/14/The-ultimate-guide-to-Windows-and-Unix-file-line-ending-conversion-in-Perl-/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Most programmers know that the file line endings used by Windows and Unix-based systems are different. Windows uses CRLF and the Unix-based systems use LF. So fixing this is in Perl requires a simple substitution regex right? Not so fast &amp;hellip;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;requirements:702a2a2b148525e915fdb1399d13703a&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;You must be using Perl version 5.14 or greater.&lt;/p&gt;

&lt;h3 id=&#34;conversion-on-unix-based-systems:702a2a2b148525e915fdb1399d13703a&#34;&gt;Conversion on Unix-based systems&lt;/h3&gt;

&lt;p&gt;These are easy. To convert a file to Unix-style line endings (as used by Linux, BSD, OSX) just open up the terminal and run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;perl -pi.bak -e &#39;s/\R/\012/&#39; /path/to/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code works by replacing any line break characters (&amp;rdquo;\R&amp;rdquo;) with a single line feed character (&amp;rdquo;\012&amp;rdquo;). The &amp;ldquo;\R&amp;rdquo; meta-character is available in Perl from version 5.10 onwards, it&amp;rsquo;s useful because it will even work for files with mixed line ending styles. The in-place switch (&amp;ldquo;i&amp;rdquo;) creates a backup of the original file with the extension &amp;ldquo;.bak&amp;rdquo;. To convert a file from Unix to Windows-style line endings, use this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;perl -pi.bak -e &#39;s/\R/\015\012/&#39; /path/to/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This replaces any vertical character with the CRLF (&amp;rdquo;\015\012&amp;rdquo;) line ending used by Windows. Again, this will also work for files with a mix of Unix and Windows line endings.&lt;/p&gt;

&lt;h3 id=&#34;conversion-on-windows:702a2a2b148525e915fdb1399d13703a&#34;&gt;Conversion on Windows&lt;/h3&gt;

&lt;p&gt;Things are trickier on Windows; there are a few things to be aware of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;By default Perl changes the value of &amp;ldquo;\n&amp;rdquo; to CRLF. This means that the regex match: &amp;ldquo;/\015\012/&amp;rdquo; will fail on Windows as Perl is actually running: &amp;ldquo;/\015\015\012/&amp;ldquo;. Regexes using meta-characters and hex codes (&amp;rdquo;/\r\n/&amp;rdquo; and &amp;ldquo;/\x0d\x0a/&amp;ldquo;) fail for the same reason.&lt;/li&gt;
&lt;li&gt;Single-quotes must be replaced with double-quotes to enclose the code in &amp;ldquo;e&amp;rdquo; and quoting operators must be used when single quotes are required within the code (e.g. &amp;ldquo;q||&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;The in-place switch (&amp;ldquo;i&amp;rdquo;) works, but any extension (e.g. &amp;ldquo;.bak&amp;rdquo;) will change the file ending and the default programs associated with it. The examples below use alternative methods.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you&amp;rsquo;re using cmd.exe or PowerShell the following Perl one liner will convert a file to Windows-style line endings:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;perl -pe &amp;quot;binmode(STDOUT);s/\R/\015\012/&amp;quot; /path/to/file &amp;gt; /path/to/new/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main differences here are: replacing single-quotes with double-quotes, &amp;ldquo;binmode(STDOUT)&amp;rdquo; to turn off Perl&amp;rsquo;s CRLF line endings and the use of redirect &amp;ldquo;&amp;gt;&amp;rdquo; to write the contents to a different file, instead of using the in-place switch. To convert a file to Unix-style line endings on cmd.exe this will work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;perl -pe &amp;quot;binmode(STDOUT);s/\R/\012/&amp;quot; /path/to/file &amp;gt; /path/to/new/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On PowerShell a few more changes are required. To convert to Unix-style line endings use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;perl -ne &amp;quot;open(OUT, q(&amp;gt;&amp;gt;), q(/path/to/new/file));binmode(OUT);print OUT s/\R/\012/r&amp;quot; /path/to/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what just happened there? First of all we changed the command line switch &amp;ldquo;p&amp;rdquo; to &amp;ldquo;n&amp;rdquo;. This stops Perl from printing every line it processes to standard output. Instead we opened an appending filehandle &amp;ldquo;OUT&amp;rdquo; to our output file and printed the result ourselves. The reason we had to do this was that PowerShell automatically interprets standard output as Unicode and replaces Unix-style endings with Windows CRLF endings. Hence using the re-direct method (&amp;rdquo;&amp;gt;&amp;rdquo;) does not work. And before you try, piping the output like this generates an error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;perl -pe &amp;quot;binmode(STDOUT);s/\R/\012/r&amp;quot; /path/to/file | set-content /path/to/new/file -Encoding Byte
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also had to use the quoting operator (&amp;ldquo;q()&amp;rdquo;) to quote our content instead of using single quotes. Finally, the substitution regex (&amp;ldquo;s/\R/\012/&amp;ldquo;) was changed to use the &amp;ldquo;r&amp;rdquo; modifier, which returns the result of the substitution without modifying the original variable. This feature is available from Perl version 5.14 onwards.&lt;/p&gt;

&lt;h3 id=&#34;further-reading:702a2a2b148525e915fdb1399d13703a&#34;&gt;Further Reading&lt;/h3&gt;

&lt;p&gt;Perl&amp;rsquo;s offical documentation &amp;ldquo;perlrun&amp;rdquo; entry has a lot of detail on Perl&amp;rsquo;s command line switches. Access it &lt;a href=&#34;http://perldoc.perl.org/perlrun.html&#34;&gt;online&lt;/a&gt; or at the command line by typing: &amp;ldquo;perldoc perlrun&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Peteris Krummins&amp;rsquo; &lt;a href=&#34;http://www.catonmat.net/&#34;&gt;website&lt;/a&gt; provides loads of Perl one liners. His new book &lt;a href=&#34;http://www.amazon.com/gp/product/159327520X/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=159327520X&amp;amp;linkCode=as2&amp;amp;tag=perltrickscom-20&#34;&gt;Perl One-Liners: 130 Programs That Get Things Done&lt;/a&gt; has just been published (affiliate link). It contains many useful one liners, but also 9 pages of detailed guidance on running one liners on Windows - highly recommended!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to redirect and restore STDOUT</title>
      <link>http://perltricks.com/article/45/2013/10/27/How-to-redirect-and-restore-STDOUT/</link>
      <pubDate>Sun, 27 Oct 2013 17:48:34 +0000</pubDate>
      
      <guid>http://perltricks.com/article/45/2013/10/27/How-to-redirect-and-restore-STDOUT/</guid>
      <description>

&lt;p&gt;STDOUT is the Perl filehandle for printing standard output. Unless a filehandle is specified, all standard printed output in Perl will go to the terminal. Because STDOUT is just a global variable, it can be redirected and restored. Want to implement logging on a program without changing every print statement in the source code? Want to capture the standard output of a perl CRON job? Read on.&lt;/p&gt;

&lt;h3 id=&#34;terminal-redirects:9e03003b05f671fa59d2fc87f91ddfba&#34;&gt;Terminal redirects&lt;/h3&gt;

&lt;p&gt;Before you launch your favourite text editor and start hacking Perl code, you may just need to redirect the program output in the terminal. On UNIX-based systems you can write to a file using &amp;ldquo;&amp;gt;&amp;rdquo; and append to a file using &amp;ldquo;&amp;gt;&amp;gt;&amp;rdquo;. Both write and append will create the file if it doesn&amp;rsquo;t exist.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;perl program.pl &amp;gt; /path/to/log.txt
perl program.pl &amp;gt;&amp;gt; /path/to/log.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On Windows a similar effect can be achieved using PowerShell using a pipe operator (&amp;ldquo;|&amp;rdquo;) and &amp;ldquo;set-content&amp;rdquo; to write, or &amp;ldquo;add-content&amp;rdquo; to append (the pipe will not redirect STDERR).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;perl program.pl | set-content /path/to/log.txt
perl program.pl | add-content /path/to/log.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;perl-solutions:9e03003b05f671fa59d2fc87f91ddfba&#34;&gt;Perl solutions&lt;/h3&gt;

&lt;p&gt;If a terminal redirect is not specific enough for your needs, you can use one of the following Perl solutions. All of the following solutions use &lt;a href=&#34;https://metacpan.org/pod/autodie&#34;&gt;autodie&lt;/a&gt; which removes the need for the classic &amp;ldquo;|| or die $!&amp;rdquo; syntax to be appended to every open statement in the code.&lt;/p&gt;

&lt;h3 id=&#34;redirect-stdout-using-select:9e03003b05f671fa59d2fc87f91ddfba&#34;&gt;Redirect STDOUT using select&lt;/h3&gt;

&lt;p&gt;Perl&amp;rsquo;s built-in function &lt;a href=&#34;http://perldoc.perl.org/functions/select.html&#34;&gt;select&lt;/a&gt; changes the standard output filehandle to the filehandle provided as an argument. This makes it easy to globally redirect and restore standard output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
use autodie;

# open filehandle log.txt
open (my $LOG, &#39;&amp;gt;&amp;gt;&#39;, &#39;log.txt&#39;);

# select new filehandle
select $LOG;

say &#39;This should be logged.&#39;;

# restore STDOUT
select STDOUT;

say &#39;This should show in the terminal&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;redirect-stdout-using-local:9e03003b05f671fa59d2fc87f91ddfba&#34;&gt;Redirect STDOUT using local&lt;/h3&gt;

&lt;p&gt;Perl&amp;rsquo;s &lt;a href=&#34;http://perldoc.perl.org/functions/local.html&#34;&gt;local&lt;/a&gt; built-in function is another option for redirecting STDOUT. The local function creates a lexically-scoped copy of any variable passed to it. By enclosing local in a do block, the code below limits the STDOUT redirect to the block scope and STDOUT is automatically restored after the closing block brace (&amp;ldquo;}&amp;rdquo;). By definition this is not a global solution for redirecting STDOUT.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
use autodie;

do {
    local *STDOUT;

    # redirect STDOUT to log.txt
    open (STDOUT, &#39;&amp;gt;&amp;gt;&#39;, &#39;log.txt&#39;);

    say &#39;This should be logged.&#39;;
};
say &#39;This should show in the terminal&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;redirect-stdout-using-a-filehandle:9e03003b05f671fa59d2fc87f91ddfba&#34;&gt;Redirect STDOUT using a filehandle&lt;/h3&gt;

&lt;p&gt;A third way to redirect and restore STDOUT is to copy the STDOUT filehandle before replacing it. This copy can then be restored when required. As with select, this will have a global affect on the Perl program.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use feature qw/say/;
use autodie;

# copy STDOUT to another filehandle
open (my $STDOLD, &#39;&amp;gt;&amp;amp;&#39;, STDOUT);

# redirect STDOUT to log.txt
open (STDOUT, &#39;&amp;gt;&amp;gt;&#39;, &#39;log.txt&#39;);

say &#39;This should be logged.&#39;;

# restore STDOUT
open (STDOUT, &#39;&amp;gt;&amp;amp;&#39;, $STDOLD);

say &#39;This should show in the terminal&#39;;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Catch and Handle Signals in Perl</title>
      <link>http://perltricks.com/article/37/2013/8/18/Catch-and-Handle-Signals-in-Perl/</link>
      <pubDate>Sun, 18 Aug 2013 18:48:51 +0000</pubDate>
      
      <guid>http://perltricks.com/article/37/2013/8/18/Catch-and-Handle-Signals-in-Perl/</guid>
      <description>

&lt;p&gt;Signals are types of messages sent by an operating system to a process such as a Perl program. Signals provide a method for communicating with a process, for example when running a command line program pressing control-c will send the interrupt signal (&amp;lsquo;SIGINT&amp;rsquo;) to the program by default terminating it. Signals are often unexpected and if not handled can leave your Perl program or data in an unfinished state. This article describes some useful Perl programming tools for gracefully handling signals.&lt;/p&gt;

&lt;h3 id=&#34;method-1-the-sig-hash:7909a2df78dbcc2767753affaca8b750&#34;&gt;Method 1: The %SIG Hash&lt;/h3&gt;

&lt;p&gt;All Perl programs have the global variable %SIG hash which contains keys corresponding to each signal type. When a signal is sent to a Perl program, the value of the matching key name in %SIG is automatically de-referenced. This makes it possible to assign code references to handle specific signals by adding a coderef to the signal&amp;rsquo;s key value in %SIG. Let&amp;rsquo;s use an example Perl script called sleeper.pl to demonstrate. All sleeper.pl does is sleep for 20 seconds:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;

sleep(20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s update sleeper.pl to handle an interrupt signal using %SIG:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;

$SIG{INT} = sub { die &amp;quot;Caught a sigint $!&amp;quot; };

sleep(20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run sleeper.pl on the command line and press control-c to send a SIGINT to it, we can see the our code ref was executed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;perl sleeper.pl
^CCaught a sig int Interrupted system call at projects/scripts/sleeper.pl line 4.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By updating the various key-value pairs in %SIG it&amp;rsquo;s possible to handle specific signals, for example we can update sleeper.pl to handle a terminate signal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;

$SIG{INT} = sub { die &amp;quot;Caught a sigint $!&amp;quot; };
$SIG{TERM} = sub { die &amp;quot;Caught a sigterm $!&amp;quot; };

sleep(20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s often easier to define a signal handling subroutine rather than using anonymous subroutines for every signal you wish to catch. Let&amp;rsquo;s update sleeper.pl accordingly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;

$SIG{INT}  = \&amp;amp;signal_handler;
$SIG{TERM} = \&amp;amp;signal_handler;

sleep(20);

sub signal_handler {
    die &amp;quot;Caught a signal $!&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the signal_handler subroutine will be called everytime sleeper.pl receives a SIGINT or SIGTERM signal. Using these techniques it&amp;rsquo;s possible to extend signal-handling behavior for all signals that you wish to be handled.&lt;/p&gt;

&lt;h3 id=&#34;method-2-sigtrap:7909a2df78dbcc2767753affaca8b750&#34;&gt;Method 2: sigtrap&lt;/h3&gt;

&lt;p&gt;sigtrap is a useful Perl pragma that makes handling signals easier than manipulating %SIG directly. The sigtrap pragma recognizes three groups of signals: normal-signals (HUP, PIPE, INT, TERM), error-signals (ABRT, BUS, EMT, FPE, ILL, QUIT, SEGV, SYS and TRAP) and old-interface-signals (ABRT, BUS, EMT, FPE, ILL, PIPE, QUIT, SEGV, SYS, TERM, and TRAP). Using sigtrap we can update sleeper.pl to die when any of the normal-signals are received:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use sigtrap qw/die normal-signals/;

sleep(20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of calling die we can have sigtrap call the signal_handler routine that we defined previously:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use sigtrap qw/handler signal_handler normal-signals/;

sleep(20);

sub signal_handler {
    die &amp;quot;Caught a signal $!&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a lot more to sigtrap, check out the &lt;a href=&#34;http://perldoc.perl.org/sigtrap.html&#34;&gt;sigtrap perldoc entry&lt;/a&gt; for more details about its functionality.&lt;/p&gt;

&lt;h3 id=&#34;useful-signal-handling-behavior:7909a2df78dbcc2767753affaca8b750&#34;&gt;Useful signal handling behavior&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s common to call die when handling SIGINT and SIGTERM. die is useful because it will ensure that Perl stops correctly: for example Perl will execute a destructor method if present when die is called, but the destructor method will not be called if a SIGINT or SIGTERM is received and no signal handler calls die. Additional behaviors that are useful in a signal handling subroutine are stack tracing, event logging, thread termination and temporary file clean up. The correct behavior to define will depend on the type of signal received and the type of Perl program.&lt;/p&gt;

&lt;h3 id=&#34;posix-signals:7909a2df78dbcc2767753affaca8b750&#34;&gt;POSIX signals&lt;/h3&gt;

&lt;p&gt;Not every signal can be handled: on POSIX compliant systems (such as BSD, Linux and OSX) SIGSTOP and SIGKILL cannot be caught, blocked or ignored. See the &lt;a href=&#34;http://man7.org/linux/man-pages/man7/signal.7.html&#34;&gt;signal man page&lt;/a&gt; for further details. Not every signal needs to be handled - each signal has a default program behavior (disposition) which may not affect the running of the program (also defined on the man page). You can find a list of signals Perl recognizes by printing %SIG at the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;perl -e &#39;foreach (keys %SIG) { print &amp;quot;$_\n&amp;quot; }&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;windows-signals:7909a2df78dbcc2767753affaca8b750&#34;&gt;Windows signals&lt;/h3&gt;

&lt;p&gt;Windows implements a subset of the standard POSIX signals. These signals can still be handled using the techniques described above. Microsoft have provided a list of these signals on &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms811896#ucmgch09_topic3&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Test if the user is root</title>
      <link>http://perltricks.com/article/16/2013/4/10/Test-if-the-user-is-root/</link>
      <pubDate>Wed, 10 Apr 2013 21:48:42 +0000</pubDate>
      
      <guid>http://perltricks.com/article/16/2013/4/10/Test-if-the-user-is-root/</guid>
      <description>&lt;p&gt;When Perl is executing a program, it maintains the user id of the process owner in a global variable ($&amp;lt;). When a Perl program is executed by root or a user with root privileges (e.g. using the sudo command), the user id variable is always set to zero. This can be checked at the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl -e &#39;print $&amp;lt; . \n;&#39;
1000
$ sudo perl -e &#39;print $&amp;lt; . \n;&#39;
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because the root user id is always zero and in Perl zero is treated as false, it is a trivial task to test if the user is root during runtime. This can be used to for flow control, such as exiting the program early:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Carp qw/croak/;

if ($&amp;lt;) {
    croak &amp;quot;Error: exiting program as not executed by root\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Windows the user id variable is always set to zero and is of limited use. However the Perl &lt;a href=&#34;https://metacpan.org/module/Win32&#34;&gt;Win32&lt;/a&gt; module has the Win32::IsAdminUser() method that can be used instead of $&amp;lt;, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Win32;
use Carp qw/croak/;

if (not Win32::IsAdminUser()) {
    croak &amp;quot;Error: exiting program as not executed by root\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>

