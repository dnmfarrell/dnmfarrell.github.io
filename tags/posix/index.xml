<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>posix on Code Matters - a tech blog</title>
    <link>https://blog.dnmfarrell.com/tags/posix/</link>
    <description>Recent content in posix on Code Matters - a tech blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Nov 2021 09:03:41 -0500</lastBuildDate><atom:link href="https://blog.dnmfarrell.com/tags/posix/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to Split a String in POSIX Shell</title>
      <link>https://blog.dnmfarrell.com/post/how-to-split-a-string-in-posix-shell/</link>
      <pubDate>Fri, 12 Nov 2021 09:03:41 -0500</pubDate>
      
      <guid>https://blog.dnmfarrell.com/post/how-to-split-a-string-in-posix-shell/</guid>
      <description>The POSIX Shell specification defines a minimalist shell language with few features compared to stalwarts like Bash. Yet POSIX shells are everywhere: Dash is the default on Ubuntu, and many Docker containers only have busybox ash. Minimalist shells use little resources and are faster than featureful shells like Bash and ZshÂ¹. They are more likely to be secure too, as the reduced feature sets are easier to reason about and provide a smaller attack surface for hackers.</description>
    </item>
    
    <item>
      <title>Unit Testing Shell Scripts</title>
      <link>https://blog.dnmfarrell.com/post/unit-testing-shell-scripts/</link>
      <pubDate>Fri, 16 Jul 2021 09:32:50 -0400</pubDate>
      
      <guid>https://blog.dnmfarrell.com/post/unit-testing-shell-scripts/</guid>
      <description>Unit testing is great way to build confidence that your code works. Usually you&amp;rsquo;d write unit tests for libraries; but if you have a particularly long or complicated shell script, it might be worth converting it to a modulino just so you can write tests for it. And if you are writing a library in shell code, you need all the help you can get anyway.
So let&amp;rsquo;s assume you have some shell code to test, now what?</description>
    </item>
    
    <item>
      <title>Bash Function Names Can Be Almost Anything</title>
      <link>https://blog.dnmfarrell.com/post/bash-function-names-can-be-almost-anything/</link>
      <pubDate>Sun, 20 Jun 2021 20:19:32 -0400</pubDate>
      
      <guid>https://blog.dnmfarrell.com/post/bash-function-names-can-be-almost-anything/</guid>
      <description>A common misconception about Bash is that function names must follow the same rules that variables do. The Bash manual even suggests this:
 A word consisting solely of letters, numbers, and underscores, and beginning with a letter or underscore. Names are used as shell variable and function names. Also referred to as an identifier.
 In fact Bash function names can be almost any printable character. For instance I can define my own pre-increment unary function:</description>
    </item>
    
    <item>
      <title>Three Ways to Get a Unix Epoch in Bash</title>
      <link>https://blog.dnmfarrell.com/post/three-ways-to-get-a-unix-epoch-in-bash/</link>
      <pubDate>Sun, 13 Jun 2021 11:34:50 -0400</pubDate>
      
      <guid>https://blog.dnmfarrell.com/post/three-ways-to-get-a-unix-epoch-in-bash/</guid>
      <description>The Unix epoch time is the number of elapsed seconds since January 1st, 1970. Epoch times are handy because they&amp;rsquo;re not subject to timezone offsets, and they&amp;rsquo;re numbers, unlike ISO 8601 timestamps for example (&amp;ldquo;1970-01-01T00:00:00Z&amp;rdquo;). That makes them memory efficient, and more importantly, easy to do math with.
Here are three ways to get the epoch time in Bash.
Use Date You can use the date program to generate the epoch time by providing the %s formatting argument.</description>
    </item>
    
  </channel>
</rss>
