<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cpan on Perl programming news, code and culture</title>
    <link>http://perltricks.com/tags/cpan/</link>
    <description>Recent content in Cpan on Perl programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Mar 2016 10:04:57 +0000</lastBuildDate>
    <atom:link href="http://perltricks.com/tags/cpan/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>What is the Perl Core?</title>
      <link>http://perltricks.com/article/what-is-the-perl-core-/</link>
      <pubDate>Wed, 09 Mar 2016 10:04:57 +0000</pubDate>
      
      <guid>http://perltricks.com/article/what-is-the-perl-core-/</guid>
      <description>

&lt;p&gt;When I use the term &amp;ldquo;Perl Core&amp;rdquo; I mean the standard library of modules (distributions actually) that ship with the &lt;code&gt;perl&lt;/code&gt; interpreter, and I think that&amp;rsquo;s what most people mean when they use that term. Knowing which modules are in the Perl Core is useful; it enables developers to build programs without external dependencies over which the developer has little control. The perldoc site has a handy alphabetized &lt;a href=&#34;http://perldoc.perl.org/index-modules-A.html&#34;&gt;list&lt;/a&gt; of core modules and I generally check there first to browse which modules are in core. The problem though, is that it can be wrong.&lt;/p&gt;

&lt;h3 id=&#34;what-modules-are-included-in-the-perl-core:0d5c2e3cd089b0cf6cb0dbe47d066eb1&#34;&gt;What modules are included in the Perl Core?&lt;/h3&gt;

&lt;p&gt;Did you know that &lt;a href=&#34;http://metacpan.org/pod/HTTP::Tiny&#34;&gt;HTTP::Tiny&lt;/a&gt; has shipped with Perl since 2011 (version 5.14.0)? It&amp;rsquo;s not listed on &lt;a href=&#34;http://perldoc.perl.org&#34;&gt;perldoc&lt;/a&gt; (although that is on the list to be fixed at the next &lt;a href=&#34;http://act.qa-hackathon.org/qa2016/&#34;&gt;QA Hackathon&lt;/a&gt;). Luckily there is a better solution: the &lt;code&gt;corelist&lt;/code&gt; program. This is supplied with &lt;a href=&#34;https://metacpan.org/pod/Module::CoreList/&#34;&gt;Module::CoreList&lt;/a&gt;. Let&amp;rsquo;s see when Module::CoreList first shipped with Perl:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ corelist -a Module::CoreList

Data for 2015-06-01
Module::CoreList was first released with perl v5.8.9
  v5.8.9     2.17
  v5.9.2     1.99
  v5.9.3     2.02
  v5.9.4     2.08
  v5.9.5     2.12
  v5.10.0    2.13
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve truncated the output and kept the key details. It shows that Module::CoreList has been included since Perl version 5.8.9. At home I run Fedora 23, which comes with Perl version 5.22.1. Running the system Perl &lt;code&gt;corelist&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo corelist -a Module::CoreList
sudo: corelist: command not found
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The program doesn&amp;rsquo;t exist; the Fedora team didn&amp;rsquo;t include it for some reason. Not only that, but great core modules like &lt;a href=&#34;http://perltricks.com/article/59/2014/1/10/Solve-almost-any-datetime-need-with-Time--Piece/&#34;&gt;Time::Piece&lt;/a&gt; aren&amp;rsquo;t included either!&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t have &lt;code&gt;corelist&lt;/code&gt;, but want to view a list of distributions that &lt;em&gt;should&lt;/em&gt; have been bundled with your version of Perl, you can read &lt;code&gt;perldoc perlmodlib&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;which-modules-do-i-have:0d5c2e3cd089b0cf6cb0dbe47d066eb1&#34;&gt;Which modules do I have?&lt;/h3&gt;

&lt;p&gt;Sometimes instead of asking which modules are in the Perl Core what we really mean is: &amp;ldquo;which modules do I have installed?&amp;rdquo; For non-core modules, I use &lt;a href=&#34;http://perltricks.com/article/14/2013/4/7/List-all-Perl-modules-installed-via-CPAN/&#34;&gt;perldoc&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;perldoc&lt;/code&gt; won&amp;rsquo;t show us the core modules that we already have, and in the case of missing core modules, Module::CoreList can&amp;rsquo;t help either (its results are based on internal lists of modules that &lt;em&gt;should&lt;/em&gt; be there, not which files are actually present). A simple way I handle this is to use the following script to search the contents of &lt;code&gt;@INC&lt;/code&gt;; the directories which &lt;code&gt;perl&lt;/code&gt; searches for modules:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;#!/usr/bin/env perl
use 5.10.3;
use Path::Tiny &#39;path&#39;;
use Getopt::Long &#39;GetOptions&#39;;

GetOptions(
  &#39;dir=s&#39; =&amp;gt; \my $dirpath,
) or die &amp;quot;Unrecognized option\n&amp;quot;;
die &amp;quot;--dir is required\n&amp;quot; unless $dirpath &amp;amp;&amp;amp; -d $dirpath;

# append a slash if missing
$dirpath .= &#39;/&#39; unless substr($dirpath, -1) eq &#39;/&#39;;

my $iter = path($dirpath)-&amp;gt;iterator({recurse =&amp;gt; 1});
while (my $path = $iter-&amp;gt;()) {
  next unless &amp;quot;$path&amp;quot; =~ qr/.pm$/;
  # remove the parent dir and trailing .pm from filename
  my $module = substr(&amp;quot;$path&amp;quot;, length($dirpath), length(&amp;quot;$path&amp;quot;)-length($dirpath)-3);
  $module =~ s/\//::/g;
  say $module;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I run it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod 755 list_modules
$ /usr/bin/perl -e &#39;for(@INC){ system &amp;quot;./list_modules -d $_&amp;quot; }&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m using the absolute path &lt;code&gt;/usr/bin/perl&lt;/code&gt; to ensure I get my system&amp;rsquo;s &lt;code&gt;perl&lt;/code&gt; and not the local one I manage with &lt;a href=&#34;https://github.com/tokuhirom/plenv&#34;&gt;plenv&lt;/a&gt;. One downside of this approach is it lists every module (&lt;code&gt;.pm&lt;/code&gt; file) rather than every distribution, (see this &lt;a href=&#34;http://perltricks.com/article/96/2014/6/13/Perl-distributions--modules--packages-explained/&#34;&gt;explanation&lt;/a&gt; if you&amp;rsquo;re not familiar with the distinction). Another issue is it will list duplicate modules when the system uses symlinks. So the program output needs to be tidied up in a text editor.&lt;/p&gt;

&lt;p&gt;What about programs? To search for Perl programs I prepared a list of Perl programs from the source for Perl 5.22, called &lt;code&gt;perl522_programs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c2ph
corelist
cpan
enc2xs
encguess
h2ph
h2xs
instmodsh
json_pp
libnetcfg
perl
perl5.22.1
perlbug
perldoc
perlivp
perlthanks
piconv
pl2pm
pod2html
pod2man
pod2text
pod2usage
podchecker
podselect
prove
pstruct
ptar
ptardiff
ptargrep
shasum
splain
xsubpp
zipdetails
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I used the following script, called &lt;code&gt;find_binary&lt;/code&gt; to check for the programs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;#!/usr/bin/perl
my $bin = shift or die &amp;quot;You must provide a binary name to search for\n&amp;quot;;

for ( qw(/sbin /bin /usr/sbin /usr/bin) )
{
  my $path = &amp;quot;$_/$bin&amp;quot;;
  print &amp;quot;$path\n&amp;quot; if -e $path;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I run it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chmod 755 find_binary
$ perl -ne &#39;chomp;system &amp;quot;./find_binary $_&amp;quot;&#39; perl522_programs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This line calls the &lt;code&gt;find_binary&lt;/code&gt; script on every program listed in the file &lt;code&gt;perl522_programs&lt;/code&gt;. I &lt;code&gt;chomp&lt;/code&gt; the line before searching for it to remove the trailing newline character. This method isn&amp;rsquo;t perfect though; sneaky Ubuntu ships with a program called &lt;code&gt;perldoc&lt;/code&gt; but if you run it the system prints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;You need to install the perl-doc package to use this program.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;core-modules-and-programs-missing-from-system-perls:0d5c2e3cd089b0cf6cb0dbe47d066eb1&#34;&gt;Core modules and programs missing from system perls&lt;/h3&gt;

&lt;p&gt;Using the code above I did a comparison of the modules and programs shipped with Perl and those shipped with the following systems. Here&amp;rsquo;s what missing:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Fedora 23&lt;/th&gt;
&lt;th&gt;Ubuntu 14.04 LTS&lt;/th&gt;
&lt;th&gt;OSX Yosemite 10.10.5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;B::Debug&lt;/td&gt;
&lt;td&gt;CGI::Fast&lt;/td&gt;
&lt;td&gt;GDBM_File&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Config::Perl::V&lt;/td&gt;
&lt;td&gt;ODBM_File&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CPANPLUS&lt;/td&gt;
&lt;td&gt;perldoc&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DB_File&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Devel::PPPort&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ExtUtils::Embed&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ExtUtils::MakeMaker::Locale&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ExtUtils::Miniperl&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;File::Fetch&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;File::Spec::VMS&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Filter::Simple&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;IO::Compress::Adapter::Bzip2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;IO::Uncompress::Adapter::Bunzip2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Math::BigFloat&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Math::BigInt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Math::BigRat&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Math::Complex&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Math::Trig&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Module::Loaded&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PerlIO&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Text::Balanced&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Time::Piece&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Time::Seconds&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Unicode::Collate&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;autodie&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bigint&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bignum&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;bigrat&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;experimental&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;perlfaq&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;corelist&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;enc2xs&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;libnetcfg&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Ubuntu and OSX ship with Perl 5.18 so I looked for missing programs and modules against the 5.18 source code. For Fedora I compared the system &lt;code&gt;perl&lt;/code&gt; against the 5.22 source. These results show that Fedora is missing quite a few modules and programs: experimental, corelist, autodie, the Math:: modules and Time::Piece strike me as significant omissions (they are supplied by the &lt;code&gt;perl-core&lt;/code&gt; package, which is must be installed separately). For Ubuntu, excluding &lt;code&gt;perldoc&lt;/code&gt; is a &lt;a href=&#34;http://perltricks.com/article/155/2015/2/26/Hello-perldoc--productivity-booster/&#34;&gt;real shame&lt;/a&gt;. OSX came away gleaming though: nearly all core modules and programs were present.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:0d5c2e3cd089b0cf6cb0dbe47d066eb1&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;When writing programs that use core Perl modules be careful, especially if you&amp;rsquo;re using any of the modules or programs found to be missing earlier. One way around this is the use &lt;a href=&#34;https://metacpan.org/pod/App::FatPacker&#34;&gt;App::FatPacker&lt;/a&gt; to compile all the modules used into a single file. Another way would be to use &lt;a href=&#34;https://metacpan.org/pod/pp&#34;&gt;pp&lt;/a&gt; to create a compiled binary. Finally for modules like Time::Piece, you could always consider wrapping Perl&amp;rsquo;s built-in functions like &lt;code&gt;gmtime&lt;/code&gt; and &lt;code&gt;localtime&lt;/code&gt; in subroutines that give the behavior you need, rather than using the module.&lt;/p&gt;

&lt;p&gt;Of course it&amp;rsquo;s always easier to work with a locally-installed &lt;code&gt;perl&lt;/code&gt; than the system version. The local Perls provided by &lt;a href=&#34;http://perlbrew.pl&#34;&gt;perlbrew&lt;/a&gt; and &lt;a href=&#34;https://github.com/tokuhirom/plenv&#34;&gt;plenv&lt;/a&gt; contain all the core modules and utilities. You can always &lt;a href=&#34;http://perlmaven.com/how-to-build-perl-from-source-code&#34;&gt;compile&lt;/a&gt; your own Perl too, it&amp;rsquo;s easy. &lt;a href=&#34;http://www.strawberryperl.com&#34;&gt;Strawberry Perl&lt;/a&gt; for Windows even comes with some useful extra modules and C libraries. If you do have to rely on the system Perl, you may find a core module isn&amp;rsquo;t there at all.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Updates&lt;/strong&gt; &lt;em&gt;Added reference to perl-core Fedora package, thanks to Grant McLean. 2016-03-21&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Modern Perl 4th edition, a review</title>
      <link>http://perltricks.com/article/205/2015/12/21/Modern-Perl-4th-edition--a-review/</link>
      <pubDate>Mon, 21 Dec 2015 00:02:25 +0000</pubDate>
      
      <guid>http://perltricks.com/article/205/2015/12/21/Modern-Perl-4th-edition--a-review/</guid>
      <description>

&lt;p&gt;The 4th edition of &lt;a href=&#34;https://pragprog.com/book/swperl/modern-perl-fourth-edition&#34;&gt;Modern Perl&lt;/a&gt; by chromatic is out. I was given an advance copy to review and the book features my praise quote, so I figured it was about time I wrote my notes up into a longer review. Overall I really like the changes to the new edition; in my opinion, Modern Perl continues to provide a valuable introduction to idiomatic Perl programming.&lt;/p&gt;

&lt;h3 id=&#34;learn-the-idiomatic-perl-style:1a23e64e513dff9cb8ce1f594e62a037&#34;&gt;Learn the idiomatic Perl style&lt;/h3&gt;

&lt;p&gt;Modern Perl isn&amp;rsquo;t like your typical dry programming book. For one thing, it&amp;rsquo;s opinionated. Author chromatic draws on his experience to provide an insiders&amp;rsquo; guide that shows the &lt;em&gt;right&lt;/em&gt; way to program in Perl.&lt;/p&gt;

&lt;p&gt;The text is fast-moving and doesn&amp;rsquo;t baby the reader. Instead of &amp;ldquo;hello World&amp;rdquo;, the book begins by teaching the reader how to use &lt;code&gt;perldoc&lt;/code&gt; and draw upon the official documentation when they get stuck. Don&amp;rsquo;t waste time with Google when the answer &lt;a href=&#34;http://perltricks.com/article/155/2015/2/26/Hello-perldoc--productivity-booster&#34;&gt;can be found in seconds&lt;/a&gt; at the command line.&lt;/p&gt;

&lt;p&gt;Chapters 1 and 2 introduce the Perl philosophy and Community. The book rapidly covers the major features of Perl (chapters 3 - 7) and even more advanced topics like recursion, anonymous functions and closures. Peppered throughout are gems of wisdom explaining the rationale behind a given concept. For instance, on including parentheses on all function calls (even ones without arguments):&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;While these parentheses are not strictly necessary for these examples—even with strict enabled—they provide clarity to human readers as well as Perl’s parser. When in doubt, use them.&lt;/p&gt;

&lt;p&gt;Modern Perl 4th edition, Chapter 5, Declaring Functions&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The focus here, though is on the practical and chromatic quickly moves on to advising on elements of good Perl style and how to learn it (chapter 8) and real-World programming tips (chapter 9). This is an honest, expert&amp;rsquo;s account of Perl, and chapter 11 describes what to avoid in Perl (chapter 5 also has an entry on function misfeatures).&lt;/p&gt;

&lt;p&gt;Whilst this is an introductory text, chromatic does find time to touch upon several intermediate concepts like taint, schwartzian transforms and tail call optimizations. There is something for everybody: re-reading the &lt;a href=&#34;http://modernperlbooks.com/books/modern_perl_2014/05-perl-functions.html#U3RhdGV2ZXJzdXNDbG9zdXJlcw&#34;&gt;section&lt;/a&gt; State-versus-Closures (chapter 5) I learned a nuance that I hadn&amp;rsquo;t appreciated before.&lt;/p&gt;

&lt;p&gt;Modern Perl does assume a lot and this could make it challenging for complete novices. For example the code snippets assume the reader can distinguish between command line and Perl programming context. Map and grep are used in examples but are not covered in the language overview chapters. But these are minor nits.&lt;/p&gt;

&lt;h3 id=&#34;modern-perl:1a23e64e513dff9cb8ce1f594e62a037&#34;&gt;&amp;ldquo;Modern&amp;rdquo; Perl?&lt;/h3&gt;

&lt;p&gt;About 10 years ago, Perl enjoyed something of a &lt;a href=&#34;http://www.modernperlbooks.com/mt/2009/07/milestones-in-the-perl-renaissance.html&#34;&gt;renaissance&lt;/a&gt; called &amp;ldquo;Modern Perl&amp;rdquo;. This was a movement that developed powerful new libraries, tools and applications which invigorated Perl programming and gave it a new lease-of-life. Today the phrase is almost synonymous with Perl &amp;ldquo;best practices&amp;rdquo; and its ethos continues to help Perl flourish.&lt;/p&gt;

&lt;h3 id=&#34;what-s-changed:1a23e64e513dff9cb8ce1f594e62a037&#34;&gt;What&amp;rsquo;s changed&lt;/h3&gt;

&lt;p&gt;The 4th edition brings a lot of changes, but it&amp;rsquo;s a case of evolution, not revolution. New Perl features like the double-diamond operator (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;) and &lt;a href=&#34;http://perltricks.com/article/72/2014/2/24/Perl-levels-up-with-native-subroutine-signatures&#34;&gt;subroutine signatures&lt;/a&gt; are covered. Almost every paragraph has been &lt;a href=&#34;https://github.com/chromatic/modern_perl_book/commits/master&#34;&gt;updated&lt;/a&gt;), but the chapter structure remains the same and many of the edits are tweaks rather than wholesale re-writes. Many of the changes improve the readability of the text, others de-jargonize it, like this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Functions are a prime mechanism for abstraction, encapsulation, and re-use in Perl.&lt;/p&gt;

&lt;p&gt;Modern Perl, 3rd Edition, Chapter 5&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;became:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Functions are a prime mechanism for organizing code into similar groups, identifying individual pieces by name, and providing reusable units of behavior.&lt;/p&gt;

&lt;p&gt;Modern Perl, 3rd Edition, Chapter 5&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Which is clearly easier for beginners to understand. Code-wise, many of the examples have changed from a BSD to K&amp;amp;R style, presumably to save vertical space. Overall the book length remains about the same (205 vs 204 pages).&lt;/p&gt;

&lt;p&gt;The biggest change with the new edition comes from The Pragmatic Bookshelf - their version is simply &lt;em&gt;gorgeous&lt;/em&gt;. Full color with larger fonts, icons and callouts, the book really pops. This is the layout Modern Perl needs &lt;em&gt;and&lt;/em&gt; deserves. See this comparison between the Onyx Neon and Pragmatic Bookshelf versions:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/205/comparison.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;alternatives:1a23e64e513dff9cb8ce1f594e62a037&#34;&gt;Alternatives&lt;/h3&gt;

&lt;p&gt;As an opinionated introduction to Perl, Modern Perl is a compromise between a tutorial and a best-practices style cookbook. I love the direction and terse writing style, but the book might move too fast for complete beginners. So it depends on what you&amp;rsquo;re looking for - &lt;a href=&#34;http://www.amazon.com/Beginning-Perl-Curtis-Poe/dp/1118013840&#34;&gt;Beginning Perl&lt;/a&gt; and &lt;a href=&#34;http://www.amazon.com/Learning-Perl-Randal-L-Schwartz/dp/1449303587&#34;&gt;Learning Perl&lt;/a&gt; are fine introductions to the language. &lt;a href=&#34;http://www.amazon.com/Effective-Perl-Programming-Idiomatic-Development/dp/0321496949&#34;&gt;Effective Perl Programming&lt;/a&gt; is my favorite Perl cookbook. But Modern Perl is a unique blend of both styles.&lt;/p&gt;

&lt;h3 id=&#34;where-to-get-it:1a23e64e513dff9cb8ce1f594e62a037&#34;&gt;Where to get it&lt;/h3&gt;

&lt;p&gt;You can read Modern Perl &lt;a href=&#34;http://modernperlbooks.com/books/modern_perl_2014/index.html&#34;&gt;online&lt;/a&gt; for free, and there are downloadable versions available from &lt;a href=&#34;http://onyxneon.com/books/modern_perl/index.html&#34;&gt;Onyx Neon&lt;/a&gt;. If you want it as an ebook, I would recommend the Pragmatic Bookshelf &lt;a href=&#34;https://pragprog.com/book/swperl/modern-perl-fourth-edition&#34;&gt;version&lt;/a&gt; - it&amp;rsquo;s beautifully styled, free, and you&amp;rsquo;ll be eligible for updates to the text as/when they appear.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Create GitHub files automatically with Dist::Zilla</title>
      <link>http://perltricks.com/article/203/2015/12/9/Create-GitHub-files-automatically-with-Dist--Zilla/</link>
      <pubDate>Wed, 09 Dec 2015 13:46:17 +0000</pubDate>
      
      <guid>http://perltricks.com/article/203/2015/12/9/Create-GitHub-files-automatically-with-Dist--Zilla/</guid>
      <description>

&lt;p&gt;I use &lt;a href=&#34;https://metacpan.org/pod/Dist::Zilla&#34;&gt;Dist::Zilla&lt;/a&gt; to release my code to CPAN. I really like it as with a single command I can build, package and ship a distribution. But most of my code lives on GitHub. In fact, a quick check shows that I have 90 &lt;a href=&#34;https://github.com/dnmfarrell&#34;&gt;repos&lt;/a&gt;, but only 13 distributions on &lt;a href=&#34;https://metacpan.org/author/DFARRELL&#34;&gt;CPAN&lt;/a&gt;. So only 14% of my code makes it to CPAN.&lt;/p&gt;

&lt;p&gt;Traditionally Dist::Zilla makes a distinction between your code and the files needed for CPAN and PAUSE to work, (like package metadata, a readme etc). The basic use case goes like this: you write your class files, scripts and unit tests, and when you tell Dist::Zilla to release the distribution, it generates all of the extra files, creates a tarball and uploads it to &lt;a href=&#34;https://pause.perl.org/pause/query&#34;&gt;PAUSE&lt;/a&gt;. The problem is though, some of those additional files would be nice to have in my GitHub repos too. I don&amp;rsquo;t want to write another &lt;code&gt;readme.md&lt;/code&gt;, or spend time copying the license file into the repo if Dist::ZIlla can already generate one. To solve this issue I use two Dist::Zilla plugins from &lt;a href=&#34;https://metacpan.org/author/RTHOMPSON&#34;&gt;Ryan Thompson&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;setup:3e7badd427fe2f7b2dcf3dadf6e1d80b&#34;&gt;Setup&lt;/h3&gt;

&lt;p&gt;To use the code in this article, you&amp;rsquo;ll need to install Dist::Zilla and the two plugin modules described below. You can do that with &lt;code&gt;cpan&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpan Dist::Zilla \
  Dist::Zilla::Plugin::ReadmeAnyFromPod  \
  Dist::Zilla::Plugin::CopyFilesFromBuild
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re installing Dist::Zilla consider using &lt;a href=&#34;https://metacpan.org/pod/App::cpanminus&#34;&gt;cpanminus&lt;/a&gt; instead, with no tests for a much faster install:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpanm --notest Dist::Zilla \ 
  Dist::Zilla::Plugin::ReadmeAnyFromPod \
  Dist::Zilla::Plugin::CopyFilesFromBuild
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;creating-a-readme-automatically:3e7badd427fe2f7b2dcf3dadf6e1d80b&#34;&gt;Creating a readme automatically&lt;/h3&gt;

&lt;p&gt;Ryan&amp;rsquo;s module &lt;a href=&#34;https://metacpan.org/pod/Dist::Zilla::Plugin::ReadmeAnyFromPod&#34;&gt;Dist::Zilla::Plugin::ReadmeAnyFromPod&lt;/a&gt; can generate a readme automatically, in any common format. It uses the Pod text from the main modules in the distribution. I use it to create my GitHub readme files in Pod, by adding the following text to my &lt;code&gt;dist.ini&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ReadmeAnyFromPod]
type = pod 
filename = README.pod
location = root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I build the distribution with Dist::Zilla, it will generate a new readme for me, including the author, copyright and version information in addition to the documentation already in the main module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ dzil build &amp;amp;&amp;amp; dzil clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This line instructs Dist::Zilla to build the distribution, which generates the new &lt;code&gt;README.pod&lt;/code&gt; and then clean up the build files that it generated, leaving a clean working directory.&lt;/p&gt;

&lt;h3 id=&#34;adding-a-license:3e7badd427fe2f7b2dcf3dadf6e1d80b&#34;&gt;Adding a license&lt;/h3&gt;

&lt;p&gt;I use another module from Ryan, &lt;a href=&#34;https://metacpan.org/pod/Dist::Zilla::Plugin::CopyFilesFromBuild&#34;&gt;Dist::Zilla::Plugin::CopyFilesFromBuild&lt;/a&gt; to copy the software license from the Dist::Zilla build into my project directory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[CopyFilesFromBuild]
copy = LICENSE
[GatherDir]
exclude_filename = LICENSE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will copy the license out of the build directory into the root project directory. The &lt;code&gt;exclude_filename&lt;/code&gt; clause is there so that during the &lt;em&gt;next&lt;/em&gt; build, Dist::Zilla does not include the generated license in the working directory of files. Running this in the same way as before, I can generate whatever license text I want for my distribution (the type of license is specified in the &lt;code&gt;dist.ini&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ dzil build &amp;amp;&amp;amp; dzil clean
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;helping-others:3e7badd427fe2f7b2dcf3dadf6e1d80b&#34;&gt;Helping others&lt;/h3&gt;

&lt;p&gt;Dist::Zilla is great, but if you don&amp;rsquo;t have it, installing a distribution from GitHub can really suck. Recently a friend was trying to deploy some code of mine to his Macbook with a vanilla Perl install. I didn&amp;rsquo;t want to upload the code to CPAN and wait for PAUSE to index it. Installing Dist::Zilla on the his machine was not a great option either: Dist::Zilla is a beast. According to Devel::Modlist, Dist::Zilla has &lt;strong&gt;178&lt;/strong&gt; non-core dependencies (including indirectly-used modules). That&amp;rsquo;s the price you pay for automation and modularity - Dist::Zilla is working hard so us module authors don&amp;rsquo;t have to. But for someone who barely knows Perl, installing Dist::Zilla in a virgin environment can be a nightmare.&lt;/p&gt;

&lt;p&gt;To get around this issue, I used &lt;a href=&#34;https://metacpan.org/pod/Dist::Zilla::Plugin::CopyFilesFromBuild&#34;&gt;Dist::Zilla::Plugin::CopyFilesFromBuild&lt;/a&gt; again to copy the Makefile.PL and cpanfile into the project directory. My friend then cloned the directory with Git and used &lt;a href=&#34;https://metacpan.org/pod/App::cpanminus&#34;&gt;cpanminus&lt;/a&gt; to install it. Easy! It worked so well, I&amp;rsquo;m going to include a Makefile and cpanfile in my GitHub repos from now on.&lt;/p&gt;

&lt;h3 id=&#34;a-sample-dist-zilla-config:3e7badd427fe2f7b2dcf3dadf6e1d80b&#34;&gt;A sample Dist::Zilla config&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s a &lt;code&gt;dist.ini&lt;/code&gt; from a &lt;a href=&#34;https://github.com/dnmfarrell/Settlers-Game&#34;&gt;repo&lt;/a&gt; of mine that uses the code in this article. As certain directives are required in order, it can be useful to see the entire context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name    = Settlers-Game
author  = David Farrell 
license = FreeBSD
copyright_holder = David Farrell
copyright_year   = 2015
version = 0.06

[CPANFile]
[License]
[CopyFilesFromBuild]
copy = cpanfile
copy = LICENSE
copy = Makefile.PL
[GatherDir]
exclude_filename = cpanfile
exclude_filename = LICENSE
exclude_filename = Makefile.PL
[PkgVersion]
[AutoPrereqs]
[GithubMeta]
[ChangelogFromGit]
[MetaYAML]
[MetaJSON]
[MakeMaker]
[ModuleBuild]
[ManifestSkip]
[Manifest]
[PodWeaver]
[ReadmeAnyFromPod]
type = pod
filename = README.pod
location = root
[PodSyntaxTests]
[PodCoverageTests]
[TestRelease]
[Test::EOL]
[UploadToCPAN]
[ConfirmRelease]
[Clean]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use this config with Dist::Zilla you&amp;rsquo;ll need some additional plugins:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpan Dist::Zilla::Plugin::Clean \
  Dist::Zilla::Plugin::GithubMeta \
  Dist::Zilla::Plugin::ChangelogFromGit \
  Dist::Zilla::Plugin::PodWeaver
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion:3e7badd427fe2f7b2dcf3dadf6e1d80b&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Ok it&amp;rsquo;s not &lt;em&gt;all&lt;/em&gt; gravy. The copy file method has one downside: it overwrites the copied files every time they&amp;rsquo;re generated. This isn&amp;rsquo;t an issue for me; the commit diff only shows the changed lines, but some people may not like it.&lt;/p&gt;

&lt;p&gt;For more information on Dist::Zilla, check out the official &lt;a href=&#34;http://dzil.org/tutorial/contents.html&#34;&gt;documentation&lt;/a&gt;. For a completely different approach to releasing code to CPAN, you may like&lt;a href=&#34;https://metacpan.org/pod/%20Module::Release&#34;&gt;Module::Release&lt;/a&gt;. Oh and if you find yourself in a new development environment, needing to install dependencies for a local module, David Golden has a useful &lt;a href=&#34;http://www.dagolden.com/index.php/1528/five-ways-to-install-modules-prereqs-by-hand/&#34;&gt;post&lt;/a&gt; that includes five different ways to do it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to install any* Perl module</title>
      <link>http://perltricks.com/article/200/2015/11/28/How-to-install-any--Perl-module/</link>
      <pubDate>Sat, 28 Nov 2015 00:11:17 +0000</pubDate>
      
      <guid>http://perltricks.com/article/200/2015/11/28/How-to-install-any--Perl-module/</guid>
      <description>&lt;p&gt;It&amp;rsquo;s our 200th article! Installing CPAN modules can be a pain, particularly for users not familiar with the Perl toolchain. To try something different, I&amp;rsquo;m uploading the article as an image file under creative commons. Feel free to share it, use it, whatever. If you use Perl at your office, maybe print it out for reference. You can download a copy &lt;a href=&#34;http://perltricks.com/images/200/chart.png&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/200/chart.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;[*] You can install any Perl module, but it may not be a good idea™&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello perldoc, productivity booster</title>
      <link>http://perltricks.com/article/155/2015/2/26/Hello-perldoc--productivity-booster/</link>
      <pubDate>Thu, 26 Feb 2015 13:42:57 +0000</pubDate>
      
      <guid>http://perltricks.com/article/155/2015/2/26/Hello-perldoc--productivity-booster/</guid>
      <description>

&lt;p&gt;Imagine this scenario: you&amp;rsquo;re using the DateTime module but you can&amp;rsquo;t remember the exact name of a function it provides. What do you do? You could open your browser, go to &lt;a href=&#34;https://metacpan.org/&#34;&gt;MetaCPAN&lt;/a&gt;, search for DateTime and look up the answer in the module&amp;rsquo;s documentation. A faster way would be to switch to the command line, and type &lt;code&gt;perldoc DateTime&lt;/code&gt; to display the module&amp;rsquo;s documentation right there in the terminal.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;perldoc&lt;/code&gt; is a command line program for reading Perl documentation. It comes with Perl, so if you&amp;rsquo;ve got Perl installed, perldoc should be available too. Using perldoc is easy: as you&amp;rsquo;ve already seen, to view the documentation of a module you&amp;rsquo;ve installed, at the command line type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perldoc Module::Name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;perldoc will search for the module and if it finds it, display the module&amp;rsquo;s documentation (written in Pod). Using perldoc you can learn more about any aspect of Perl almost instantly. Want to know more about Pod? Try &lt;code&gt;perldoc pod&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;dial-f-for-functions:950e91211886bd6e410eb5c07d6bf43a&#34;&gt;Dial -f for functions&lt;/h3&gt;

&lt;p&gt;Perl has a huge number of built-in functions, about 224 depending on the Perl version. Who can remember exactly how they all work? I know I can&amp;rsquo;t. To lookup a Perl function, use perldoc with the &lt;code&gt;-f&lt;/code&gt; switch. For instance to look up the documentation on the &lt;code&gt;rindex&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perldoc -f rindex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which will display:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rindex STR,SUBSTR,POSITION
rindex STR,SUBSTR
      Works just like index() except that it returns the position of the
      last occurrence of SUBSTR in STR. If POSITION is specified,
      returns the last occurrence beginning at or before that position.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aha! This is all well and good, but what do you do if you can&amp;rsquo;t remember the function name? Well you could use &lt;a href=&#34;https://metacpan.org/pod/B::Keywords&#34;&gt;B::Keywords&lt;/a&gt;, but another way would be to check out &lt;code&gt;perlfunc&lt;/code&gt; the Perl documentation on built-in functions. To read it, with perldoc just type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perldoc perlfunc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;predefined-variables:950e91211886bd6e410eb5c07d6bf43a&#34;&gt;Predefined Variables&lt;/h3&gt;

&lt;p&gt;As with functions, Perl has a large number of predefined variables that do everything from storing the program name to tracking the state of the regex engine. They&amp;rsquo;re really useful, but often have obscure names like &lt;code&gt;$^O&lt;/code&gt; (the OS name). So if you find yourself needing to check whether you&amp;rsquo;re looking at a list separator (&lt;code&gt;$&amp;quot;&lt;/code&gt;) or an output separator (&lt;code&gt;$/&lt;/code&gt;), just use perldoc with the &lt;code&gt;-v&lt;/code&gt; switch:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perldoc -v $/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because some predefined variables have weird names, you may need to quote them on the command line for perldoc to work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perldoc -v &#39;$&amp;quot;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The predefined variables documentation is known as &lt;code&gt;perlvar&lt;/code&gt;. It&amp;rsquo;s well worth a read through at least once (&lt;code&gt;perldoc perlvar&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;searching-the-documentation:950e91211886bd6e410eb5c07d6bf43a&#34;&gt;Searching the documentation&lt;/h3&gt;

&lt;p&gt;Perl has a lot of great documentation, but it can be hard to remember the names of all of the entries. If you ever want to browse the table of contents, use &lt;code&gt;perl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perldoc perl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Many people recommend perltoc for this, but for finding relevant entries, I think the perl entry is easier to browse than perltoc.&lt;/p&gt;

&lt;p&gt;Perl also has an extensive FAQ, (another entry that&amp;rsquo;s worth a read through). It has loads of answers to common queries. As usual you can read it with &lt;code&gt;perldoc faq&lt;/code&gt;, but you can also search it using the &lt;code&gt;-q&lt;/code&gt; switch. Want to know if there are any good IDEs for Perl? (a common newbie question):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perl -q ide
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Is there an IDE or Windows Perl Editor?
 Perl programs are just plain text, so any editor will do.

 If you&#39;re on Unix, you already have an IDE--Unix itself. The Unix
 philosophy is the philosophy of several small tools that each do one thing
 and do it well. It&#39;s like a carpenter&#39;s toolbox.

 If you want an IDE, check the following (in alphabetical order, not order
 of preference):

 Eclipse


     The Eclipse Perl Integration Project integrates Perl editing/debugging
     with Eclipse.

 Komodo


     ActiveState&#39;s cross-platform (as of October 2004, that&#39;s Windows,
     Linux, and Solaris), multi-language IDE has Perl support, including a
     regular expression debugger and remote debugging.
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;finding-module-install-locations:950e91211886bd6e410eb5c07d6bf43a&#34;&gt;Finding module install locations&lt;/h3&gt;

&lt;p&gt;perldoc isn&amp;rsquo;t just about documentation. If you need to find out where a module is installed, using the &lt;code&gt;-l&lt;/code&gt; switch, perldoc will return the filepath of the module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perldoc -l Test::More
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you get the path, you can open it in an editor directly:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ vi $(perldoc -l Test::More)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One trick here: some modules don&amp;rsquo;t have any POD in them, for those modules, use &lt;code&gt;-lm&lt;/code&gt; to still return the path.&lt;/p&gt;

&lt;h3 id=&#34;read-module-source-code-in-perldoc:950e91211886bd6e410eb5c07d6bf43a&#34;&gt;Read module source code in perldoc&lt;/h3&gt;

&lt;p&gt;Finally, perldoc can also display module source code. Just use the &lt;code&gt;-m&lt;/code&gt; switch:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ perldoc -m Test::More
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wrap-up:950e91211886bd6e410eb5c07d6bf43a&#34;&gt;Wrap up&lt;/h3&gt;

&lt;p&gt;This article has covered the most common features, but perldoc has a bunch of other capabilities that you can read about at the command line with &lt;code&gt;man perldoc&lt;/code&gt;. The Perl documentation is also &lt;a href=&#34;http://perldoc.perl.org/&#34;&gt;online&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Keep in mind that as you get more proficient with perldoc, you&amp;rsquo;ll need the online resources less and less. Get in the habit of switching to the command line, looking up something in perldoc and flipping right back to programming - it&amp;rsquo;s a productivity win.&lt;/p&gt;

&lt;h3 id=&#34;perldoc-cheatsheet:950e91211886bd6e410eb5c07d6bf43a&#34;&gt;perldoc cheatsheet&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;perldoc [option]

Module Options                               
--------------                               
         Module documentation     
-l       Module filepath          
-lm      Module filepath (alt.)   
-m       Module source


Search Options
--------------
-f     Get a built-in function definition
-v     Get a variable definition
-q      Search the faq for a keyword


Commonly Used Entries
---------------------
perl         Language overview, list of all other entries
perltoc      Table of contents
perlfunc     Built-in functions documentation
perlvar      Predefined variables documentation
perlref      References documentation
perlre       Regex documentation
faq          The Perl FAQ

Help
----
man perldoc     List of all perldoc options
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Who has the best package manager? Part one</title>
      <link>http://perltricks.com/article/110/2014/8/21/Who-has-the-best-package-manager--Part-one/</link>
      <pubDate>Thu, 21 Aug 2014 13:03:03 +0000</pubDate>
      
      <guid>http://perltricks.com/article/110/2014/8/21/Who-has-the-best-package-manager--Part-one/</guid>
      <description>

&lt;p&gt;Every major language has thousands of libraries which enable programmers to reach higher, further and faster than before. Package managers (the online systems for sharing code) are key to a language&amp;rsquo;s success; Perl, PHP, Python, Ruby and Node.js all have strong offerings. But which one is the best and what can we learn from each of them? This article is the first in a two-part series where I review each package manager. Part one focuses on searching and using packages and part two will look at how easy it is to upload and share packages.&lt;/p&gt;

&lt;h3 id=&#34;terminology:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Terminology&lt;/h3&gt;

&lt;p&gt;The term &amp;ldquo;package manager&amp;rdquo; isn&amp;rsquo;t strictly accurate when referring to the online code sharing systems. &lt;a href=&#34;http://rubygems.org/&#34;&gt;RubyGems&lt;/a&gt; and &lt;a href=&#34;https://www.npmjs.org/&#34;&gt;npm&lt;/a&gt; are described as package managers but for Python &lt;a href=&#34;https://pypi.python.org/pypi&#34;&gt;PyPI&lt;/a&gt; is a package index and &lt;code&gt;pip&lt;/code&gt; is the package manager. Similarly, &lt;a href=&#34;https://metacpan.org&#34;&gt;metacpan&lt;/a&gt; is a search engine for &lt;a href=&#34;http://www.cpan.org/%20&#34;&gt;CPAN&lt;/a&gt;. I use the term &amp;ldquo;package manager&amp;rdquo; to refer to the commonly-used collection of tools used for searching, reviewing, installing and sharing code.&lt;/p&gt;

&lt;h3 id=&#34;inputs-and-scoring-criteria:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Inputs and Scoring Criteria&lt;/h3&gt;

&lt;p&gt;The following package managers were reviewed:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://packagist.org&#34;&gt;Packagist&lt;/a&gt; for PHP&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pypi.python.org/pypi&#34;&gt;PyPi&lt;/a&gt; for Python&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org&#34;&gt;metacpan&lt;/a&gt; for Perl&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.org/&#34;&gt;npm&lt;/a&gt; for Node.js&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rubygems.org/&#34;&gt;RubyGems&lt;/a&gt; for Ruby&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Every package manager was scored against 5 criteria:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Search - how easy is it to find what you&amp;rsquo;re looking for. An ideal search function would return the most relevant packages first, and provide information to help users differentiate packages.&lt;/li&gt;
&lt;li&gt;Metadata - what supporting data is provided to give context and enable the user understand the package better: name, description, number of downloads, unit test coverage, portability, dependencies, user reviews etc/&lt;/li&gt;
&lt;li&gt;Documentation - accessibility and usability of the package documentation. Easy-to-use documentation is clear and consistent in layout and provides useful information for would-be package consumers.&lt;/li&gt;
&lt;li&gt;Source - accessibility and usability of the source code. The source code should be easily inspect-able which means providing an easily navigable directory tree and presenting the code in a readable, helpful way.&lt;/li&gt;
&lt;li&gt;Installation - how easy is it to install a package: are instructions provided and does the installation work.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I scored each criterion between 1 and 5, with 5 being best. Clearly this is a subjective approach both in the criteria chosen and strength of the rating given. Whether the results are &lt;em&gt;useful&lt;/em&gt; or not I leave for you, the reader to decide.&lt;/p&gt;

&lt;h3 id=&#34;method:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Method&lt;/h3&gt;

&lt;p&gt;3 search terms were used: &amp;ldquo;selenium&amp;rdquo;, &amp;ldquo;sqlite3&amp;rdquo; and &amp;ldquo;web framework&amp;rdquo;. The search term was unquoted when entered. Selenium should be an easy search term as it&amp;rsquo;s a unique name and common library (bindings to &lt;a href=&#34;http://docs.seleniumhq.org/projects/webdriver/&#34;&gt;Selenium WebDriver&lt;/a&gt;). SQLite3 is slightly more difficult as it includes a version number and many packages named &amp;ldquo;sqlite&amp;rdquo; are intended for SQLite3. Web framework is the most difficult as it is a description rather than a name and yet we wanted the search to return relevant results like Sinatra, Django, and express. For each language I used a recommended list of web frameworks as my target packages. In all searches I considered the sorting of relevant results and the usefulness of information provided in the search results.&lt;/p&gt;

&lt;p&gt;Upon locating a target result in each search, I opened the package page and scored the other criteria. Only the packages returned by the 3 search terms were considered.&lt;/p&gt;

&lt;h3 id=&#34;php-packagist:e4033a7178e3036bc1983cb5214477f8&#34;&gt;PHP: Packagist&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_packagist.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;First up is &lt;a href=&#34;https://packagist.org/statistics&#34;&gt;Packagist&lt;/a&gt;, the largest PHP package search engine, with over 36,000 &lt;a href=&#34;https://packagist.org/statistics&#34;&gt;packages&lt;/a&gt; indexed. Packagist integrates with &lt;a href=&#34;https://getcomposer.org/&#34;&gt;Composer&lt;/a&gt;, a PHP dependency management system.&lt;/p&gt;

&lt;p&gt;Packagist auto-focused to the text search box and provided live search results as I entered the search terms. For every search result Packagist return the package name, description, number of downloads and star count. Search results were paginated and no facility for sorting or filtering the search results was provided.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_packagist_search_selenium.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The search results were mixed: the target &lt;a href=&#34;https://packagist.org/packages/alexandresalome/php-selenium&#34;&gt;selenium package&lt;/a&gt; was returned 3rd on the list of results. The SQLite3 search did not return any useful packages (bindings to SQLite3), but this is perhaps because PHP 5.3 ships with a built in &lt;a href=&#34;http://php.net/manual/en/book.sqlite3.php&#34;&gt;SQLite class&lt;/a&gt;. The Web Framework &lt;a href=&#34;https://packagist.org/search/?q=web%20framework&#34;&gt;search&lt;/a&gt; did not return any &lt;a href=&#34;http://mashable.com/2014/04/04/php-frameworks-build-applications/&#34;&gt;target packages&lt;/a&gt; in the top 20 results, with &lt;a href=&#34;https://packagist.org/packages/laravel/framework&#34;&gt;Laravel&lt;/a&gt; being returned 21&lt;sup&gt;st&lt;/sup&gt;.&lt;/p&gt;

&lt;h4 id=&#34;search-3-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Search: &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;Packagist provided a basic set of metadata including: name, description, version number, download statistics, version history and dependencies. No package had license information, unit test coverage, platform compatibility or continuous integration results. There was no facility to &amp;ldquo;star&amp;rdquo; or review a module (presumably the star count on the search results came from GitHub).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_packagist_laravel.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;metadata-2-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Metadata: &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;Documentation was sparse - a link was provided to the GitHub repo, which displays the repo readme by default. There seemed to be little consistency across packages in terms of headings or content.&lt;/p&gt;

&lt;h4 id=&#34;documentation-2-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Documentation: &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;Packagist linked to the source repos on GitHub. The code was easy to navigate although the directory tree structures were inconsistent.&lt;/p&gt;

&lt;h4 id=&#34;source-3-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Source: &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;Installation with PHP Composer is done by marking the target package as &amp;ldquo;required&amp;rdquo; in a json file. packages can be installed directly using Composer on the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ composer.phar require &amp;quot;laravel/framework&amp;quot;: &amp;quot;4.2.8&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Helpfully, Packagist listed the required text on every package page.&lt;/p&gt;

&lt;h4 id=&#34;installation-5-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Installation: &lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;h5 id=&#34;packagist-overall-3-0:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Packagist overall: 3.0&lt;/h5&gt;

&lt;h3 id=&#34;python-pypi:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Python: PyPI&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_pypi.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next up is Python&amp;rsquo;s &lt;a href=&#34;https://pypi.python.org/pypi&#34;&gt;PyPi&lt;/a&gt;, which has over 47,500 packages.&lt;/p&gt;

&lt;p&gt;PyPI&amp;rsquo;s search results returned the package name, a match-strength indicator called &amp;ldquo;weight&amp;rdquo; and a description. The search results for &lt;a href=&#34;https://pypi.python.org/pypi/selenium/2.42.1&#34;&gt;Selenium&lt;/a&gt; and &lt;a href=&#34;https://pypi.python.org/pypi/db-sqlite3/0.0.1&#34;&gt;SQLite3&lt;/a&gt; were good with the target libraries in the top 2 results each time.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_pypi_search_selenium.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The search results for &amp;ldquo;web framework&amp;rdquo; were mixed: I was looking for common Python &lt;a href=&#34;https://wiki.python.org/moin/WebFrameworks&#34;&gt;web frameworks&lt;/a&gt; and only one, &lt;a href=&#34;https://pypi.python.org/pypi/watson-framework/2.2.7&#34;&gt;Watson&lt;/a&gt; was listed in the top 20 results. Django was 280&lt;sup&gt;th&lt;/sup&gt; with Flask arriving 574&lt;sup&gt;th&lt;/sup&gt; in the list. PyPI was the only package manager to not paginate search results, which made it easy to traverse search results results and export them. There was no function to filter or sort the results under different criteria.&lt;/p&gt;

&lt;h4 id=&#34;search-3-5-1:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Search: &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;The metadata provided varied from package to package, but PyPI usually provided: the last upload date, number of downloads, author name, package owner and maintainers, package homepage link and a DOAP.xml record. The &lt;a href=&#34;https://pypi.python.org/pypi/watson-framework/2.2.7&#34;&gt;Watson&lt;/a&gt; package included a build status with unit test coverage. Only 1 of the three packages provided a license. There didn&amp;rsquo;t seem to be a facility to provide user reviews or &amp;ldquo;stars&amp;rdquo; which would indicate whether a package was any good or not.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_pypi_selenium.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;metadata-3-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Metadata: &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;Documentation was mixed with either no documentation or just a high level synopsis provided. In most cases an external link to another site provided more documentation, but it&amp;rsquo;s not consistent (it could be Google code, GitHub or a project-specific website).&lt;/p&gt;

&lt;h4 id=&#34;documentation-2-5-1:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Documentation: &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;All of the packages source code was hosted externally by GitHub or Google code and a link is provided by PyPI. This is fine, but it can take several hops to find the actual source code, and the structure of the source code tree varies from package to package; it might just be a collection of *.py files in a root folder for example.&lt;/p&gt;

&lt;h4 id=&#34;source-2-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Source: &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;PyPI provides installation guidance on it&amp;rsquo;s homepage. Additionally most of the reviewed packages&amp;rsquo; documentation contained command line code instructions for installing the packages. All three packages installed without a hitch using &lt;code&gt;pip&lt;/code&gt;, although it appeared that no unit tests were run on install, so whether the packages work or not is an open question.&lt;/p&gt;

&lt;h4 id=&#34;installation-5-5-1:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Installation: &lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;h5 id=&#34;pypi-overall-3-0:e4033a7178e3036bc1983cb5214477f8&#34;&gt;PyPI overall: 3.0&lt;/h5&gt;

&lt;h3 id=&#34;perl-metacpan:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Perl: metacpan&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_metacpan.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/&#34;&gt;metacpan&lt;/a&gt; is described as a CPAN &lt;a href=&#34;https://metacpan.org/about&#34;&gt;search engine&lt;/a&gt; and provides nearly all of the features of CPAN, plus many features that CPAN doesn&amp;rsquo;t offer. It has been around since 2013, and indexes over 30,000 packages.&lt;/p&gt;

&lt;p&gt;metacpan&amp;rsquo;s search page autofocused on the text input search box and provide predictive text search. The search results contained the package name, description, an average review score (if there are any reviews), a count of &amp;ldquo;++&amp;ldquo;s (which are like GitHub stars) and the author name. Helpfully, sub-packages in the same namespace were indented below higher-level packages.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_cpan_selenium_search.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The Selenium search returned the target package (&lt;a href=&#34;https://metacpan.org/pod/WWW::Selenium&#34;&gt;WWW:Selenium&lt;/a&gt;) first, however SQLite3&amp;rsquo;s target package (&lt;a href=&#34;https://metacpan.org/pod/DBD::SQLite&#34;&gt;DBD::SQLite&lt;/a&gt;) was returned 17th in the search results. The Web Framework search results were not great: the first 20 results were for old frameworks or irrelevant packages. However the target packages (e.g. Catalyst, Dancer, Mojolicious and Kelp) were found in top 40 results. metacpan paginated the search results, 20 per page, which meant the target packages were actually on &lt;a href=&#34;https://metacpan.org/search?p=2&amp;amp;q=web+framework&#34;&gt;page 2&lt;/a&gt; . No method to filter or sort the search results was provided.&lt;/p&gt;

&lt;h4 id=&#34;search-3-5-2:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Search: &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_cpan_sqlite.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;metacpan provided a wealth of package metadata: the package name, description, version number, activity histogram, issues list, CPAN Testers &lt;a href=&#34;http://www.cpantesters.org/distro/D/DBD-SQLite.html?oncpan=1&amp;amp;distmat=1&amp;amp;version=1.42&#34;&gt;results&lt;/a&gt; (an external CI platform that runs the package against many different operating systems and Perl versions to detect portability issues), &lt;a href=&#34;http://cpants.cpanauthors.org/kwalitee&#34;&gt;kwalitee&lt;/a&gt; rating, reviews and &amp;ldquo;++&amp;rdquo; counts. It also provides a dependencies list, a dependent packages list and a nifty dependencies chart. This example is for &lt;a href=&#34;https://metacpan.org/pod/WWW::Selenium&#34;&gt;WWW::Selenium&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;Curiously metacpan did not provide download statistics for any package. This would seem like a useful quality indicator for users. metacpan may suffer a little from &amp;ldquo;information overload&amp;rdquo; - there were so many links and metrics it could be hard for a user to disseminate the important metrics from the noise. Although metacpan listed the license name, it didn&amp;rsquo;t provide a link to the underlying license text which would be useful. Unit test coverage was not reported.&lt;/p&gt;

&lt;h4 id=&#34;metadata-5-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Metadata: &lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;Documentation was extensive, except in the case of the web framework package (Dancer) which includes high-level examples and then links for documentation contained in other packages. What was especially nice was that the documentation was easily accessible and consistently styled across all three packages as it was all presented though metacpan.&lt;/p&gt;

&lt;h4 id=&#34;documentation-5-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Documentation: &lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;A direct link to the source code was provided on every package page. The source code is also hosted on metacpan and consistently styled. Some useful measures were provided: the number of lines of code, the number of lines of documentation and the file size in kilobytes. I was also able to toggle on and off the inline documentation (called &amp;ldquo;Pod&amp;rdquo;) and view the code raw. Another useful feature: every package reference in the source code is a hyperlink to the source code of that package.&lt;/p&gt;

&lt;p&gt;However it was not clear how to navigate the package tree (the links are in the name of the package itself). One package was hosted on GitHub and a direct link to the repo was provided on the package page - so the user has the option of viewing the source on GitHub if they prefer it to metacpan.&lt;/p&gt;

&lt;h4 id=&#34;source-5-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Source: &lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;No information was provided by metacpan on how to install a module.&lt;/p&gt;

&lt;h4 id=&#34;installation-1-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Installation: &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;h5 id=&#34;metacpan-overall-3-8:e4033a7178e3036bc1983cb5214477f8&#34;&gt;metacpan overall: 3.8&lt;/h5&gt;

&lt;p&gt;Node.js: npm&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_npm.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.npmjs.org/&#34;&gt;npm&lt;/a&gt; is the Node.js package manager. It boasts over 89,500 packages, which is the most of any package manager in this review.&lt;/p&gt;

&lt;p&gt;The npm search results were good: although the target Selenium &lt;a href=&#34;https://www.npmjs.org/package/selenium-webdriver&#34;&gt;package&lt;/a&gt; was 7th in the list of results, both the SQLite3 and Web Framework searches returned the target packages (&lt;a href=&#34;https://www.npmjs.org/package/sqlite3&#34;&gt;sqlite3&lt;/a&gt;, [](&lt;a href=&#34;https://www.npmjs.org/package/express)express&#34;&gt;https://www.npmjs.org/package/express)express&lt;/a&gt;) first in the results list. npm displayed the package name, description, download statistics, a &amp;ldquo;star&amp;rdquo; count and a keyword list. The search results were paginated and no filtering or sorting function was provided.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_npm_search_webf.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;search-5-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Search: &lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;npm provided a useful set of metadata including: download statistics, license, issues link, version, dependencies and dependant packages When available it also pulled the Travis CI status from GitHub. No information was provided regarding unit test coverage or platform availability. There didn&amp;rsquo;t seem to be a function for adding user reviews of packages to npm.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_npm_express.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;metadata-4-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Metadata: &lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;Documentation was poor - npm just displayed the package readme. Although the documentation was consistently styled, it was not consistent in layout or content. Every package used different headings and different content.&lt;/p&gt;

&lt;h4 id=&#34;documentation-2-5-2:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Documentation: &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;npm just provided links to the source repo. The Selenium &lt;a href=&#34;https://code.google.com/p/selenium/&#34;&gt;repo&lt;/a&gt; was on Google Code and npm provided the URL but did not link to it. The Selenium source code link did not even direct to the Node.js package - it went to the main Selenium source code. The other two packages (SQLite3, express) were better: they were GitHub hosted with consistent package trees (lib and test directories) and it was easy to browse the source.&lt;/p&gt;

&lt;h4 id=&#34;source-3-5-1:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Source: &lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;The npm homepage explained how to install a package, and linked to a more detailed page of examples. Every package page included installation instructions. All three packages installed without issue. It wasn&amp;rsquo;t clear if any unit tests were run as part of installation.&lt;/p&gt;

&lt;h4 id=&#34;installation-5-5-2:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Installation: &lt;sup&gt;5&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;h5 id=&#34;npm-overall-3-8:e4033a7178e3036bc1983cb5214477f8&#34;&gt;npm overall: 3.8&lt;/h5&gt;

&lt;h3 id=&#34;ruby-rubygems:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Ruby: RubyGems&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_gem.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://rubygems.org&#34;&gt;RubyGems&lt;/a&gt; is the Ruby package manager and has over 87,000 packages.&lt;/p&gt;

&lt;p&gt;RubyGems search was mixed, for the SQLite3 and Selenium searches the target package was returned in the top 2 results. However RubyGems returned no results for the Web Framework search, which given the popularity of Ruby on Rails is astonishing. For each search result RubyGems displayed the package name, description and number of downloads. Results were paginated and no facility was provided for sorting or filtering the results returned.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_gem_search_webf.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;search-2-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Search: &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;A basic set of metadata was provided: package name, description, author(s), version number, download statistics, license name, dependencies and a version history time line. There was no facility to &amp;ldquo;star&amp;rdquo; or review a module. No information was provided regarding cross platform support or unit test coverage.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_gem_sqlite.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;metadata-2-5-1:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Metadata: &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;RubyGems&amp;rsquo; documentation consisted of a link to an external site. The SQLite3 package used &lt;a href=&#34;http://rubydoc.info/&#34;&gt;RubyDoc&lt;/a&gt; which is like a nicer-looking JavaDoc. Selenium-Webdriver used Google code and in the case of Sinatra, their own &lt;a href=&#34;http://www.sinatrarb.com/&#34;&gt;website&lt;/a&gt;. The documentation was inconsistent in style, layout, content and quality.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://perltricks.com/images/110/pm_gem_sqlite_doc.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;documentation-2-5-3:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Documentation: &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;RubyGems provided a link to the externally hosted repo for 2 packages (&lt;a href=&#34;http://rubygems.org/gems/sinatra&#34;&gt;Sinatra&lt;/a&gt;, &lt;a href=&#34;http://rubygems.org/gems/selenium-webdriver&#34;&gt;Selenium-Webdriver&lt;/a&gt;). The Selenium source code &lt;a href=&#34;https://code.google.com/p/selenium/source/list&#34;&gt;link&lt;/a&gt; was to the base Selenium package, not the Ruby package. For the SQLite3 package no link to the source code was provided.&lt;/p&gt;

&lt;h4 id=&#34;source-2-5-1:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Source: &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;p&gt;Every package page provided command line installation instructions. However on my machine (Fedora 19), 2 of the packages failed to install with the same error: &lt;code&gt;mkmf.rb can&#39;t find header files for ruby&lt;/code&gt;. I was able to install the packages using the Fedora package manager instead.&lt;/p&gt;

&lt;h4 id=&#34;installation-2-5:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Installation: &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;5&lt;/sub&gt;&lt;/h4&gt;

&lt;h5 id=&#34;rubygems-overall-2-0:e4033a7178e3036bc1983cb5214477f8&#34;&gt;RubyGems overall: 2.0&lt;/h5&gt;

&lt;h3 id=&#34;conclusion:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.npmjs.org/&#34;&gt;npm&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/&#34;&gt;metacpan&lt;/a&gt; both scored 3.8 and tied for first place. npm has a great search feature, but needs better documentation. No package manager provided a means for sorting or further filtering the search results, which seems like a missed opportunity - it would be very helpful to be able to sort search results by the date of last upload - this would help the user eliminate stale packages from the results.&lt;/p&gt;

&lt;p&gt;metacpan&amp;rsquo;s search could have been better but it&amp;rsquo;s documentation was excellent. It&amp;rsquo;s interesting that CPAN enforces almost zero requirements on documentation, yet overall it scored the highest. This might be because the underlying CPAN toolchain is 19 years old and has well-established conventions. metacpan also presented the source code nicely with several enhancements to make it easier, such as being able to toggle the display of inline documentation. metacpan should provide installation instructions for every package, which would be easy boilerplate using the &lt;code&gt;cpan&lt;/code&gt; command line tool. The distributed network of CPAN mirrors may mean that download statistics are not easily available to metacpan, but it could be a useful addition to the rich set of package metadata that metacpan provides.&lt;/p&gt;

&lt;p&gt;PyPI and Packagist were all-rounders, with each scoring 3.0. In both cases better documentation and more package metadata would make them more usable.&lt;/p&gt;

&lt;p&gt;RubyGems score of just 2.0 leaves room for improvement in all areas. I&amp;rsquo;m guessing but I think the strange search results could be improved by searching the package description as well as the package name, so that searches for &amp;ldquo;web framework&amp;rdquo; returns results.&lt;/p&gt;

&lt;p&gt;In part two I&amp;rsquo;ll consider how well each of these package managers enables users to upload and share packages.&lt;/p&gt;

&lt;h3 id=&#34;evaluation:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Evaluation&lt;/h3&gt;

&lt;p&gt;The results are subjective but I hope they&amp;rsquo;re approximately representative. Choosing different search terms could have changed the results significantly - perhaps different packages are better documented than others for example. Also the uniform weighting given to each of the criteria could be changed to reflect the relative importance of each criterion (is search is more important than source code accessibility?). Also don&amp;rsquo;t rule out author ignorance :). The list of package managers could also be expanded. I&amp;rsquo;ve focused here on scripting language package managers, but there are &lt;a href=&#34;http://www.modulecounts.com/&#34;&gt;many&lt;/a&gt; to choose from.&lt;/p&gt;

&lt;h3 id=&#34;thanks:e4033a7178e3036bc1983cb5214477f8&#34;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;Thanks to Neil Bowers for providing the initial idea and feedback on this article. All errors are my own.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Celebrate CPAN day on August 16th</title>
      <link>http://perltricks.com/article/109/2014/8/13/Celebrate-CPAN-day-on-August-16th/</link>
      <pubDate>Wed, 13 Aug 2014 12:43:17 +0000</pubDate>
      
      <guid>http://perltricks.com/article/109/2014/8/13/Celebrate-CPAN-day-on-August-16th/</guid>
      <description>

&lt;p&gt;Back in 1995 CPAN was a visionary concept that propelled Perl to the height of its popularity during the dotcom boom. For the first time there was a single, integrated online system for Perl programmers to distribute software. Today CPAN continues to go from &lt;a href=&#34;http://neilb.org/cpan-report/&#34;&gt;strength to strength&lt;/a&gt; as Perl&amp;rsquo;s &amp;ldquo;killer feature&amp;rdquo;. CPAN Day is August the 16th - the day of the first ever upload to CPAN, and a fantastic opportunity to celebrate our wonderful tool and give back to the Perl community.&lt;/p&gt;

&lt;h3 id=&#34;ways-to-celebrate:37fcf7f7809608d85d3fba77ced9a502&#34;&gt;Ways to celebrate&lt;/h3&gt;

&lt;p&gt;The idea of CPAN Day was conceived by Philippe Bruhat from an IRC conversation with Neil Bowers. Since then, Neil has blogged daily about different ways to celebrate CPAN Day. Most of these ideas are Neil&amp;rsquo;s:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Help make history by releasing a new &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/07/the-ghost-of-cpan-days-past.html&#34;&gt;distribution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Give your module good &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/07/give-your-modules-a-good-abstract.html&#34;&gt;extract&lt;/a&gt;, &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/08/craft-the-first-paragraph-of-your-description.html&#34;&gt;description&lt;/a&gt;, &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/07/give-your-modules-a-good-synopsis.html&#34;&gt;synopsis&lt;/a&gt; []() or &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/07/give-your-module-a-good-see-also-section.html&#34;&gt;see also&lt;/a&gt; section&lt;/li&gt;
&lt;li&gt;Thank a &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/08/thank-a-cpan-author-on-cpan-day.html&#34;&gt;CPAN author&lt;/a&gt; or acknowledge a &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/08/acknowledge-your-contributors-on-cpan-day.html&#34;&gt;contributor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Help keep Perl strong and donate to the &lt;a href=&#34;https://secure.donor.com/pf012/give&#34;&gt;Perl Foundation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Put your module on &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/08/put-your-cpan-distributions-on-github.html&#34;&gt;Github&lt;/a&gt; so other programmers can easily contribute&lt;/li&gt;
&lt;li&gt;Classify your &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/08/classify-your-rt-tickets-on-cpan-day.html&#34;&gt;RT tickets&lt;/a&gt; or fix a &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/08/fix-a-bug-on-cpan-day.html&#34;&gt;bug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;If you have a stable module, let others know and update the distribution version to 1.0&lt;/li&gt;
&lt;li&gt;Check your &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/08/check-your-test-coverage-with-develcover.html&#34;&gt;test coverage&lt;/a&gt; with Devel::Cover&lt;/li&gt;
&lt;li&gt;Make your module more portable by fixing your CPAN Testers &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/08/fix-your-cpan-testers-failures.html&#34;&gt;failures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Increase your module&amp;rsquo;s &amp;ldquo;kwalitee&amp;rdquo; by improving your &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/08/get-cpants-clean-on-cpan-day.html&#34;&gt;CPANTS rating&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Maybe improve your module &lt;a href=&#34;http://blogs.perl.org/users/neilb/2014/08/dont-be-afraid-to-rename-your-module-dist.html&#34;&gt;name&lt;/a&gt; or remove the &lt;a href=&#34;http://blogs.perl.org/users/book/2014/08/curating-cpan-sometimes-mean-deleting-stuff.html&#34;&gt;module&lt;/a&gt; entirely&lt;/li&gt;
&lt;li&gt;Write an article about your favourite CPAN module&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So there are loads of different ways to contribute! Earlier today I caught up with Neil Bowers and asked him if he had to pick one, which was the most important contribution. Neil said:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I would pick the see also section - it outlines other relevant modules, the pros and cons of each one and saves people time when first approaching a problem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For you self-interested module authors out there, Neil also explained that a good SEE ALSO section can make your own module more popular. This is because &lt;a href=&#34;https://metacpan.org/&#34;&gt;metacpan&lt;/a&gt; is built on elastic search and by listing other modules in the SEE ALSO, you ensure that your modules appear in the search results for those other modules.&lt;/p&gt;

&lt;p&gt;So how will you celebrate CPAN Day? Even if you did just one of the above suggestions, you&amp;rsquo;d be supporting the community in some way. Apparently some of CPAN&amp;rsquo;s most prolific authors are planning large releases to CPAN. Diff records will be broken, commit history will be made. I&amp;rsquo;m planning to move my modules to GitHub and to thank an author. I can&amp;rsquo;t wait to see what everyone else does. The inaugural CPAN Day is August 16th 2014, let&amp;rsquo;s make it &lt;em&gt;our&lt;/em&gt; day!&lt;/p&gt;

&lt;h3 id=&#34;thanks:37fcf7f7809608d85d3fba77ced9a502&#34;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;Thanks to Neil Bowers for contributing additional detail in support of this article.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Parse Excel with ease using Perl</title>
      <link>http://perltricks.com/article/108/2014/8/5/Parse-Excel-with-ease-using-Perl/</link>
      <pubDate>Tue, 05 Aug 2014 13:41:48 +0000</pubDate>
      
      <guid>http://perltricks.com/article/108/2014/8/5/Parse-Excel-with-ease-using-Perl/</guid>
      <description>

&lt;p&gt;In the business world, it seems like Excel spreadsheets are everywhere. Recently I had to parse several hundred spreadsheets under a tight deadline for a client. To make matters worse, the spreadsheets were in a mix of Excel 2003 (xls) and 2007 (xlsx) formats. Fortunately I know Perl, and using the Spreadsheet::Read module, it was easy. This article will show you how to use Spreadsheet::Read to parse Excel spreadsheets.&lt;/p&gt;

&lt;h3 id=&#34;requirements:0b46a0650427715cdfe7d0a01e84588d&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ll need to install &lt;a href=&#34;https://metacpan.org/pod/Spreadsheet::Read&#34;&gt;Spreadsheet::Read&lt;/a&gt; and a couple of interface modules. &lt;a href=&#34;https://metacpan.org/pod/Spreadsheet::ParseExcel&#34;&gt;Spreadsheet::ParseExcel&lt;/a&gt; is an interface for Excel 2003 spreadsheets and &lt;a href=&#34;https://metacpan.org/pod/Spreadsheet::XLSX&#34;&gt;Spreadsheet::XLSX&lt;/a&gt; is for reading the modern Excel format. You can install all three modules from the terminal using cpan:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpan Spreadsheet::ParseExcel Spreadsheet::XLSX Spreadsheet::Read
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;using-spreadsheet-read:0b46a0650427715cdfe7d0a01e84588d&#34;&gt;Using Spreadsheet::Read&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s parse the spreadsheet shown in the cover image, which contains an income statement. Spreadsheet::Read provides a simple, unified interface for reading spreadsheets. It exports the &lt;code&gt;ReadData&lt;/code&gt; function which requires a filepath to the spreadsheet:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Spreadsheet::Read;

my $workbook = ReadData(&#39;income_statement.xlsx&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;$workbook&lt;/code&gt; contains the data structure representing the spreadsheet. We can inspect this structure by printing it with &lt;a href=&#34;https://metacpan.org/pod/Data::Printer&#34;&gt;Data::Printer&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;\ [
    [0] {
        error     undef,
        parser    &amp;quot;Spreadsheet::XLSX&amp;quot;,
        sheet     {
            Sheet1   1
        },
        sheets    1,
        type      &amp;quot;xlsx&amp;quot;,
        version   0.13
    },
    [1] {
        attr     [],
        B1       &amp;quot;Income Statement 2014&amp;quot;,
        B2       &amp;quot;Revenue&amp;quot;,
        B3       &amp;quot;Cost of goods sold&amp;quot;,
        B4       &amp;quot;Gross profit&amp;quot;,
        B5       &amp;quot;Financing costs&amp;quot;,
        B6       &amp;quot;Tax&amp;quot;,
        B7       &amp;quot;Net profit&amp;quot;,
        cell     [
            [0] [],
            [1] [],
            [2] [
                [0] undef,
                [1] &amp;quot;Income Statement 2014&amp;quot;,
                [2] &amp;quot;Revenue&amp;quot;,
                [3] &amp;quot;Cost of goods sold&amp;quot;,
                [4] &amp;quot;Gross profit&amp;quot;,
                [5] &amp;quot;Financing costs&amp;quot;,
                [6] &amp;quot;Tax&amp;quot;,
                [7] &amp;quot;Net profit&amp;quot;
            ],
            [3] [
                [0] undef,
                [1] undef,
                [2] 50000,
                [3] 2500,
                [4] 47500,
                [5] 7150,
                [6] 10087.5,
                [7] 30262.5
            ]
        ],
        C2       &amp;quot; $ 50,000.00 &amp;quot;,
        C3       &amp;quot; $ 2,500.00 &amp;quot;,
        C4       &amp;quot; $ 47,500.00 &amp;quot;,
        C5       &amp;quot; $ 7,150.00 &amp;quot;,
        C6       &amp;quot; $ 10,087.50 &amp;quot;,
        C7       &amp;quot; $ 30,262.50 &amp;quot;,
        label    &amp;quot;Sheet1&amp;quot;,
        maxcol   3,
        maxrow   7
    }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This shows that &lt;code&gt;$workbook&lt;/code&gt; is an arrayref, whose first element describes the file, and subsequent elements represent the individual worksheets. The &lt;code&gt;label&lt;/code&gt; key pair contains the worksheet name, access it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$workbook-&amp;gt;[1]{label}; #Sheet1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cells can be referenced using Excel&amp;rsquo;s grid notation (&amp;ldquo;A3&amp;rdquo;) or via standard Perl array access. The different between these is formatting:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$workbook-&amp;gt;[1]{C2}; #$ 50,000.00

$workbook-&amp;gt;[1]{cell}[3][2]; #50000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So if you need to perform additional processing on the data you&amp;rsquo;re extracting (such as saving to a database), you probably want to use the &lt;code&gt;{cell}&lt;/code&gt; notation, to obtain clean data. With Spreadsheet::Read array indexes begin at 1, so cell &amp;ldquo;C2&amp;rdquo; is [3][2].&lt;/p&gt;

&lt;p&gt;Perhaps you want to loop through two columns at once and print them? No problem:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;for (2..7) {
    print &amp;quot;$workbook-&amp;gt;[1]{cell}[2][$_]: $workbook-&amp;gt;[1]{cell}[3][$_]\n&amp;quot;; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are some data points which Spreadsheet::Read does not provide: you cannot access the underlying formula of a cell and the styling data is also not available.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:0b46a0650427715cdfe7d0a01e84588d&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Spreadsheet::Read isn&amp;rsquo;t just great for command line apps, it has many uses. Unlike the Microsoft .Net interop library, Perl&amp;rsquo;s Excel interfaces are not single threaded and do not require Excel to be installed to work. Instead Spreadsheet::Read directly parses the Excel file. That makes it possible to process large computing tasks in parallel. Another possible use case is for a spreadsheet upload interface on a web application; Spreadsheet::Read also supports the Libre / Open Office formats as well as CSV text files.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl distributions, modules, packages explained</title>
      <link>http://perltricks.com/article/96/2014/6/13/Perl-distributions--modules--packages-explained/</link>
      <pubDate>Fri, 13 Jun 2014 12:26:00 +0000</pubDate>
      
      <guid>http://perltricks.com/article/96/2014/6/13/Perl-distributions--modules--packages-explained/</guid>
      <description>

&lt;p&gt;&lt;em&gt;It can be confusing for new Perl programmers to understand the terminology used to describe Perl distributions and their accompanying files. This article explains the core concepts.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;package-module-distribution:17113ac399bf5596ee1d46e47a6ce58b&#34;&gt;Package, Module, Distribution&lt;/h3&gt;

&lt;p&gt;A Perl package is just a section of code defined in a .pm file, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;package Data::Connector;

sub connect {
    # do something
    ...
}
1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The start of the package begins with the &amp;ldquo;package&amp;rdquo; declaration. A package is a lot like a class, except that it can denote a collection of subroutines and variables, and not necessarily be instantiated as an object. Usually a .pm file will have one package declaration per file, but you can have multiple packages in a .pm file, similar to Java and C# where you can have multiple classes in a single file.&lt;/p&gt;

&lt;p&gt;A module is a .pm file (&amp;ldquo;pm&amp;rdquo; means Perl Module). When you import a module with &amp;ldquo;require&amp;rdquo; or &amp;ldquo;use&amp;rdquo;, you are literally referencing the file name and not the package(s) contained in the file. For example to import the &amp;ldquo;Data::Connector&amp;rdquo; package defined above, we could save it in a file called &amp;ldquo;Whatever.pm&amp;rdquo; and later reference it in a script like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use Whatever;

# call connect subroutine declared in Data::Connector package
Data::Connector::connect();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All .pm files must end with a &amp;ldquo;true&amp;rdquo; value per Perl&amp;rsquo;s requirements, so most authors either place &amp;ldquo;1;&amp;rdquo; or &amp;ldquo;__PACKAGE__;&amp;rdquo; as the last line of the .pm file. In Perl a true value is any value that is not: null, zero or a zero-length string.&lt;/p&gt;

&lt;p&gt;A distribution is a collection of files that usually includes a Perl module and several other files. There is no strict standard as to which files must be included in a distribution, however for the distribution to be indexed on CPAN and install-able by the CPAN command line client, the distribution needs to include some core files. Distributions have versions - so a Perl module on CPAN will have one distribution for every version of the module. These are the main files and directories you&amp;rsquo;ll encounter in distributions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;README - a brief description of how to install the distribution, sometimes includes a license and examples of how to use the module(s).&lt;/li&gt;
&lt;li&gt;LICENSE - the license for the code - a non-commercial license like the GPL, artistic, BSD etc are common.&lt;/li&gt;
&lt;li&gt;META.yml/ META.json - files that contain the metadata describing the distribution: the author, license, version, pre-requisite modules for use etc. They are auto-generated as part of the distribution build process and can be ignored.&lt;/li&gt;
&lt;li&gt;Makefile.PL and or Build.PL - these are Perl files that are used to install the module(s) in the distribution. Worth looking at when you&amp;rsquo;re having installation issues.&lt;/li&gt;
&lt;li&gt;MANIFEST - a list of the files included in the distribution.&lt;/li&gt;
&lt;li&gt;lib - a directory containing Perl modules - usually the core code of the distribution.&lt;/li&gt;
&lt;li&gt;t - the test files directory. These are run when the module is installed. If you have failing tests on installation, it can be helpful to review the test files in the t/ directory to find out the specifics of the test.&lt;/li&gt;
&lt;li&gt;bin - if the distribution contains an app, (Perl script) it will be in here. Often the app uses modules contained in the lib directory.&lt;/li&gt;
&lt;li&gt;Changes - a list of changes from distribution version to version.&lt;/li&gt;
&lt;li&gt;xt - the extended test files directory, usually used for author tests that you don&amp;rsquo;t need to run.&lt;/li&gt;
&lt;li&gt;eg - a directory of example Perl scripts, using the module(s) contained in the distribution.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are the typical directories and files found in a Perl distribution but as there is no fixed standard, distribution authors are free to include and exclude the files they wish. For a good example, check out the files provided by David Golden in a distribution of the the popular &lt;a href=&#34;https://metacpan.org/source/DAGOLDEN/HTTP-Tiny-0.043&#34;&gt;HTTP::Tiny&lt;/a&gt; module.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:17113ac399bf5596ee1d46e47a6ce58b&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Once you get to grips with Perl packages, modules and distributions it&amp;rsquo;s far easier to start hacking on Perl modules that don&amp;rsquo;t work the way you want them to. For example, in the case of a module that won&amp;rsquo;t install, you can download the distribution from CPAN (at the command line &amp;ldquo;cpan -g Module::Name&amp;rdquo;), untar it, and patch the failing tests, or examine the source code in the lib directory and resolve a bug or two. Before long you&amp;rsquo;ll be releasing your own distributions to CPAN!&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F96%2F2014%2F6%2F13%2FPerl-distributions-modules-packages-explained&amp;amp;text=Perl+distributions%2C+modules%2C+packages+explained&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F96%2F2014%2F6%2F13%2FPerl-distributions-modules-packages-explained&amp;amp;via=perltricks&#34;&gt;tweet&lt;/a&gt; about it!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Parsing data couldn&#39;t be easier with XML::Dataset</title>
      <link>http://perltricks.com/article/87/2014/5/9/Parsing-data-couldn-t-be-easier-with-XML--Dataset/</link>
      <pubDate>Fri, 09 May 2014 03:14:01 +0000</pubDate>
      
      <guid>http://perltricks.com/article/87/2014/5/9/Parsing-data-couldn-t-be-easier-with-XML--Dataset/</guid>
      <description>

&lt;p&gt;&lt;em&gt;It&amp;rsquo;s hard to believe that when it comes to XML parsing CPAN hasn&amp;rsquo;t already got you covered, but &lt;a href=&#34;https://metacpan.org/pod/XML::Dataset&#34;&gt;XML::Dataset&lt;/a&gt; is a new module that fills a useful void. XML::Dataset let&amp;rsquo;s you declare a plaintext data collection schema, and then goes and extracts the data for you, super fast. Read on to see how it works.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;requirements:2f6e0c408059a4f921b8d668bba7c6d3&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;The CPAN Testers results &lt;a href=&#34;http://matrix.cpantesters.org/?dist=XML-Dataset+0.006&#34;&gt;show&lt;/a&gt; that XML::Dataset v0.06 will run on any platform with Perl (down to 5.8.9). To install the module with CPAN, open up the terminal and type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;$ cpan XML::Dataset
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;your-data-extracted:2f6e0c408059a4f921b8d668bba7c6d3&#34;&gt;Your data, extracted&lt;/h3&gt;

&lt;p&gt;To use XML::Dataset you&amp;rsquo;ll need some stringified XML source data and a data profile. A profile is just a plaintext schema which specifies the data you&amp;rsquo;d like to extract. Let&amp;rsquo;s look at an example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use XML::Dataset;
use Data::Printer;

my $sample_data = q(&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;colleagues&amp;gt;
    &amp;lt;colleague&amp;gt;
        &amp;lt;title&amp;gt;The Boss&amp;lt;/title&amp;gt;
        &amp;lt;phone&amp;gt;+1 202-663-9108&amp;lt;/phone&amp;gt;
    &amp;lt;/colleague&amp;gt;
    &amp;lt;colleague&amp;gt;
        &amp;lt;title&amp;gt;Admin Assistant&amp;lt;/title&amp;gt;
        &amp;lt;phone&amp;gt;+1 347-999-5454&amp;lt;/phone&amp;gt;
        &amp;lt;email&amp;gt;inbox@the_company.com&amp;lt;/email&amp;gt;
    &amp;lt;/colleague&amp;gt;
    &amp;lt;colleague&amp;gt;
        &amp;lt;title&amp;gt;Minion&amp;lt;/title&amp;gt;
        &amp;lt;phone&amp;gt;+1 792-123-4109&amp;lt;/phone&amp;gt;
    &amp;lt;/colleague&amp;gt;
&amp;lt;/colleagues&amp;gt;);

my $sample_data_profile
    = q(colleagues
            colleague
                title   = dataset:colleagues
                email   = dataset:colleagues
                phone   = dataset:colleagues);

p parse_using_profile($sample_data, $sample_data_profile);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above declares a simple XML dataset ($sample_data) and a data profile to extract the required data ($sample_data_profile). XML::Dataset requires every indented newline in the data profile to map to another nested level of the data set. Once we reach the data attributes we want to extract, we simply assign a dataset to them (dataset:colleagues).&lt;/p&gt;

&lt;p&gt;XML::Dataset exports the &amp;ldquo;parse_using_profile&amp;rdquo; function which extracts the data using our data profile and returns a Perl data structure. We use &lt;a href=&#34;https://metacpan.org/pod/Data::Printer&#34;&gt;Data::Printer&lt;/a&gt; to print out the results. Running this code we get this output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;\ {
    colleagues   [
        [0] {
            phone   &amp;quot;+1 202-663-9108&amp;quot;,
            title   &amp;quot;The Boss&amp;quot;
        },
        [1] {
            email   &amp;quot;inbox@the_company.com&amp;quot;,
            phone   &amp;quot;+1 347-999-5454&amp;quot;,
            title   &amp;quot;Admin Assistant&amp;quot;
        },
        [2] {
            phone   &amp;quot;+1 792-123-4109&amp;quot;,
            title   &amp;quot;Minion&amp;quot;
        },
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that XML::Dataset had no problem extracting the one email address that was present in the data, even though the other colleagues did not have that attribute. What if we wanted to collect emails and phone numbers, but in separate datasets? All we need to do is update $sample_data_profile with two datasets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;my $sample_data_profile
    = q(colleagues
            colleague
                title   = dataset:emails dataset:phones
                email   = dataset:emails
                phone   = dataset:phones);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Re-running the code, XML::Dataset now produces two datasets for us:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;\ {
    emails   [
        [0] {
            title   &amp;quot;The Boss&amp;quot;
        },
        [1] {
            email   &amp;quot;inbox@the_company.com&amp;quot;,
            title   &amp;quot;Admin Assistant&amp;quot;
        },
        [2] {
            title   &amp;quot;Minion&amp;quot;
        }
    ],
    phones   [
        [0] {
            phone   &amp;quot;+1 202-663-9108&amp;quot;,
            title   &amp;quot;The Boss&amp;quot;
        },
        [1] {
            phone   &amp;quot;+1 347-999-5454&amp;quot;,
            title   &amp;quot;Admin Assistant&amp;quot;
        },
        [2] {
            phone   &amp;quot;+1 792-123-4109&amp;quot;,
            title   &amp;quot;Minion&amp;quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-real-example:2f6e0c408059a4f921b8d668bba7c6d3&#34;&gt;A real example&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s write a program to parse a a more realistic data set. Many websites provide a sitemap that lists all of the content on the website, and when it was last updated. This information is used by search engines to optimize their crawling routines. The sitemap has a defined xml format, so it&amp;rsquo;s a cinch to parse it with XML::Dataset:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;use strict;
use warnings;
use XML::Dataset;
use Data::Printer;
use HTTP::Tiny;

my $url = &#39;http://perltricks.com/sitemap.xml&#39;;

my $sitemap_data 
    = HTTP::Tiny-&amp;gt;new-&amp;gt;get($url)-&amp;gt;{content};

my $sitemap_data_profile
    = q(urlset
            url
                loc     = dataset:sitemap_locations_modified
                lastmod = dataset:sitemap_locations_modified);

p parse_using_profile($sitemap_data, $sitemap_data_profile);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above downloads the PerlTricks.com sitemap using &lt;a href=&#34;https://metacpan.org/pod/HTTP::Tiny&#34;&gt;HTTP::Tiny&lt;/a&gt; and extracts every URL and last modified timestamp from the sitemap. Running the code, we get this output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;\ {
    sitemap_locations_modified   [
        [0]  {
            lastmod   &amp;quot;2014-05-09&amp;quot;,
            loc       &amp;quot;http://perltricks.com/&amp;quot;
        },
        [1]  {
            lastmod   &amp;quot;2013-03-24&amp;quot;,
            loc       &amp;quot;http://perltricks.com/article/1/2013/3/24/3-quick-ways-to-find-out-the-version-number-of-an-installed-Perl-module-from-the-terminal&amp;quot;
        },
        [2]  {
            lastmod   &amp;quot;2013-03-27&amp;quot;,
            loc       &amp;quot;http://perltricks.com/article/3/2013/3/27/How-to-cleanly-uninstall-a-Perl-module&amp;quot;
        },
        ...
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;No problem! We could re-use that same program to download and parse any sitemap on the Internet.&lt;/p&gt;

&lt;h3 id=&#34;conclusion:2f6e0c408059a4f921b8d668bba7c6d3&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;XML::Dataset is fantastic for extracting fixed data schemas from XML. The plaintext data profiles are so easy to use, a non-programmer could write them. XML::Dataset is also fast: under the hood it uses XML::LibXML (and a few optimizations) and could be adapted for well-formatted HTML. It has great &lt;a href=&#34;https://metacpan.org/pod/XML::Dataset&#34;&gt;documentation&lt;/a&gt; and offers some advanced features like partial dataset parse dispatching. Module author James Spurin deserves credit for producing a quality module and a welcome addition to CPAN&amp;rsquo;s XML namespace.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Do you have a much-loved CPAN module that you&amp;rsquo;d like us to cover? Drop us an &lt;a href=&#34;mailto:perltricks.com@gmail.com&#34;&gt;email&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Cover image &lt;a href=&#34;https://creativecommons.org/licenses/by/2.0/&#34;&gt;©&lt;/a&gt; &lt;a href=&#34;https://www.flickr.com/photos/dullhunk/3948166814/in/photolist-71TorC-5RcLVC-5RcLk1-5R8vpe-5RcMC9-5R8w7D-5R8v7e-5RcM9Q-5RcLeL-5R8upk-5RcMso-5RcL7J-72QCEU-7KoKym-72QCsE-6FtTJ-6m6pyB-5AJCpY-6FvjN-6FuLy-6FtQL-6Fv4J-5BHeXd-6FuUe-6FtXH-6Fu9t-6FuAs-5AJCs3-5AJCsd-5AJCro-tS2dS-6kzkkD-6kDvjQ-6kDAtY-6kDvzS-6kD45L-6kzqYM-6kDvsE-6kDuys-6kDvcE-6m6prT-6kDupU-6kDuWw-6kDv6j-6kzkd2-6kDALo-5AJCsA-CJhVy-5AJCrN-5MzAkw&#34;&gt;Duncun Hull&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An interview with Steven Haryanto</title>
      <link>http://perltricks.com/article/62/2014/1/24/An-interview-with-Steven-Haryanto/</link>
      <pubDate>Fri, 24 Jan 2014 03:17:09 +0000</pubDate>
      
      <guid>http://perltricks.com/article/62/2014/1/24/An-interview-with-Steven-Haryanto/</guid>
      <description>&lt;p&gt;&lt;em&gt;Steven Haryanto is a Perl programmer and &lt;a href=&#34;https://metacpan.org/author/SHARYANTO&#34;&gt;prolific CPAN author&lt;/a&gt;. We recently caught up with him to discuss his development approach and the tools he uses to be be so productive. (Steven tells us that the photo above is representative of his hometown, Bandung).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;According the recent &lt;a href=&#34;http://neilb.org/cpan-report/&#34;&gt;CPAN report&lt;/a&gt;, you made 769 releases to CPAN last year. How did you become so productive!?&lt;/strong&gt;
 For what it&amp;rsquo;s worth, I made over 900 releases in 2012, so 2013 is not *that* productive by comparison. Two things made it possible really: a dist build/release tool (I happen to use &lt;a href=&#34;https://metacpan.org/pod/Dist::Zilla&#34;&gt;Dist::Zilla&lt;/a&gt;) and the fact that I produce lots of mistakes/bugs :-)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Of those releases, is there any one in particular that stands out as a significant milestone for you?&lt;/strong&gt;
 To be honest, no. Things are going mostly incrementally nowadays, which I&amp;rsquo;m happy with. This means I haven&amp;rsquo;t needed to rewrite or redesign a module from scratch so far (well there are a couple of partial rewrites, but not very major).&lt;/p&gt;

&lt;p&gt;The overwhelming majority of modules which I publish on CPAN are those which I use by myself or for work. Currently only a few of those have been confirmed to be used by at least one other person. This includes &lt;a href=&#34;https://metacpan.org/pod/Org::Parser&#34;&gt;Org::Parser&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Data:Sah&#34;&gt;Data::Sah&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Gepok&#34;&gt;Gepok&lt;/a&gt;,&lt;a href=&#34;https://metacpan.org/pod/Data::Dump::Color&#34;&gt;Data::Dump::Color&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Progress::Any&#34;&gt;Progress::Any&lt;/a&gt;, &lt;a href=&#34;https://metacpan.org/pod/Log::Any::App&#34;&gt;Log::Any::App&lt;/a&gt;, and &lt;a href=&#34;https://metacpan.org/pod/Text::ANSITable&#34;&gt;Text::ANSITable&lt;/a&gt; (only the last one was created in 2013). In 2012 I released 166 new distributions and in 2013 only 71. So 2013 was more about updates and improvements instead of creating new things.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You&amp;rsquo;ve talked in the past about &amp;ldquo;distribution oriented development&amp;rdquo;, do you still follow that approach, and why?&lt;/strong&gt;
 Yup, because making software modular keeps me from going insane, and modules and distributions are the units of modularity in Perl.&lt;/p&gt;

&lt;p&gt;Do you find developing as if you&amp;rsquo;re going to release the module forces you to follow better coding practices? (Like writing tests, documentation, error checking).&lt;/p&gt;

&lt;p&gt;Definitely. The coding practices for a Perl module and distribution are relatively established, so following them is a no-brainer. The already existing tools help too, relieving me from having to reinvent wheels.&lt;/p&gt;

&lt;p&gt;What text editor / IDE do you use to code in Perl? Why do you use that tool, have you tried others and prefer it?&lt;/p&gt;

&lt;p&gt;As some of you might know, I&amp;rsquo;m a fan of org-mode, so I&amp;rsquo;m stuck with Emacs for the time being. Not a very advanced user of both, though. I&amp;rsquo;ve also used Komodo IDE in the past, its regex debugger tool is neat. I&amp;rsquo;ve tried Padre too a while back, but due to installation issues I haven&amp;rsquo;t tried it again.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Org-mode looks cool! - as a Perl developer which feature(s) of org-mode do you use the most?&lt;/strong&gt;
 Nothing Perl-specific, actually. I use org-mode like most other people (non-Perl-programmers and non-programmers alike): to organize my todo lists and to take notes. I also happen to write &lt;a href=&#34;https://metacpan.org/pod/Org::Parser&#34;&gt;Org::Parser&lt;/a&gt;, because no such module exists at the time, and this helps me create some scripts to process and summarize the Org documents which I write. For example I keep a daily statistics of the number of done/undone todo items, to record my progress. I do my time bookkeeping on an Org document using a simple, homegrown format. The todo reminder which I run from a shell startup file is also written in Perl.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m also starting to use Org to write software product documentation, and later export to HTML (and then to PDF). There will probably be another CPAN module or two once the workflow is more defined.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I keep a daily statistics of the number of done/undone todo items, to record my progress&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;You&amp;rsquo;ve also mentioned use of tmux / screen. Could you explain how those terminal tools help your development?&lt;/strong&gt;
 I rarely use them these days, except when on slow and unreliable connections, which fortunately is occurring less frequently where I live. Normally Konsole suffices. But I do maintain screen sessions on servers I&amp;rsquo;m monitoring.&lt;/p&gt;

&lt;p&gt;Terminals is where I work most of the time though, so a lot of my CPAN modules are related to command-line application and terminals.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;In your blog post (&amp;rdquo;&lt;a href=&#34;http://blogs.perl.org/users/steven_haryanto/2013/10/how-i-manage-my-perl-distributions.html&#34;&gt;How I manage my distributions&lt;/a&gt;&amp;rdquo;) you said you use Dist::Zilla to manage your distributions. Could you elaborate on how Dist::Zilla helps you be more productive?&lt;/strong&gt;
 &lt;a href=&#34;https://metacpan.org/pod/Dist::Zilla&#34;&gt;Dist::Zilla&lt;/a&gt; (or an equivalent tool) frees us from doing the boring and tedious parts of distribution building/releasing, allowing us to focus on writing code and encourages us to do more releases. Doing a new release can be done in a few seconds instead of a few minutes. With dozens or hundreds of distributions, it&amp;rsquo;s simply impossible to do things manually.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What are your favourite Dist::Zilla plugins?&lt;/strong&gt;
 No one plugin in particular, perhaps &lt;a href=&#34;https://metacpan.org/pod/Dist::Zilla::Plugin::OurPkgVersion&#34;&gt;OurPkgVersion&lt;/a&gt; (simply because its big brother, &lt;a href=&#34;https://metacpan.org/pod/Dist::Zilla::Plugin::PkgVersion&#34;&gt;PkgVersion,&lt;/a&gt; modifies line numbers). &lt;a href=&#34;https://metacpan.org/pod/Dist::Zilla::Plugin::Run&#34;&gt;Run&lt;/a&gt; is also nifty too. But the great thing about Dist::Zilla is that when the existing plugins don&amp;rsquo;t cut it, you can simply create your own plugins to do the specific things you need. I&amp;rsquo;ve written a few myself.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;the great thing about Dist::Zilla is that when the existing plugins don&amp;rsquo;t cut it, you can simply create your own plugins to do the specific things you need.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Does your framework, Rinci help you with your development process?&lt;/strong&gt;
 Most certainly. Without the &lt;a href=&#34;https://metacpan.org/pod/Perinci&#34;&gt;Perinci&lt;/a&gt; tools I wouldn&amp;rsquo;t have written and released as many stuffs. They allow me to avoid or minimize doing boring and repetitive things which I hate doing, like writing POD, &lt;a href=&#34;https://metacpan.org/pod/Getopt::Long::Spec&#34;&gt;Getopt::Long spec&lt;/a&gt;, command-line usage message, and so on. Like Dist::Zilla they let me focus on writing actual code instead.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Do you use any static code analysis tools like Perl::Critic?&lt;/strong&gt;
 Currently, no. I should though. Maybe the thought of having to do lots of initial configuration and tweaking makes me put it off.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You&amp;rsquo;re previously &lt;a href=&#34;http://blogs.perl.org/users/steven_haryanto/2012/11/the-sad-state-of-syntax-highlighting-libraries-on-cpan.html&#34;&gt;noted&lt;/a&gt; Perl&amp;rsquo;s lack of a good syntax highlighting library. Do you think that&amp;rsquo;s still the case today ?&lt;/strong&gt;
 Haven&amp;rsquo;t checked back; I even forget why I need a syntax highlighting library in the first place. I think it&amp;rsquo;s still the case and I&amp;rsquo;ve come to accept it. At least there are other tools available, not everything needs to be done in Perl. &lt;a href=&#34;https://metacpan.org/pod/PPI::HTML&#34;&gt;PPI::HTML&lt;/a&gt; is for highlighting Perl code and not other languages, right?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Any other thought about the Perl community or development that you think people should be aware of?&lt;/strong&gt;
 Since Perl is a swiss-army knife tool, including as a shell script replacement and for writing command-line programs, I wish authors would pay more attention to startup overhead. It seems lots of prominent CPAN authors are mostly concerned only with writing pretty OO code or PSGI webapps or long-running daemons, but the truth is Perl is more than that. So I will certainly encourage and promote good lightweight alternatives of popular libraries like &lt;a href=&#34;https://metacpan.org/pod/Moose&#34;&gt;Moose,&lt;/a&gt; &lt;a href=&#34;https://metacpan.org/pod/DateTime&#34;&gt;DateTime,&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Log::Log4perl&#34;&gt;Log::Log4perl&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I wish authors would pay more attention to startup overhead.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;What&amp;rsquo;s next for you in terms of your development process, what are you looking forward to trying?&lt;/strong&gt;
 I will keep churning out CPAN modules to do my part in giving back to the Perl community. My current focus areas are: Indonesian-related (language/locale) modules , making bad-ass command-line programs with Perl, as well as other tools/libraries to cut back the boilerplate and emphasize the DRY principle.&lt;/p&gt;

&lt;p&gt;One project in the works is &lt;a href=&#34;http://cpanlists.org/&#34;&gt;cpanlists.org&lt;/a&gt; (not up yet), which will be a simple website and service to manage lists of authors and CPAN modules, along with comment and rating for each author/module. It&amp;rsquo;s much like an Amazon Listmania list, and I&amp;rsquo;ve blogged in the past about wanting to create something like it. I put it up mainly to publish my own notes as well as a proof-of-concept for Riap::HTTP, a protocol for a developer-friendly API service.&lt;/p&gt;

&lt;p&gt;People will be able to maintain a list of their favorite modules. This is already possible with ++ in MetaCPAN, but with MetaCPAN I can&amp;rsquo;t add notes for each module or rate each module. To rate modules one must use a separate service (&lt;a href=&#34;http://cpanratings.perl.org/&#34;&gt;CPAN Ratings&lt;/a&gt;). Also I want to create multiple lists aside from a single favorites list, for example: list of recommended modules to do X (e.g. logging or convert Markdown to POD), list of modules to avoid because of X (e.g. heavy startup overhead, high number of bugs), and so on.&lt;/p&gt;

&lt;p&gt;When lots of people create their lists, this will help users evaluate and choose the right CPAN modules for their needs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Find CPAN mirrors and configure the local CPAN mirror list</title>
      <link>http://perltricks.com/article/44/2013/10/20/Find-CPAN-mirrors-and-configure-the-local-CPAN-mirror-list/</link>
      <pubDate>Sun, 20 Oct 2013 19:07:00 +0000</pubDate>
      
      <guid>http://perltricks.com/article/44/2013/10/20/Find-CPAN-mirrors-and-configure-the-local-CPAN-mirror-list/</guid>
      <description>

&lt;p&gt;CPAN mirrors are online repositories which host or &amp;ldquo;mirror&amp;rdquo; the Perl module distributions on CPAN. There are hundreds of CPAN mirrors dispersed throughout the World. When the CPAN program is run for the first time on a machine, it will configure the CPAN mirror list to use for checking for new versions of modules and downloading Perl distributions. All CPAN mirrors are not created equally though: the distribution list&amp;rsquo;s age, speed and the geographic location vary from mirror to mirror and so you may want to re-configure your local CPAN mirror list to suit your needs. This article describes how to find CPAN mirrors and edit the local CPAN mirror configuration.&lt;/p&gt;

&lt;h3 id=&#34;finding-cpan-mirrors:6b39c76ec4be1267597fa5bb07945eee&#34;&gt;Finding CPAN mirrors&lt;/h3&gt;

&lt;p&gt;An online list of public CPAN mirrors can be found &lt;a href=&#34;http://mirrors.cpan.org/&#34;&gt;here&lt;/a&gt;. The list is frequently updated and lists mirrors by location, the scheme used (ftp, http), the age of the module list and some test results. Viewing this list you can see that some mirrors do not refresh their module list for days at a time - if you are using these mirrors you could be missing out on the latest version of your favourite module! A JSON formatted CPAN mirror list can be found &lt;a href=&#34;http://www.cpan.org/indices/mirrors.json&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;start-the-cpan-shell:6b39c76ec4be1267597fa5bb07945eee&#34;&gt;Start the CPAN shell&lt;/h3&gt;

&lt;p&gt;Once you have identified the URLs of the CPAN mirrors you want to use, fire up the terminal and load the cpan shell:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cpan

cpan shell -- CPAN exploration and modules installation (v2.00)
Enter &#39;h&#39; for help.

cpan[1]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;view-the-local-cpan-mirror-list:6b39c76ec4be1267597fa5bb07945eee&#34;&gt;View the local CPAN mirror list&lt;/h3&gt;

&lt;p&gt;The CPAN mirror list is stored in the &amp;ldquo;urllist&amp;rdquo; variable. To view the list of mirrors, type &amp;ldquo;o conf urllist&amp;rdquo; in the CPAN shell:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cpan[1]&amp;gt;o conf urllist
    urllist           
    0 [http://httpupdate3.cpanel.net/CPAN/]
    1 [http://httpupdate23.cpanel.net/CPAN/]
    2 [http://mirrors.servercentral.net/CPAN/]
    3 [ftp://cpan.cse.msu.edu/]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;add-a-cpan-mirror:6b39c76ec4be1267597fa5bb07945eee&#34;&gt;Add a CPAN mirror&lt;/h3&gt;

&lt;p&gt;To add a CPAN mirror use the &amp;ldquo;unshift&amp;rdquo; or &amp;ldquo;push&amp;rdquo; functions to add the mirror&amp;rsquo;s url to the front or end of the mirror list. Make sure that the URL for the mirror &lt;strong&gt;includes the scheme&lt;/strong&gt; (http, ftp).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cpan[2]&amp;gt; o conf urllist push http://mirror.waia.asn.au/pub/cpan/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;remove-a-cpan-mirror:6b39c76ec4be1267597fa5bb07945eee&#34;&gt;Remove a CPAN mirror&lt;/h3&gt;

&lt;p&gt;To remove a CPAN mirror use the &amp;ldquo;shift&amp;rdquo; or &amp;ldquo;pop&amp;rdquo; functions to remove the mirror URL from the front or end of the mirror list:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cpan[3]&amp;gt; o conf urllist pop
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;completely-replace-the-existing-mirror-list:6b39c76ec4be1267597fa5bb07945eee&#34;&gt;Completely replace the existing mirror list&lt;/h3&gt;

&lt;p&gt;To overwrite the existing mirror list with a new one, just provide the URLs to the new mirrors as a space separated list:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cpan[4]&amp;gt; o conf urllist http://mirror.waia.asn.au/pub/cpan/ ftp://mirrors.coopvgg.com.ar/CPAN/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;saving-changes:6b39c76ec4be1267597fa5bb07945eee&#34;&gt;Saving changes&lt;/h3&gt;

&lt;p&gt;Once you have updated the CPAN mirror list, make sure you commit the changes to file so they are saved beyond the current session:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cpan[5]&amp;gt; o conf commit
commit: wrote &#39;/home/sillymoose/.cpan/CPAN/MyConfig.pm&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;edit-the-cpan-configuration-file-directly:6b39c76ec4be1267597fa5bb07945eee&#34;&gt;Edit the CPAN configuration file directly&lt;/h3&gt;

&lt;p&gt;You can also edit the CPAN config file directly. For local user Perl installations this is */CPAN/MyConfig.pm and system Perl installations */CPAN/Config.pm (the parent directory will depend on the platform). When editing the file, urllist is a hash key for an array reference of mirror urls. Note the urls are quoted using Perl&amp;rsquo;s quoting operator (&amp;ldquo;q&amp;rdquo;). Simply edit and save the file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;&#39;urllist&#39; =&amp;gt; [
    q[http://httpupdate3.cpanel.net/CPAN/], 
    q[http://httpupdate23.cpanel.net/CPAN/], 
    q[http://mirrors.servercentral.net/CPAN/], 
    q[ftp://cpan.cse.msu.edu/]
],
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>How to track new CPAN releases</title>
      <link>http://perltricks.com/article/33/2013/7/29/How-to-track-new-CPAN-releases/</link>
      <pubDate>Mon, 29 Jul 2013 01:11:31 +0000</pubDate>
      
      <guid>http://perltricks.com/article/33/2013/7/29/How-to-track-new-CPAN-releases/</guid>
      <description>

&lt;p&gt;CPAN is a fantastic Perl resource with thousands of modules and new ones being added all the time. But how do you keep track of what&amp;rsquo;s being released? This article describes three techniques for keeping tabs on the latest CPAN releases.&lt;/p&gt;

&lt;h3 id=&#34;cpan-org:1bfc29f171e882ce9b1eb00fa28d0101&#34;&gt;CPAN.org&lt;/h3&gt;

&lt;p&gt;The CPAN website&amp;rsquo;s &lt;a href=&#34;http://search.cpan.org/recent&#34;&gt;recent uploads&lt;/a&gt; page maintains a list of the latest CPAN releases, with links to the module documentation. Additionally it&amp;rsquo;s possible to search the release history using the navigating arrow links at the top of the page.&lt;/p&gt;

&lt;h3 id=&#34;cpan-recent-uploads:1bfc29f171e882ce9b1eb00fa28d0101&#34;&gt;CPAN::Recent::Uploads&lt;/h3&gt;

&lt;p&gt;Chris Williams&amp;rsquo; &lt;a href=&#34;https://metacpan.org/module/CPAN::Recent::Uploads&#34;&gt;CPAN::Recent::Uploads&lt;/a&gt; module offers a programmatic interface to track recent CPAN uploads. It provides a &amp;ldquo;recent&amp;rdquo; function that accepts two optional arguments: the time from which to view uploads since and the URL of the CPAN mirror to use. By default it will return a list of modules released in the past week on the CPAN mirror &amp;ldquo;&lt;a href=&#34;ftp://ftp.funet.fi/pub/CPAN/&amp;quot;&#34;&gt;ftp://ftp.funet.fi/pub/CPAN/&amp;quot;&lt;/a&gt;. The module&amp;rsquo;s &lt;a href=&#34;https://metacpan.org/module/CPAN::Recent::Uploads&#34;&gt;documentation&lt;/a&gt; also has an example Perl one liner. To see CPAN::Recent::Uploads in action, enter this at the command-line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# print a list of this week&#39;s CPAN releases
perl -MCPAN::Recent::Uploads -le &amp;quot;print for CPAN::Recent::Uploads-&amp;gt;recent;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;twitter:1bfc29f171e882ce9b1eb00fa28d0101&#34;&gt;Twitter&lt;/h3&gt;

&lt;p&gt;The Twitter account &lt;a href=&#34;https://twitter.com/cpan_new&#34;&gt;CPAN New Modules&lt;/a&gt; tweets every new CPAN release. The author Punytan has also released the source code on &lt;a href=&#34;https://t.co/K7KnELaYzk&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can subscribe to the stream by clicking this button: &lt;a href=&#34;https://twitter.com/cpan_new&#34;&gt;Follow @cpan_new&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Upload to CPAN from the command line</title>
      <link>http://perltricks.com/article/31/2013/6/30/Upload-to-CPAN-from-the-command-line/</link>
      <pubDate>Sun, 30 Jun 2013 03:44:12 +0000</pubDate>
      
      <guid>http://perltricks.com/article/31/2013/6/30/Upload-to-CPAN-from-the-command-line/</guid>
      <description>

&lt;p&gt;The Perl module &lt;a href=&#34;https://metacpan.org/module/CPAN::Uploader&#34;&gt;CPAN::Uploader&lt;/a&gt; comes with a neat command line application called &lt;a href=&#34;https://metacpan.org/module/RJBS/CPAN-Uploader-0.103004/bin/cpan-upload&#34;&gt;cpan-upload&lt;/a&gt; which allows Perl module authors to upload to CPAN from the command line. This article describes how to install cpan-upload and use it.&lt;/p&gt;

&lt;p&gt;To upload modules to CPAN you must have a registered &lt;a href=&#34;http://pause.perl.org/pause/query&#34;&gt;PAUSE&lt;/a&gt; account. Registration is free and an account is usually activated within 24 hours. Once you have a registered PAUSE account, install CPAN::Uploader via the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cpan CPAN::Uploader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once CPAN::Uploader has installed (it has a bunch of dependencies, including C libraries for NetSSLeay) at the command line type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cpan-upload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see the cpan-upload help output displayed:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;Please provide at least one file name.
usage: cpan-upload [options] file-to-upload
    -v --verbose       enable verbose logging
    -h --help          display this help message
    --dry-run          do not actually upload anything
                     
    -u --user          your PAUSE username
    -p --password      the password to your PAUSE account
    -d --directory     a dir in your CPAN space in which to put the files
    --http-proxy       URL of the http proxy to use in uploading
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-step-method:9253a99b6a8c2591d3b7e3b70155f9ec&#34;&gt;1 Step method&lt;/h3&gt;

&lt;p&gt;To upload a file to PAUSE, the syntax is like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cpan-upload -u username -p password My-App-0.01.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where username and password are your PAUSE account credentials followed by the filepath(s) to the files you want to upload. On a successful load, cpan-upload will display the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;registering upload with PAUSE web server
POSTing upload for My-App-0.01.tar.gz to https://pause.perl.org/pause/authenquery
PAUSE add message sent ok [200]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-step-method-recommended:9253a99b6a8c2591d3b7e3b70155f9ec&#34;&gt;2 step method (recommended)&lt;/h3&gt;

&lt;p&gt;The 2 step method involves calling cpan-upload with just your username and the filepath to the files to be uploaded. cpan-upload will then prompt for your password, which is entered directly into Perl, in a hidden format:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;cpan-upload -u sillymoos My-App-0.01.tar.gz 
PAUSE Password:
POSTing upload for My-App-0.01.tar.gz to https://pause.perl.org/pause/authenquery
PAUSE add message sent ok [200]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; cpan-upload transmits your credentials via HTTPS (encrypted) to the PAUSE server, but with the 1 step method you do have to type your password in plaintext. which is a security risk as many operating systems will store them in logs, and/or process details. Simply searching through the Terminal history will reveal your PAUSE password. Additionally, someone could read your password as it&amp;rsquo;s typed in. The 2 step method reduces this risk as the password is not logged in the terminal, but goes directly into the Perl program, and the password is not visible on the screen when typed. That said, the password can still be extracted from the computer by a stack trace or system call search. cpan-upload does have the ability to read the credentials from a .pause file in your home directory, which is a slightly more secure method than the 1 step method (although storing passwords in plaintext files raises its own security vulnerabilities). Of these three options the 2 step method seems to be the most secure.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Installing Perl modules with C library dependencies</title>
      <link>http://perltricks.com/article/19/2013/4/15/Installing-Perl-modules-with-C-library-dependencies/</link>
      <pubDate>Mon, 15 Apr 2013 18:37:26 +0000</pubDate>
      
      <guid>http://perltricks.com/article/19/2013/4/15/Installing-Perl-modules-with-C-library-dependencies/</guid>
      <description>

&lt;p&gt;Some Perl modules have specific C library dependencies that need to be met or else they won&amp;rsquo;t install. These issues can be tricky to solve as CPAN is not able to automatically install or report on non-Perl dependencies and Google isn&amp;rsquo;t good at returning useful results for these types of issues (&lt;a href=&#34;https://metacpan.org/module/MIKEM/Net-SSLeay-1.54/lib/Net/SSLeay.pod&#34;&gt;Net::SSLeay&lt;/a&gt; is a common example of a tricky module to install). Usually you will only find out about missing dependencies when trying to install the module, as the install will fail. What you need to do at this point is &lt;strong&gt;identify&lt;/strong&gt; and &lt;strong&gt;install&lt;/strong&gt; the missing C libraries.&lt;/p&gt;

&lt;h3 id=&#34;identifying-c-library-dependencies:12040641a686db63029ae6c41a9f1d99&#34;&gt;Identifying C Library dependencies&lt;/h3&gt;

&lt;p&gt;Here are some places to check for dependencies:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Install error message&lt;/strong&gt; - scan the command line output from the failed install: often Perl developers will write specific error messages that indicate the missing C library.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Module documentation&lt;/strong&gt; - check the main POD page for the module on &lt;a href=&#34;https://metacpan.org/&#34;&gt;metacpan&lt;/a&gt; it may indicate which C libraries are required.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distribution files&lt;/strong&gt; - check the README and INSTALL files that come with the distribution for the module you are trying to install. If available they will be in the root directory of the tarball. You can browse these files online at &lt;a href=&#34;https://metacpan.org/&#34;&gt;metacpan&lt;/a&gt; by searching for the module, then clicking the &amp;lsquo;browse&amp;rsquo; link on the module&amp;rsquo;s main page.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Search your package manager&lt;/strong&gt; - look at the technologies and keywords associated with the module. For example &lt;a href=&#34;https://metacpan.org/module/MIKEM/Net-SSLeay-1.54/lib/Net/SSLeay.pod&#34;&gt;Net::SSLeay&lt;/a&gt; probably has something to do with SSL, so search for Perl-related SSL packages (example below).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;installing-c-library-dependencies:12040641a686db63029ae6c41a9f1d99&#34;&gt;Installing C library dependencies&lt;/h3&gt;

&lt;p&gt;Once you have identified the missing C libraries, you need to install them. If you are on Linux, this can be done using a package manager and searching for and installing the package containing the C library:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-prettyprint&#34;&gt;# yum package manager
$ sudo yum search ssl
...
sudo yum install openssl-perl.x86_64 perl-Net-SSLeay.x86_64 perl-Crypt-SSLeay.x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are not on Linux, try downloading the library directly from the C library&amp;rsquo;s homepage - these are easy to find via Google and usually have specific Windows / OSX distributions.&lt;/p&gt;

&lt;p&gt;Once you have installed the requisite libraries, try installing the Perl module again with CPAN.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

