<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software-Engineering on Code - a programming blog</title>
    <link>https://blog.dnmfarrell.com/tags/software-engineering/</link>
    <description>Recent content in Software-Engineering on Code - a programming blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 Jan 2025 09:45:40 -0500</lastBuildDate>
    <atom:link href="https://blog.dnmfarrell.com/tags/software-engineering/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The Nature of Computing Innovation</title>
      <link>https://blog.dnmfarrell.com/post/nature-of-innovation/</link>
      <pubDate>Tue, 21 Jan 2025 09:45:40 -0500</pubDate>
      <guid>https://blog.dnmfarrell.com/post/nature-of-innovation/</guid>
      <description>&lt;p&gt;In his book &lt;a href=&#34;https://www.amazon.com/Nature-Technology-What-How-Evolves/dp/1416544062&#34;&gt;The Nature of Technology&lt;/a&gt;, W. Brian Arthur describes technology as combinations of other technologies. This description poses a couple of questions for software.&lt;/p&gt;&#xA;&lt;p&gt;First, take a program like Git. To figure out what technologies Git is made of, perhaps all we have to do is inspect its dependencies? Surprisingly, Git has few real dependencies.¹&lt;/p&gt;&#xA;&lt;p&gt;Second, note how Arthur&amp;rsquo;s description of technology is recursive — where does it end? His answer is in elemental technologies. These are technologies which deliver an effect based on a natural phenomenon:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Novelty In Software Engineering</title>
      <link>https://blog.dnmfarrell.com/post/novelty/</link>
      <pubDate>Mon, 16 Dec 2024 12:41:35 -0500</pubDate>
      <guid>https://blog.dnmfarrell.com/post/novelty/</guid>
      <description>&lt;p&gt;In the 1940s Bell Aircraft used an experimental approach to build the first commercial helicopter:¹&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;q&gt;At Gardenville, we built things, tested them, modified them until they worked, and then made the drawings.&lt;/q&gt;&#xA;&#xA;&lt;p class=&#34;source&#34;&gt;&amp;mdash;&amp;nbsp;The Bell Notes, Arthur M. Young, &lt;em&gt;&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;The project manager contrasted this with how they built airplanes:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;q&gt;The main engineering group made drawings, sent them to the plant, and only the project manager ever saw the product fly. This was successful with airplanes because the airplane did not involve unknowns …&lt;/q&gt;&#xA;&#xA;&lt;p class=&#34;source&#34;&gt;&amp;mdash;&amp;nbsp;The Bell Notes, Arthur M. Young, &lt;em&gt;&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Microservices Reify Compute</title>
      <link>https://blog.dnmfarrell.com/post/microservices-reify-compute/</link>
      <pubDate>Tue, 10 Dec 2024 10:59:33 -0500</pubDate>
      <guid>https://blog.dnmfarrell.com/post/microservices-reify-compute/</guid>
      <description>&lt;p&gt;Twenty five years ago the most popular solution for web apps was known as &amp;ldquo;LAMP&amp;rdquo; (Linux, Apache, MySQL, PHP). A typical web app today, deployed with Kubernetes might comprise of 5x as many technologies. That we don&amp;rsquo;t use such acronyms anymore tells us something about how software engineering has changed.&lt;/p&gt;&#xA;&lt;p&gt;This has mostly been a journey from implicit to explicit state. For example, Kubernetes manifests declare how much memory an application will need. This is necessary to make deployments&amp;rsquo; resources &lt;em&gt;calculable&lt;/em&gt;. But this requires more work from the software engineer, to estimate and declare the memory needed by the app.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
